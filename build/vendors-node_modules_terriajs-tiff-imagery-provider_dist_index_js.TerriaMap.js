/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
((self || window)["webpackChunkterriajs_map"] = (self || window)["webpackChunkterriajs_map"] || []).push([["vendors-node_modules_terriajs-tiff-imagery-provider_dist_index_js"],{

/***/ "./node_modules/xml-utils/count-substring.js":
/*!***************************************************!*\
  !*** ./node_modules/xml-utils/count-substring.js ***!
  \***************************************************/
/***/ ((module) => {

eval("function countSubstring(string, substring) {\n  const pattern = new RegExp(substring, \"g\");\n  const match = string.match(pattern);\n  return match ? match.length : 0;\n}\n\nmodule.exports = countSubstring;\nmodule.exports[\"default\"] = countSubstring;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveG1sLXV0aWxzL2NvdW50LXN1YnN0cmluZy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVycmlhanMtbWFwLy4vbm9kZV9tb2R1bGVzL3htbC11dGlscy9jb3VudC1zdWJzdHJpbmcuanM/ZGRlYyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBjb3VudFN1YnN0cmluZyhzdHJpbmcsIHN1YnN0cmluZykge1xuICBjb25zdCBwYXR0ZXJuID0gbmV3IFJlZ0V4cChzdWJzdHJpbmcsIFwiZ1wiKTtcbiAgY29uc3QgbWF0Y2ggPSBzdHJpbmcubWF0Y2gocGF0dGVybik7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoLmxlbmd0aCA6IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY291bnRTdWJzdHJpbmc7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gY291bnRTdWJzdHJpbmc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/xml-utils/count-substring.js\n");

/***/ }),

/***/ "./node_modules/xml-utils/find-tag-by-name.js":
/*!****************************************************!*\
  !*** ./node_modules/xml-utils/find-tag-by-name.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const indexOfMatch = __webpack_require__(/*! ./index-of-match.js */ \"./node_modules/xml-utils/index-of-match.js\");\nconst indexOfMatchEnd = __webpack_require__(/*! ./index-of-match-end.js */ \"./node_modules/xml-utils/index-of-match-end.js\");\nconst countSubstring = __webpack_require__(/*! ./count-substring.js */ \"./node_modules/xml-utils/count-substring.js\");\n\nfunction findTagByName(xml, tagName, options) {\n  const debug = (options && options.debug) || false;\n  const nested = !(options && typeof options.nested === false);\n\n  const startIndex = (options && options.startIndex) || 0;\n\n  if (debug) console.log(\"[xml-utils] starting findTagByName with\", tagName, \" and \", options);\n\n  const start = indexOfMatch(xml, `\\<${tagName}[ \\n\\>\\/]`, startIndex);\n  if (debug) console.log(\"[xml-utils] start:\", start);\n  if (start === -1) return undefined;\n\n  const afterStart = xml.slice(start + tagName.length);\n\n  let relativeEnd = indexOfMatchEnd(afterStart, \"^[^<]*[ /]>\", 0);\n\n  const selfClosing = relativeEnd !== -1 && afterStart[relativeEnd - 1] === \"/\";\n  if (debug) console.log(\"[xml-utils] selfClosing:\", selfClosing);\n\n  if (selfClosing === false) {\n    // check if tag has subtags with the same name\n    if (nested) {\n      let startIndex = 0;\n      let openings = 1;\n      let closings = 0;\n      while ((relativeEnd = indexOfMatchEnd(afterStart, \"[ /]\" + tagName + \">\", startIndex)) !== -1) {\n        const clip = afterStart.substring(startIndex, relativeEnd + 1);\n        openings += countSubstring(clip, \"<\" + tagName + \"[ \\n\\t>]\");\n        closings += countSubstring(clip, \"</\" + tagName + \">\");\n        // we can't have more openings than closings\n        if (closings >= openings) break;\n        startIndex = relativeEnd;\n      }\n    } else {\n      relativeEnd = indexOfMatchEnd(afterStart, \"[ /]\" + tagName + \">\", 0);\n    }\n  }\n\n  const end = start + tagName.length + relativeEnd + 1;\n  if (debug) console.log(\"[xml-utils] end:\", end);\n  if (end === -1) return undefined;\n\n  const outer = xml.slice(start, end);\n  // tag is like <gml:identifier codeSpace=\"OGP\">urn:ogc:def:crs:EPSG::32617</gml:identifier>\n\n  let inner;\n  if (selfClosing) {\n    inner = null;\n  } else {\n    inner = outer.slice(outer.indexOf(\">\") + 1, outer.lastIndexOf(\"<\"));\n  }\n\n  return { inner, outer, start, end };\n}\n\nmodule.exports = findTagByName;\nmodule.exports[\"default\"] = findTagByName;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveG1sLXV0aWxzL2ZpbmQtdGFnLWJ5LW5hbWUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZXJyaWFqcy1tYXAvLi9ub2RlX21vZHVsZXMveG1sLXV0aWxzL2ZpbmQtdGFnLWJ5LW5hbWUuanM/ZWJlYSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBpbmRleE9mTWF0Y2ggPSByZXF1aXJlKFwiLi9pbmRleC1vZi1tYXRjaC5qc1wiKTtcbmNvbnN0IGluZGV4T2ZNYXRjaEVuZCA9IHJlcXVpcmUoXCIuL2luZGV4LW9mLW1hdGNoLWVuZC5qc1wiKTtcbmNvbnN0IGNvdW50U3Vic3RyaW5nID0gcmVxdWlyZShcIi4vY291bnQtc3Vic3RyaW5nLmpzXCIpO1xuXG5mdW5jdGlvbiBmaW5kVGFnQnlOYW1lKHhtbCwgdGFnTmFtZSwgb3B0aW9ucykge1xuICBjb25zdCBkZWJ1ZyA9IChvcHRpb25zICYmIG9wdGlvbnMuZGVidWcpIHx8IGZhbHNlO1xuICBjb25zdCBuZXN0ZWQgPSAhKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubmVzdGVkID09PSBmYWxzZSk7XG5cbiAgY29uc3Qgc3RhcnRJbmRleCA9IChvcHRpb25zICYmIG9wdGlvbnMuc3RhcnRJbmRleCkgfHwgMDtcblxuICBpZiAoZGVidWcpIGNvbnNvbGUubG9nKFwiW3htbC11dGlsc10gc3RhcnRpbmcgZmluZFRhZ0J5TmFtZSB3aXRoXCIsIHRhZ05hbWUsIFwiIGFuZCBcIiwgb3B0aW9ucyk7XG5cbiAgY29uc3Qgc3RhcnQgPSBpbmRleE9mTWF0Y2goeG1sLCBgXFw8JHt0YWdOYW1lfVsgXFxuXFw+XFwvXWAsIHN0YXJ0SW5kZXgpO1xuICBpZiAoZGVidWcpIGNvbnNvbGUubG9nKFwiW3htbC11dGlsc10gc3RhcnQ6XCIsIHN0YXJ0KTtcbiAgaWYgKHN0YXJ0ID09PSAtMSkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICBjb25zdCBhZnRlclN0YXJ0ID0geG1sLnNsaWNlKHN0YXJ0ICsgdGFnTmFtZS5sZW5ndGgpO1xuXG4gIGxldCByZWxhdGl2ZUVuZCA9IGluZGV4T2ZNYXRjaEVuZChhZnRlclN0YXJ0LCBcIl5bXjxdKlsgL10+XCIsIDApO1xuXG4gIGNvbnN0IHNlbGZDbG9zaW5nID0gcmVsYXRpdmVFbmQgIT09IC0xICYmIGFmdGVyU3RhcnRbcmVsYXRpdmVFbmQgLSAxXSA9PT0gXCIvXCI7XG4gIGlmIChkZWJ1ZykgY29uc29sZS5sb2coXCJbeG1sLXV0aWxzXSBzZWxmQ2xvc2luZzpcIiwgc2VsZkNsb3NpbmcpO1xuXG4gIGlmIChzZWxmQ2xvc2luZyA9PT0gZmFsc2UpIHtcbiAgICAvLyBjaGVjayBpZiB0YWcgaGFzIHN1YnRhZ3Mgd2l0aCB0aGUgc2FtZSBuYW1lXG4gICAgaWYgKG5lc3RlZCkge1xuICAgICAgbGV0IHN0YXJ0SW5kZXggPSAwO1xuICAgICAgbGV0IG9wZW5pbmdzID0gMTtcbiAgICAgIGxldCBjbG9zaW5ncyA9IDA7XG4gICAgICB3aGlsZSAoKHJlbGF0aXZlRW5kID0gaW5kZXhPZk1hdGNoRW5kKGFmdGVyU3RhcnQsIFwiWyAvXVwiICsgdGFnTmFtZSArIFwiPlwiLCBzdGFydEluZGV4KSkgIT09IC0xKSB7XG4gICAgICAgIGNvbnN0IGNsaXAgPSBhZnRlclN0YXJ0LnN1YnN0cmluZyhzdGFydEluZGV4LCByZWxhdGl2ZUVuZCArIDEpO1xuICAgICAgICBvcGVuaW5ncyArPSBjb3VudFN1YnN0cmluZyhjbGlwLCBcIjxcIiArIHRhZ05hbWUgKyBcIlsgXFxuXFx0Pl1cIik7XG4gICAgICAgIGNsb3NpbmdzICs9IGNvdW50U3Vic3RyaW5nKGNsaXAsIFwiPC9cIiArIHRhZ05hbWUgKyBcIj5cIik7XG4gICAgICAgIC8vIHdlIGNhbid0IGhhdmUgbW9yZSBvcGVuaW5ncyB0aGFuIGNsb3NpbmdzXG4gICAgICAgIGlmIChjbG9zaW5ncyA+PSBvcGVuaW5ncykgYnJlYWs7XG4gICAgICAgIHN0YXJ0SW5kZXggPSByZWxhdGl2ZUVuZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVsYXRpdmVFbmQgPSBpbmRleE9mTWF0Y2hFbmQoYWZ0ZXJTdGFydCwgXCJbIC9dXCIgKyB0YWdOYW1lICsgXCI+XCIsIDApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGVuZCA9IHN0YXJ0ICsgdGFnTmFtZS5sZW5ndGggKyByZWxhdGl2ZUVuZCArIDE7XG4gIGlmIChkZWJ1ZykgY29uc29sZS5sb2coXCJbeG1sLXV0aWxzXSBlbmQ6XCIsIGVuZCk7XG4gIGlmIChlbmQgPT09IC0xKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gIGNvbnN0IG91dGVyID0geG1sLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAvLyB0YWcgaXMgbGlrZSA8Z21sOmlkZW50aWZpZXIgY29kZVNwYWNlPVwiT0dQXCI+dXJuOm9nYzpkZWY6Y3JzOkVQU0c6OjMyNjE3PC9nbWw6aWRlbnRpZmllcj5cblxuICBsZXQgaW5uZXI7XG4gIGlmIChzZWxmQ2xvc2luZykge1xuICAgIGlubmVyID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICBpbm5lciA9IG91dGVyLnNsaWNlKG91dGVyLmluZGV4T2YoXCI+XCIpICsgMSwgb3V0ZXIubGFzdEluZGV4T2YoXCI8XCIpKTtcbiAgfVxuXG4gIHJldHVybiB7IGlubmVyLCBvdXRlciwgc3RhcnQsIGVuZCB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmRUYWdCeU5hbWU7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZmluZFRhZ0J5TmFtZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/xml-utils/find-tag-by-name.js\n");

/***/ }),

/***/ "./node_modules/xml-utils/find-tags-by-name.js":
/*!*****************************************************!*\
  !*** ./node_modules/xml-utils/find-tags-by-name.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const findTagByName = __webpack_require__(/*! ./find-tag-by-name.js */ \"./node_modules/xml-utils/find-tag-by-name.js\");\n\nfunction findTagsByName(xml, tagName, options) {\n  const tags = [];\n  const debug = (options && options.debug) || false;\n  const nested = options && typeof options.nested === \"boolean\" ? options.nested : true;\n  let startIndex = (options && options.startIndex) || 0;\n  let tag;\n  while ((tag = findTagByName(xml, tagName, { debug, startIndex }))) {\n    if (nested) {\n      startIndex = tag.start + 1 + tagName.length;\n    } else {\n      startIndex = tag.end;\n    }\n    tags.push(tag);\n  }\n  if (debug) console.log(\"findTagsByName found\", tags.length, \"tags\");\n  return tags;\n}\n\nmodule.exports = findTagsByName;\nmodule.exports[\"default\"] = findTagsByName;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveG1sLXV0aWxzL2ZpbmQtdGFncy1ieS1uYW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVycmlhanMtbWFwLy4vbm9kZV9tb2R1bGVzL3htbC11dGlscy9maW5kLXRhZ3MtYnktbmFtZS5qcz81ZWRmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGZpbmRUYWdCeU5hbWUgPSByZXF1aXJlKFwiLi9maW5kLXRhZy1ieS1uYW1lLmpzXCIpO1xuXG5mdW5jdGlvbiBmaW5kVGFnc0J5TmFtZSh4bWwsIHRhZ05hbWUsIG9wdGlvbnMpIHtcbiAgY29uc3QgdGFncyA9IFtdO1xuICBjb25zdCBkZWJ1ZyA9IChvcHRpb25zICYmIG9wdGlvbnMuZGVidWcpIHx8IGZhbHNlO1xuICBjb25zdCBuZXN0ZWQgPSBvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm5lc3RlZCA9PT0gXCJib29sZWFuXCIgPyBvcHRpb25zLm5lc3RlZCA6IHRydWU7XG4gIGxldCBzdGFydEluZGV4ID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5zdGFydEluZGV4KSB8fCAwO1xuICBsZXQgdGFnO1xuICB3aGlsZSAoKHRhZyA9IGZpbmRUYWdCeU5hbWUoeG1sLCB0YWdOYW1lLCB7IGRlYnVnLCBzdGFydEluZGV4IH0pKSkge1xuICAgIGlmIChuZXN0ZWQpIHtcbiAgICAgIHN0YXJ0SW5kZXggPSB0YWcuc3RhcnQgKyAxICsgdGFnTmFtZS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0SW5kZXggPSB0YWcuZW5kO1xuICAgIH1cbiAgICB0YWdzLnB1c2godGFnKTtcbiAgfVxuICBpZiAoZGVidWcpIGNvbnNvbGUubG9nKFwiZmluZFRhZ3NCeU5hbWUgZm91bmRcIiwgdGFncy5sZW5ndGgsIFwidGFnc1wiKTtcbiAgcmV0dXJuIHRhZ3M7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZFRhZ3NCeU5hbWU7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZmluZFRhZ3NCeU5hbWU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/xml-utils/find-tags-by-name.js\n");

/***/ }),

/***/ "./node_modules/xml-utils/get-attribute.js":
/*!*************************************************!*\
  !*** ./node_modules/xml-utils/get-attribute.js ***!
  \*************************************************/
/***/ ((module) => {

eval("function getAttribute(tag, attributeName, options) {\n  const debug = (options && options.debug) || false;\n  if (debug) console.log(\"[xml-utils] getting \" + attributeName + \" in \" + tag);\n\n  const xml = typeof tag === \"object\" ? tag.outer : tag;\n\n  // only search for attributes in the opening tag\n  const opening = xml.slice(0, xml.indexOf(\">\") + 1);\n\n  const quotechars = ['\"', \"'\"];\n  for (let i = 0; i < quotechars.length; i++) {\n    const char = quotechars[i];\n    const pattern = attributeName + \"\\\\=\" + char + \"([^\" + char + \"]*)\" + char;\n    if (debug) console.log(\"[xml-utils] pattern:\", pattern);\n\n    const re = new RegExp(pattern);\n    const match = re.exec(opening);\n    if (debug) console.log(\"[xml-utils] match:\", match);\n    if (match) return match[1];\n  }\n}\n\nmodule.exports = getAttribute;\nmodule.exports[\"default\"] = getAttribute;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveG1sLXV0aWxzL2dldC1hdHRyaWJ1dGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVycmlhanMtbWFwLy4vbm9kZV9tb2R1bGVzL3htbC11dGlscy9nZXQtYXR0cmlidXRlLmpzPzk0ZGYiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gZ2V0QXR0cmlidXRlKHRhZywgYXR0cmlidXRlTmFtZSwgb3B0aW9ucykge1xuICBjb25zdCBkZWJ1ZyA9IChvcHRpb25zICYmIG9wdGlvbnMuZGVidWcpIHx8IGZhbHNlO1xuICBpZiAoZGVidWcpIGNvbnNvbGUubG9nKFwiW3htbC11dGlsc10gZ2V0dGluZyBcIiArIGF0dHJpYnV0ZU5hbWUgKyBcIiBpbiBcIiArIHRhZyk7XG5cbiAgY29uc3QgeG1sID0gdHlwZW9mIHRhZyA9PT0gXCJvYmplY3RcIiA/IHRhZy5vdXRlciA6IHRhZztcblxuICAvLyBvbmx5IHNlYXJjaCBmb3IgYXR0cmlidXRlcyBpbiB0aGUgb3BlbmluZyB0YWdcbiAgY29uc3Qgb3BlbmluZyA9IHhtbC5zbGljZSgwLCB4bWwuaW5kZXhPZihcIj5cIikgKyAxKTtcblxuICBjb25zdCBxdW90ZWNoYXJzID0gWydcIicsIFwiJ1wiXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdW90ZWNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hhciA9IHF1b3RlY2hhcnNbaV07XG4gICAgY29uc3QgcGF0dGVybiA9IGF0dHJpYnV0ZU5hbWUgKyBcIlxcXFw9XCIgKyBjaGFyICsgXCIoW15cIiArIGNoYXIgKyBcIl0qKVwiICsgY2hhcjtcbiAgICBpZiAoZGVidWcpIGNvbnNvbGUubG9nKFwiW3htbC11dGlsc10gcGF0dGVybjpcIiwgcGF0dGVybik7XG5cbiAgICBjb25zdCByZSA9IG5ldyBSZWdFeHAocGF0dGVybik7XG4gICAgY29uc3QgbWF0Y2ggPSByZS5leGVjKG9wZW5pbmcpO1xuICAgIGlmIChkZWJ1ZykgY29uc29sZS5sb2coXCJbeG1sLXV0aWxzXSBtYXRjaDpcIiwgbWF0Y2gpO1xuICAgIGlmIChtYXRjaCkgcmV0dXJuIG1hdGNoWzFdO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QXR0cmlidXRlO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGdldEF0dHJpYnV0ZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/xml-utils/get-attribute.js\n");

/***/ }),

/***/ "./node_modules/xml-utils/index-of-match-end.js":
/*!******************************************************!*\
  !*** ./node_modules/xml-utils/index-of-match-end.js ***!
  \******************************************************/
/***/ ((module) => {

eval("function indexOfMatchEnd(xml, pattern, startIndex) {\n  const re = new RegExp(pattern);\n  const match = re.exec(xml.slice(startIndex));\n  if (match) return startIndex + match.index + match[0].length - 1;\n  else return -1;\n}\n\nmodule.exports = indexOfMatchEnd;\nmodule.exports[\"default\"] = indexOfMatchEnd;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveG1sLXV0aWxzL2luZGV4LW9mLW1hdGNoLWVuZC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZXJyaWFqcy1tYXAvLi9ub2RlX21vZHVsZXMveG1sLXV0aWxzL2luZGV4LW9mLW1hdGNoLWVuZC5qcz82NThlIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGluZGV4T2ZNYXRjaEVuZCh4bWwsIHBhdHRlcm4sIHN0YXJ0SW5kZXgpIHtcbiAgY29uc3QgcmUgPSBuZXcgUmVnRXhwKHBhdHRlcm4pO1xuICBjb25zdCBtYXRjaCA9IHJlLmV4ZWMoeG1sLnNsaWNlKHN0YXJ0SW5kZXgpKTtcbiAgaWYgKG1hdGNoKSByZXR1cm4gc3RhcnRJbmRleCArIG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIC0gMTtcbiAgZWxzZSByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5kZXhPZk1hdGNoRW5kO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGluZGV4T2ZNYXRjaEVuZDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/xml-utils/index-of-match-end.js\n");

/***/ }),

/***/ "./node_modules/xml-utils/index-of-match.js":
/*!**************************************************!*\
  !*** ./node_modules/xml-utils/index-of-match.js ***!
  \**************************************************/
/***/ ((module) => {

eval("function indexOfMatch(xml, pattern, startIndex) {\n  const re = new RegExp(pattern);\n  const match = re.exec(xml.slice(startIndex));\n  if (match) return startIndex + match.index;\n  else return -1;\n}\n\nmodule.exports = indexOfMatch;\nmodule.exports[\"default\"] = indexOfMatch;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveG1sLXV0aWxzL2luZGV4LW9mLW1hdGNoLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlcnJpYWpzLW1hcC8uL25vZGVfbW9kdWxlcy94bWwtdXRpbHMvaW5kZXgtb2YtbWF0Y2guanM/ZjQ2MCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBpbmRleE9mTWF0Y2goeG1sLCBwYXR0ZXJuLCBzdGFydEluZGV4KSB7XG4gIGNvbnN0IHJlID0gbmV3IFJlZ0V4cChwYXR0ZXJuKTtcbiAgY29uc3QgbWF0Y2ggPSByZS5leGVjKHhtbC5zbGljZShzdGFydEluZGV4KSk7XG4gIGlmIChtYXRjaCkgcmV0dXJuIHN0YXJ0SW5kZXggKyBtYXRjaC5pbmRleDtcbiAgZWxzZSByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5kZXhPZk1hdGNoO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGluZGV4T2ZNYXRjaDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/xml-utils/index-of-match.js\n");

/***/ }),

/***/ "./node_modules/@petamoriken/float16/src/DataView.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@petamoriken/float16/src/DataView.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFloat16: () => (/* binding */ getFloat16),\n/* harmony export */   setFloat16: () => (/* binding */ setFloat16)\n/* harmony export */ });\n/* harmony import */ var _util_arrayIterator_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_util/arrayIterator.mjs */ \"./node_modules/@petamoriken/float16/src/_util/arrayIterator.mjs\");\n/* harmony import */ var _util_converter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_util/converter.mjs */ \"./node_modules/@petamoriken/float16/src/_util/converter.mjs\");\n/* harmony import */ var _util_primordials_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_util/primordials.mjs */ \"./node_modules/@petamoriken/float16/src/_util/primordials.mjs\");\n\n\n\n\n/**\n * returns an unsigned 16-bit float at the specified byte offset from the start of the DataView\n * @param {DataView} dataView\n * @param {number} byteOffset\n * @param {[boolean]} opts\n * @returns {number}\n */\nfunction getFloat16(dataView, byteOffset, ...opts) {\n  return (0,_util_converter_mjs__WEBPACK_IMPORTED_MODULE_0__.convertToNumber)(\n    (0,_util_primordials_mjs__WEBPACK_IMPORTED_MODULE_1__.DataViewPrototypeGetUint16)(dataView, byteOffset, ...(0,_util_arrayIterator_mjs__WEBPACK_IMPORTED_MODULE_2__.safeIfNeeded)(opts))\n  );\n}\n\n/**\n * stores an unsigned 16-bit float value at the specified byte offset from the start of the DataView\n * @param {DataView} dataView\n * @param {number} byteOffset\n * @param {number} value\n * @param {[boolean]} opts\n */\nfunction setFloat16(dataView, byteOffset, value, ...opts) {\n  return (0,_util_primordials_mjs__WEBPACK_IMPORTED_MODULE_1__.DataViewPrototypeSetUint16)(\n    dataView,\n    byteOffset,\n    (0,_util_converter_mjs__WEBPACK_IMPORTED_MODULE_0__.roundToFloat16Bits)(value),\n    ...(0,_util_arrayIterator_mjs__WEBPACK_IMPORTED_MODULE_2__.safeIfNeeded)(opts)\n  );\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBldGFtb3Jpa2VuL2Zsb2F0MTYvc3JjL0RhdGFWaWV3Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZXJyaWFqcy1tYXAvLi9ub2RlX21vZHVsZXMvQHBldGFtb3Jpa2VuL2Zsb2F0MTYvc3JjL0RhdGFWaWV3Lm1qcz82MzllIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNhZmVJZk5lZWRlZCB9IGZyb20gXCIuL191dGlsL2FycmF5SXRlcmF0b3IubWpzXCI7XG5pbXBvcnQgeyBjb252ZXJ0VG9OdW1iZXIsIHJvdW5kVG9GbG9hdDE2Qml0cyB9IGZyb20gXCIuL191dGlsL2NvbnZlcnRlci5tanNcIjtcbmltcG9ydCB7XG4gIERhdGFWaWV3UHJvdG90eXBlR2V0VWludDE2LFxuICBEYXRhVmlld1Byb3RvdHlwZVNldFVpbnQxNixcbn0gZnJvbSBcIi4vX3V0aWwvcHJpbW9yZGlhbHMubWpzXCI7XG5cbi8qKlxuICogcmV0dXJucyBhbiB1bnNpZ25lZCAxNi1iaXQgZmxvYXQgYXQgdGhlIHNwZWNpZmllZCBieXRlIG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgRGF0YVZpZXdcbiAqIEBwYXJhbSB7RGF0YVZpZXd9IGRhdGFWaWV3XG4gKiBAcGFyYW0ge251bWJlcn0gYnl0ZU9mZnNldFxuICogQHBhcmFtIHtbYm9vbGVhbl19IG9wdHNcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGbG9hdDE2KGRhdGFWaWV3LCBieXRlT2Zmc2V0LCAuLi5vcHRzKSB7XG4gIHJldHVybiBjb252ZXJ0VG9OdW1iZXIoXG4gICAgRGF0YVZpZXdQcm90b3R5cGVHZXRVaW50MTYoZGF0YVZpZXcsIGJ5dGVPZmZzZXQsIC4uLnNhZmVJZk5lZWRlZChvcHRzKSlcbiAgKTtcbn1cblxuLyoqXG4gKiBzdG9yZXMgYW4gdW5zaWduZWQgMTYtYml0IGZsb2F0IHZhbHVlIGF0IHRoZSBzcGVjaWZpZWQgYnl0ZSBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIERhdGFWaWV3XG4gKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhVmlld1xuICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVPZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtbYm9vbGVhbl19IG9wdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEZsb2F0MTYoZGF0YVZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCAuLi5vcHRzKSB7XG4gIHJldHVybiBEYXRhVmlld1Byb3RvdHlwZVNldFVpbnQxNihcbiAgICBkYXRhVmlldyxcbiAgICBieXRlT2Zmc2V0LFxuICAgIHJvdW5kVG9GbG9hdDE2Qml0cyh2YWx1ZSksXG4gICAgLi4uc2FmZUlmTmVlZGVkKG9wdHMpXG4gICk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@petamoriken/float16/src/DataView.mjs\n");

/***/ }),

/***/ "./node_modules/@petamoriken/float16/src/_util/arrayIterator.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@petamoriken/float16/src/_util/arrayIterator.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   safeIfNeeded: () => (/* binding */ safeIfNeeded),\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\n/* harmony import */ var _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./primordials.mjs */ \"./node_modules/@petamoriken/float16/src/_util/primordials.mjs\");\n\n\n/** @type {WeakMap<{}, IterableIterator<any>>} */\nconst arrayIterators = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeWeakMap();\n\nconst SafeIteratorPrototype = (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ObjectCreate)(null, {\n  next: {\n    value: function next() {\n      const arrayIterator = (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.WeakMapPrototypeGet)(arrayIterators, this);\n      return (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ArrayIteratorPrototypeNext)(arrayIterator);\n    },\n  },\n\n  [_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.SymbolIterator]: {\n    value: function values() {\n      return this;\n    },\n  },\n});\n\n/**\n * Wrap the Array around the SafeIterator If Array.prototype [@@iterator] has been modified\n * @type {<T>(array: T[]) => Iterable<T>}\n */\nfunction safeIfNeeded(array) {\n  if (\n    array[_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.SymbolIterator] === _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeArrayPrototypeSymbolIterator &&\n    _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ArrayIteratorPrototype.next === _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ArrayIteratorPrototypeNext\n  ) {\n    return array;\n  }\n\n  const safe = (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ObjectCreate)(SafeIteratorPrototype);\n  (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.WeakMapPrototypeSet)(arrayIterators, safe, (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ArrayPrototypeSymbolIterator)(array));\n  return safe;\n}\n\n/** @type {WeakMap<{}, Generator<any>>} */\nconst generators = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeWeakMap();\n\n/** @see https://tc39.es/ecma262/#sec-%arrayiteratorprototype%-object */\nconst DummyArrayIteratorPrototype = (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ObjectCreate)(_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.IteratorPrototype, {\n  next: {\n    value: function next() {\n      const generator = (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.WeakMapPrototypeGet)(generators, this);\n      return (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.GeneratorPrototypeNext)(generator);\n    },\n    writable: true,\n    configurable: true,\n  },\n});\n\nfor (const key of (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ReflectOwnKeys)(_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ArrayIteratorPrototype)) {\n  // next method has already defined\n  if (key === \"next\") {\n    continue;\n  }\n\n  // Copy ArrayIteratorPrototype descriptors to DummyArrayIteratorPrototype\n  (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ObjectDefineProperty)(DummyArrayIteratorPrototype, key, (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ReflectGetOwnPropertyDescriptor)(_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ArrayIteratorPrototype, key));\n}\n\n/**\n * Wrap the Generator around the dummy ArrayIterator\n * @type {<T>(generator: Generator<T>) => IterableIterator<T>}\n */\nfunction wrap(generator) {\n  const dummy = (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.ObjectCreate)(DummyArrayIteratorPrototype);\n  (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.WeakMapPrototypeSet)(generators, dummy, generator);\n  return dummy;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBldGFtb3Jpa2VuL2Zsb2F0MTYvc3JjL191dGlsL2FycmF5SXRlcmF0b3IubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZXJyaWFqcy1tYXAvLi9ub2RlX21vZHVsZXMvQHBldGFtb3Jpa2VuL2Zsb2F0MTYvc3JjL191dGlsL2FycmF5SXRlcmF0b3IubWpzPzMyYjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQXJyYXlJdGVyYXRvclByb3RvdHlwZSxcbiAgQXJyYXlJdGVyYXRvclByb3RvdHlwZU5leHQsXG4gIEFycmF5UHJvdG90eXBlU3ltYm9sSXRlcmF0b3IsXG4gIEdlbmVyYXRvclByb3RvdHlwZU5leHQsXG4gIEl0ZXJhdG9yUHJvdG90eXBlLFxuICBOYXRpdmVBcnJheVByb3RvdHlwZVN5bWJvbEl0ZXJhdG9yLFxuICBOYXRpdmVXZWFrTWFwLFxuICBPYmplY3RDcmVhdGUsXG4gIE9iamVjdERlZmluZVByb3BlcnR5LFxuICBSZWZsZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICBSZWZsZWN0T3duS2V5cyxcbiAgU3ltYm9sSXRlcmF0b3IsXG4gIFdlYWtNYXBQcm90b3R5cGVHZXQsXG4gIFdlYWtNYXBQcm90b3R5cGVTZXQsXG59IGZyb20gXCIuL3ByaW1vcmRpYWxzLm1qc1wiO1xuXG4vKiogQHR5cGUge1dlYWtNYXA8e30sIEl0ZXJhYmxlSXRlcmF0b3I8YW55Pj59ICovXG5jb25zdCBhcnJheUl0ZXJhdG9ycyA9IG5ldyBOYXRpdmVXZWFrTWFwKCk7XG5cbmNvbnN0IFNhZmVJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdENyZWF0ZShudWxsLCB7XG4gIG5leHQ6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIGNvbnN0IGFycmF5SXRlcmF0b3IgPSBXZWFrTWFwUHJvdG90eXBlR2V0KGFycmF5SXRlcmF0b3JzLCB0aGlzKTtcbiAgICAgIHJldHVybiBBcnJheUl0ZXJhdG9yUHJvdG90eXBlTmV4dChhcnJheUl0ZXJhdG9yKTtcbiAgICB9LFxuICB9LFxuXG4gIFtTeW1ib2xJdGVyYXRvcl06IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgfSxcbn0pO1xuXG4vKipcbiAqIFdyYXAgdGhlIEFycmF5IGFyb3VuZCB0aGUgU2FmZUl0ZXJhdG9yIElmIEFycmF5LnByb3RvdHlwZSBbQEBpdGVyYXRvcl0gaGFzIGJlZW4gbW9kaWZpZWRcbiAqIEB0eXBlIHs8VD4oYXJyYXk6IFRbXSkgPT4gSXRlcmFibGU8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYWZlSWZOZWVkZWQoYXJyYXkpIHtcbiAgaWYgKFxuICAgIGFycmF5W1N5bWJvbEl0ZXJhdG9yXSA9PT0gTmF0aXZlQXJyYXlQcm90b3R5cGVTeW1ib2xJdGVyYXRvciAmJlxuICAgIEFycmF5SXRlcmF0b3JQcm90b3R5cGUubmV4dCA9PT0gQXJyYXlJdGVyYXRvclByb3RvdHlwZU5leHRcbiAgKSB7XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgY29uc3Qgc2FmZSA9IE9iamVjdENyZWF0ZShTYWZlSXRlcmF0b3JQcm90b3R5cGUpO1xuICBXZWFrTWFwUHJvdG90eXBlU2V0KGFycmF5SXRlcmF0b3JzLCBzYWZlLCBBcnJheVByb3RvdHlwZVN5bWJvbEl0ZXJhdG9yKGFycmF5KSk7XG4gIHJldHVybiBzYWZlO1xufVxuXG4vKiogQHR5cGUge1dlYWtNYXA8e30sIEdlbmVyYXRvcjxhbnk+Pn0gKi9cbmNvbnN0IGdlbmVyYXRvcnMgPSBuZXcgTmF0aXZlV2Vha01hcCgpO1xuXG4vKiogQHNlZSBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVhcnJheWl0ZXJhdG9ycHJvdG90eXBlJS1vYmplY3QgKi9cbmNvbnN0IER1bW15QXJyYXlJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdENyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwge1xuICBuZXh0OiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICBjb25zdCBnZW5lcmF0b3IgPSBXZWFrTWFwUHJvdG90eXBlR2V0KGdlbmVyYXRvcnMsIHRoaXMpO1xuICAgICAgcmV0dXJuIEdlbmVyYXRvclByb3RvdHlwZU5leHQoZ2VuZXJhdG9yKTtcbiAgICB9LFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgfSxcbn0pO1xuXG5mb3IgKGNvbnN0IGtleSBvZiBSZWZsZWN0T3duS2V5cyhBcnJheUl0ZXJhdG9yUHJvdG90eXBlKSkge1xuICAvLyBuZXh0IG1ldGhvZCBoYXMgYWxyZWFkeSBkZWZpbmVkXG4gIGlmIChrZXkgPT09IFwibmV4dFwiKSB7XG4gICAgY29udGludWU7XG4gIH1cblxuICAvLyBDb3B5IEFycmF5SXRlcmF0b3JQcm90b3R5cGUgZGVzY3JpcHRvcnMgdG8gRHVtbXlBcnJheUl0ZXJhdG9yUHJvdG90eXBlXG4gIE9iamVjdERlZmluZVByb3BlcnR5KER1bW15QXJyYXlJdGVyYXRvclByb3RvdHlwZSwga2V5LCBSZWZsZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEFycmF5SXRlcmF0b3JQcm90b3R5cGUsIGtleSkpO1xufVxuXG4vKipcbiAqIFdyYXAgdGhlIEdlbmVyYXRvciBhcm91bmQgdGhlIGR1bW15IEFycmF5SXRlcmF0b3JcbiAqIEB0eXBlIHs8VD4oZ2VuZXJhdG9yOiBHZW5lcmF0b3I8VD4pID0+IEl0ZXJhYmxlSXRlcmF0b3I8VD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwKGdlbmVyYXRvcikge1xuICBjb25zdCBkdW1teSA9IE9iamVjdENyZWF0ZShEdW1teUFycmF5SXRlcmF0b3JQcm90b3R5cGUpO1xuICBXZWFrTWFwUHJvdG90eXBlU2V0KGdlbmVyYXRvcnMsIGR1bW15LCBnZW5lcmF0b3IpO1xuICByZXR1cm4gZHVtbXk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@petamoriken/float16/src/_util/arrayIterator.mjs\n");

/***/ }),

/***/ "./node_modules/@petamoriken/float16/src/_util/converter.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@petamoriken/float16/src/_util/converter.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertToNumber: () => (/* binding */ convertToNumber),\n/* harmony export */   roundToFloat16: () => (/* binding */ roundToFloat16),\n/* harmony export */   roundToFloat16Bits: () => (/* binding */ roundToFloat16Bits)\n/* harmony export */ });\n/* harmony import */ var _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./primordials.mjs */ \"./node_modules/@petamoriken/float16/src/_util/primordials.mjs\");\n\n\nconst INVERSE_OF_EPSILON = 1 / _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.EPSILON;\n\n/**\n * rounds to the nearest value;\n * if the number falls midway, it is rounded to the nearest value with an even least significant digit\n * @param {number} num\n * @returns {number}\n */\nfunction roundTiesToEven(num) {\n  return (num + INVERSE_OF_EPSILON) - INVERSE_OF_EPSILON;\n}\n\nconst FLOAT16_MIN_VALUE = 6.103515625e-05;\nconst FLOAT16_MAX_VALUE = 65504;\nconst FLOAT16_EPSILON = 0.0009765625;\n\nconst FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE = FLOAT16_EPSILON * FLOAT16_MIN_VALUE;\nconst FLOAT16_EPSILON_DEVIDED_BY_EPSILON = FLOAT16_EPSILON * INVERSE_OF_EPSILON;\n\n/**\n * round a number to a half float number\n * @param {unknown} num - double float\n * @returns {number} half float number\n */\nfunction roundToFloat16(num) {\n  const number = +num;\n\n  // NaN, Infinity, -Infinity, 0, -0\n  if (!(0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NumberIsFinite)(number) || number === 0) {\n    return number;\n  }\n\n  // finite except 0, -0\n  const sign = number > 0 ? 1 : -1;\n  const absolute = (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.MathAbs)(number);\n\n  // small number\n  if (absolute < FLOAT16_MIN_VALUE) {\n    return sign * roundTiesToEven(absolute / FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE) * FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE;\n  }\n\n  const temp = (1 + FLOAT16_EPSILON_DEVIDED_BY_EPSILON) * absolute;\n  const result = temp - (temp - absolute);\n\n  // large number\n  if (result > FLOAT16_MAX_VALUE || (0,_primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NumberIsNaN)(result)) {\n    return sign * Infinity;\n  }\n\n  return sign * result;\n}\n\n// base algorithm: http://fox-toolkit.org/ftp/fasthalffloatconversion.pdf\n\nconst buffer = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeArrayBuffer(4);\nconst floatView = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeFloat32Array(buffer);\nconst uint32View = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeUint32Array(buffer);\n\nconst baseTable = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeUint16Array(512);\nconst shiftTable = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeUint8Array(512);\n\nfor (let i = 0; i < 256; ++i) {\n  const e = i - 127;\n\n  // very small number (0, -0)\n  if (e < -24) {\n    baseTable[i]         = 0x0000;\n    baseTable[i | 0x100] = 0x8000;\n    shiftTable[i]         = 24;\n    shiftTable[i | 0x100] = 24;\n\n  // small number (denorm)\n  } else if (e < -14) {\n    baseTable[i]         =  0x0400 >> (-e - 14);\n    baseTable[i | 0x100] = (0x0400 >> (-e - 14)) | 0x8000;\n    shiftTable[i]         = -e - 1;\n    shiftTable[i | 0x100] = -e - 1;\n\n  // normal number\n  } else if (e <= 15) {\n    baseTable[i]         =  (e + 15) << 10;\n    baseTable[i | 0x100] = ((e + 15) << 10) | 0x8000;\n    shiftTable[i]         = 13;\n    shiftTable[i | 0x100] = 13;\n\n  // large number (Infinity, -Infinity)\n  } else if (e < 128) {\n    baseTable[i]         = 0x7c00;\n    baseTable[i | 0x100] = 0xfc00;\n    shiftTable[i]         = 24;\n    shiftTable[i | 0x100] = 24;\n\n  // stay (NaN, Infinity, -Infinity)\n  } else {\n    baseTable[i]         = 0x7c00;\n    baseTable[i | 0x100] = 0xfc00;\n    shiftTable[i]         = 13;\n    shiftTable[i | 0x100] = 13;\n  }\n}\n\n/**\n * round a number to a half float number bits\n * @param {unknown} num - double float\n * @returns {number} half float number bits\n */\nfunction roundToFloat16Bits(num) {\n  floatView[0] = roundToFloat16(num);\n  const f = uint32View[0];\n  const e = (f >> 23) & 0x1ff;\n  return baseTable[e] + ((f & 0x007fffff) >> shiftTable[e]);\n}\n\nconst mantissaTable = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeUint32Array(2048);\nfor (let i = 1; i < 1024; ++i) {\n  let m = i << 13; // zero pad mantissa bits\n  let e = 0; // zero exponent\n\n  // normalized\n  while ((m & 0x00800000) === 0) {\n    m <<= 1;\n    e -= 0x00800000; // decrement exponent\n  }\n\n  m &= ~0x00800000; // clear leading 1 bit\n  e += 0x38800000; // adjust bias\n\n  mantissaTable[i] = m | e;\n}\nfor (let i = 1024; i < 2048; ++i) {\n  mantissaTable[i] = 0x38000000 + ((i - 1024) << 13);\n}\n\nconst exponentTable = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeUint32Array(64);\nfor (let i = 1; i < 31; ++i) {\n  exponentTable[i] = i << 23;\n}\nexponentTable[31] = 0x47800000;\nexponentTable[32] = 0x80000000;\nfor (let i = 33; i < 63; ++i) {\n  exponentTable[i] = 0x80000000 + ((i - 32) << 23);\n}\nexponentTable[63] = 0xc7800000;\n\nconst offsetTable = new _primordials_mjs__WEBPACK_IMPORTED_MODULE_0__.NativeUint16Array(64);\nfor (let i = 1; i < 64; ++i) {\n  if (i !== 32) {\n    offsetTable[i] = 1024;\n  }\n}\n\n/**\n * convert a half float number bits to a number\n * @param {number} float16bits - half float number bits\n * @returns {number} double float\n */\nfunction convertToNumber(float16bits) {\n  const i = float16bits >> 10;\n  uint32View[0] = mantissaTable[offsetTable[i] + (float16bits & 0x3ff)] + exponentTable[i];\n  return floatView[0];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBldGFtb3Jpa2VuL2Zsb2F0MTYvc3JjL191dGlsL2NvbnZlcnRlci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVycmlhanMtbWFwLy4vbm9kZV9tb2R1bGVzL0BwZXRhbW9yaWtlbi9mbG9hdDE2L3NyYy9fdXRpbC9jb252ZXJ0ZXIubWpzPzcwZDUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgRVBTSUxPTixcbiAgTWF0aEFicyxcbiAgTmF0aXZlQXJyYXlCdWZmZXIsXG4gIE5hdGl2ZUZsb2F0MzJBcnJheSxcbiAgTmF0aXZlVWludDE2QXJyYXksXG4gIE5hdGl2ZVVpbnQzMkFycmF5LFxuICBOYXRpdmVVaW50OEFycmF5LFxuICBOdW1iZXJJc0Zpbml0ZSxcbiAgTnVtYmVySXNOYU4sXG59IGZyb20gXCIuL3ByaW1vcmRpYWxzLm1qc1wiO1xuXG5jb25zdCBJTlZFUlNFX09GX0VQU0lMT04gPSAxIC8gRVBTSUxPTjtcblxuLyoqXG4gKiByb3VuZHMgdG8gdGhlIG5lYXJlc3QgdmFsdWU7XG4gKiBpZiB0aGUgbnVtYmVyIGZhbGxzIG1pZHdheSwgaXQgaXMgcm91bmRlZCB0byB0aGUgbmVhcmVzdCB2YWx1ZSB3aXRoIGFuIGV2ZW4gbGVhc3Qgc2lnbmlmaWNhbnQgZGlnaXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHJvdW5kVGllc1RvRXZlbihudW0pIHtcbiAgcmV0dXJuIChudW0gKyBJTlZFUlNFX09GX0VQU0lMT04pIC0gSU5WRVJTRV9PRl9FUFNJTE9OO1xufVxuXG5jb25zdCBGTE9BVDE2X01JTl9WQUxVRSA9IDYuMTAzNTE1NjI1ZS0wNTtcbmNvbnN0IEZMT0FUMTZfTUFYX1ZBTFVFID0gNjU1MDQ7XG5jb25zdCBGTE9BVDE2X0VQU0lMT04gPSAwLjAwMDk3NjU2MjU7XG5cbmNvbnN0IEZMT0FUMTZfRVBTSUxPTl9NVUxUSVBMSUVEX0JZX0ZMT0FUMTZfTUlOX1ZBTFVFID0gRkxPQVQxNl9FUFNJTE9OICogRkxPQVQxNl9NSU5fVkFMVUU7XG5jb25zdCBGTE9BVDE2X0VQU0lMT05fREVWSURFRF9CWV9FUFNJTE9OID0gRkxPQVQxNl9FUFNJTE9OICogSU5WRVJTRV9PRl9FUFNJTE9OO1xuXG4vKipcbiAqIHJvdW5kIGEgbnVtYmVyIHRvIGEgaGFsZiBmbG9hdCBudW1iZXJcbiAqIEBwYXJhbSB7dW5rbm93bn0gbnVtIC0gZG91YmxlIGZsb2F0XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBoYWxmIGZsb2F0IG51bWJlclxuICovXG5leHBvcnQgZnVuY3Rpb24gcm91bmRUb0Zsb2F0MTYobnVtKSB7XG4gIGNvbnN0IG51bWJlciA9ICtudW07XG5cbiAgLy8gTmFOLCBJbmZpbml0eSwgLUluZmluaXR5LCAwLCAtMFxuICBpZiAoIU51bWJlcklzRmluaXRlKG51bWJlcikgfHwgbnVtYmVyID09PSAwKSB7XG4gICAgcmV0dXJuIG51bWJlcjtcbiAgfVxuXG4gIC8vIGZpbml0ZSBleGNlcHQgMCwgLTBcbiAgY29uc3Qgc2lnbiA9IG51bWJlciA+IDAgPyAxIDogLTE7XG4gIGNvbnN0IGFic29sdXRlID0gTWF0aEFicyhudW1iZXIpO1xuXG4gIC8vIHNtYWxsIG51bWJlclxuICBpZiAoYWJzb2x1dGUgPCBGTE9BVDE2X01JTl9WQUxVRSkge1xuICAgIHJldHVybiBzaWduICogcm91bmRUaWVzVG9FdmVuKGFic29sdXRlIC8gRkxPQVQxNl9FUFNJTE9OX01VTFRJUExJRURfQllfRkxPQVQxNl9NSU5fVkFMVUUpICogRkxPQVQxNl9FUFNJTE9OX01VTFRJUExJRURfQllfRkxPQVQxNl9NSU5fVkFMVUU7XG4gIH1cblxuICBjb25zdCB0ZW1wID0gKDEgKyBGTE9BVDE2X0VQU0lMT05fREVWSURFRF9CWV9FUFNJTE9OKSAqIGFic29sdXRlO1xuICBjb25zdCByZXN1bHQgPSB0ZW1wIC0gKHRlbXAgLSBhYnNvbHV0ZSk7XG5cbiAgLy8gbGFyZ2UgbnVtYmVyXG4gIGlmIChyZXN1bHQgPiBGTE9BVDE2X01BWF9WQUxVRSB8fCBOdW1iZXJJc05hTihyZXN1bHQpKSB7XG4gICAgcmV0dXJuIHNpZ24gKiBJbmZpbml0eTtcbiAgfVxuXG4gIHJldHVybiBzaWduICogcmVzdWx0O1xufVxuXG4vLyBiYXNlIGFsZ29yaXRobTogaHR0cDovL2ZveC10b29sa2l0Lm9yZy9mdHAvZmFzdGhhbGZmbG9hdGNvbnZlcnNpb24ucGRmXG5cbmNvbnN0IGJ1ZmZlciA9IG5ldyBOYXRpdmVBcnJheUJ1ZmZlcig0KTtcbmNvbnN0IGZsb2F0VmlldyA9IG5ldyBOYXRpdmVGbG9hdDMyQXJyYXkoYnVmZmVyKTtcbmNvbnN0IHVpbnQzMlZpZXcgPSBuZXcgTmF0aXZlVWludDMyQXJyYXkoYnVmZmVyKTtcblxuY29uc3QgYmFzZVRhYmxlID0gbmV3IE5hdGl2ZVVpbnQxNkFycmF5KDUxMik7XG5jb25zdCBzaGlmdFRhYmxlID0gbmV3IE5hdGl2ZVVpbnQ4QXJyYXkoNTEyKTtcblxuZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBjb25zdCBlID0gaSAtIDEyNztcblxuICAvLyB2ZXJ5IHNtYWxsIG51bWJlciAoMCwgLTApXG4gIGlmIChlIDwgLTI0KSB7XG4gICAgYmFzZVRhYmxlW2ldICAgICAgICAgPSAweDAwMDA7XG4gICAgYmFzZVRhYmxlW2kgfCAweDEwMF0gPSAweDgwMDA7XG4gICAgc2hpZnRUYWJsZVtpXSAgICAgICAgID0gMjQ7XG4gICAgc2hpZnRUYWJsZVtpIHwgMHgxMDBdID0gMjQ7XG5cbiAgLy8gc21hbGwgbnVtYmVyIChkZW5vcm0pXG4gIH0gZWxzZSBpZiAoZSA8IC0xNCkge1xuICAgIGJhc2VUYWJsZVtpXSAgICAgICAgID0gIDB4MDQwMCA+PiAoLWUgLSAxNCk7XG4gICAgYmFzZVRhYmxlW2kgfCAweDEwMF0gPSAoMHgwNDAwID4+ICgtZSAtIDE0KSkgfCAweDgwMDA7XG4gICAgc2hpZnRUYWJsZVtpXSAgICAgICAgID0gLWUgLSAxO1xuICAgIHNoaWZ0VGFibGVbaSB8IDB4MTAwXSA9IC1lIC0gMTtcblxuICAvLyBub3JtYWwgbnVtYmVyXG4gIH0gZWxzZSBpZiAoZSA8PSAxNSkge1xuICAgIGJhc2VUYWJsZVtpXSAgICAgICAgID0gIChlICsgMTUpIDw8IDEwO1xuICAgIGJhc2VUYWJsZVtpIHwgMHgxMDBdID0gKChlICsgMTUpIDw8IDEwKSB8IDB4ODAwMDtcbiAgICBzaGlmdFRhYmxlW2ldICAgICAgICAgPSAxMztcbiAgICBzaGlmdFRhYmxlW2kgfCAweDEwMF0gPSAxMztcblxuICAvLyBsYXJnZSBudW1iZXIgKEluZmluaXR5LCAtSW5maW5pdHkpXG4gIH0gZWxzZSBpZiAoZSA8IDEyOCkge1xuICAgIGJhc2VUYWJsZVtpXSAgICAgICAgID0gMHg3YzAwO1xuICAgIGJhc2VUYWJsZVtpIHwgMHgxMDBdID0gMHhmYzAwO1xuICAgIHNoaWZ0VGFibGVbaV0gICAgICAgICA9IDI0O1xuICAgIHNoaWZ0VGFibGVbaSB8IDB4MTAwXSA9IDI0O1xuXG4gIC8vIHN0YXkgKE5hTiwgSW5maW5pdHksIC1JbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBiYXNlVGFibGVbaV0gICAgICAgICA9IDB4N2MwMDtcbiAgICBiYXNlVGFibGVbaSB8IDB4MTAwXSA9IDB4ZmMwMDtcbiAgICBzaGlmdFRhYmxlW2ldICAgICAgICAgPSAxMztcbiAgICBzaGlmdFRhYmxlW2kgfCAweDEwMF0gPSAxMztcbiAgfVxufVxuXG4vKipcbiAqIHJvdW5kIGEgbnVtYmVyIHRvIGEgaGFsZiBmbG9hdCBudW1iZXIgYml0c1xuICogQHBhcmFtIHt1bmtub3dufSBudW0gLSBkb3VibGUgZmxvYXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGhhbGYgZmxvYXQgbnVtYmVyIGJpdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kVG9GbG9hdDE2Qml0cyhudW0pIHtcbiAgZmxvYXRWaWV3WzBdID0gcm91bmRUb0Zsb2F0MTYobnVtKTtcbiAgY29uc3QgZiA9IHVpbnQzMlZpZXdbMF07XG4gIGNvbnN0IGUgPSAoZiA+PiAyMykgJiAweDFmZjtcbiAgcmV0dXJuIGJhc2VUYWJsZVtlXSArICgoZiAmIDB4MDA3ZmZmZmYpID4+IHNoaWZ0VGFibGVbZV0pO1xufVxuXG5jb25zdCBtYW50aXNzYVRhYmxlID0gbmV3IE5hdGl2ZVVpbnQzMkFycmF5KDIwNDgpO1xuZm9yIChsZXQgaSA9IDE7IGkgPCAxMDI0OyArK2kpIHtcbiAgbGV0IG0gPSBpIDw8IDEzOyAvLyB6ZXJvIHBhZCBtYW50aXNzYSBiaXRzXG4gIGxldCBlID0gMDsgLy8gemVybyBleHBvbmVudFxuXG4gIC8vIG5vcm1hbGl6ZWRcbiAgd2hpbGUgKChtICYgMHgwMDgwMDAwMCkgPT09IDApIHtcbiAgICBtIDw8PSAxO1xuICAgIGUgLT0gMHgwMDgwMDAwMDsgLy8gZGVjcmVtZW50IGV4cG9uZW50XG4gIH1cblxuICBtICY9IH4weDAwODAwMDAwOyAvLyBjbGVhciBsZWFkaW5nIDEgYml0XG4gIGUgKz0gMHgzODgwMDAwMDsgLy8gYWRqdXN0IGJpYXNcblxuICBtYW50aXNzYVRhYmxlW2ldID0gbSB8IGU7XG59XG5mb3IgKGxldCBpID0gMTAyNDsgaSA8IDIwNDg7ICsraSkge1xuICBtYW50aXNzYVRhYmxlW2ldID0gMHgzODAwMDAwMCArICgoaSAtIDEwMjQpIDw8IDEzKTtcbn1cblxuY29uc3QgZXhwb25lbnRUYWJsZSA9IG5ldyBOYXRpdmVVaW50MzJBcnJheSg2NCk7XG5mb3IgKGxldCBpID0gMTsgaSA8IDMxOyArK2kpIHtcbiAgZXhwb25lbnRUYWJsZVtpXSA9IGkgPDwgMjM7XG59XG5leHBvbmVudFRhYmxlWzMxXSA9IDB4NDc4MDAwMDA7XG5leHBvbmVudFRhYmxlWzMyXSA9IDB4ODAwMDAwMDA7XG5mb3IgKGxldCBpID0gMzM7IGkgPCA2MzsgKytpKSB7XG4gIGV4cG9uZW50VGFibGVbaV0gPSAweDgwMDAwMDAwICsgKChpIC0gMzIpIDw8IDIzKTtcbn1cbmV4cG9uZW50VGFibGVbNjNdID0gMHhjNzgwMDAwMDtcblxuY29uc3Qgb2Zmc2V0VGFibGUgPSBuZXcgTmF0aXZlVWludDE2QXJyYXkoNjQpO1xuZm9yIChsZXQgaSA9IDE7IGkgPCA2NDsgKytpKSB7XG4gIGlmIChpICE9PSAzMikge1xuICAgIG9mZnNldFRhYmxlW2ldID0gMTAyNDtcbiAgfVxufVxuXG4vKipcbiAqIGNvbnZlcnQgYSBoYWxmIGZsb2F0IG51bWJlciBiaXRzIHRvIGEgbnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gZmxvYXQxNmJpdHMgLSBoYWxmIGZsb2F0IG51bWJlciBiaXRzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBkb3VibGUgZmxvYXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUb051bWJlcihmbG9hdDE2Yml0cykge1xuICBjb25zdCBpID0gZmxvYXQxNmJpdHMgPj4gMTA7XG4gIHVpbnQzMlZpZXdbMF0gPSBtYW50aXNzYVRhYmxlW29mZnNldFRhYmxlW2ldICsgKGZsb2F0MTZiaXRzICYgMHgzZmYpXSArIGV4cG9uZW50VGFibGVbaV07XG4gIHJldHVybiBmbG9hdFZpZXdbMF07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@petamoriken/float16/src/_util/converter.mjs\n");

/***/ }),

/***/ "./node_modules/@petamoriken/float16/src/_util/messages.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@petamoriken/float16/src/_util/messages.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER: () => (/* binding */ ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER),\n/* harmony export */   CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT: () => (/* binding */ CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT),\n/* harmony export */   CANNOT_MIX_BIGINT_AND_OTHER_TYPES: () => (/* binding */ CANNOT_MIX_BIGINT_AND_OTHER_TYPES),\n/* harmony export */   DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH: () => (/* binding */ DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH),\n/* harmony export */   ITERATOR_PROPERTY_IS_NOT_CALLABLE: () => (/* binding */ ITERATOR_PROPERTY_IS_NOT_CALLABLE),\n/* harmony export */   OFFSET_IS_OUT_OF_BOUNDS: () => (/* binding */ OFFSET_IS_OUT_OF_BOUNDS),\n/* harmony export */   REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE: () => (/* binding */ REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE),\n/* harmony export */   SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT: () => (/* binding */ SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT),\n/* harmony export */   THE_COMPARISON_FUNCTION_MUST_BE_EITHER_A_FUNCTION_OR_UNDEFINED: () => (/* binding */ THE_COMPARISON_FUNCTION_MUST_BE_EITHER_A_FUNCTION_OR_UNDEFINED),\n/* harmony export */   THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT: () => (/* binding */ THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT),\n/* harmony export */   THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY: () => (/* binding */ THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY),\n/* harmony export */   THIS_IS_NOT_AN_OBJECT: () => (/* binding */ THIS_IS_NOT_AN_OBJECT),\n/* harmony export */   THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT: () => (/* binding */ THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT)\n/* harmony export */ });\nconst THIS_IS_NOT_AN_OBJECT = \"This is not an object\";\nconst THIS_IS_NOT_A_FLOAT16ARRAY_OBJECT = \"This is not a Float16Array object\";\nconst THIS_CONSTRUCTOR_IS_NOT_A_SUBCLASS_OF_FLOAT16ARRAY =\n  \"This constructor is not a subclass of Float16Array\";\nconst THE_CONSTRUCTOR_PROPERTY_VALUE_IS_NOT_AN_OBJECT =\n  \"The constructor property value is not an object\";\nconst SPECIES_CONSTRUCTOR_DIDNT_RETURN_TYPEDARRAY_OBJECT =\n  \"Species constructor didn't return TypedArray object\";\nconst DERIVED_CONSTRUCTOR_CREATED_TYPEDARRAY_OBJECT_WHICH_WAS_TOO_SMALL_LENGTH =\n  \"Derived constructor created TypedArray object which was too small length\";\nconst ATTEMPTING_TO_ACCESS_DETACHED_ARRAYBUFFER =\n  \"Attempting to access detached ArrayBuffer\";\nconst CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT =\n  \"Cannot convert undefined or null to object\";\nconst CANNOT_MIX_BIGINT_AND_OTHER_TYPES =\n  \"Cannot mix BigInt and other types, use explicit conversions\";\nconst ITERATOR_PROPERTY_IS_NOT_CALLABLE = \"@@iterator property is not callable\";\nconst REDUCE_OF_EMPTY_ARRAY_WITH_NO_INITIAL_VALUE =\n  \"Reduce of empty array with no initial value\";\nconst THE_COMPARISON_FUNCTION_MUST_BE_EITHER_A_FUNCTION_OR_UNDEFINED =\n  \"The comparison function must be either a function or undefined\";\nconst OFFSET_IS_OUT_OF_BOUNDS = \"Offset is out of bounds\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBldGFtb3Jpa2VuL2Zsb2F0MTYvc3JjL191dGlsL21lc3NhZ2VzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZXJyaWFqcy1tYXAvLi9ub2RlX21vZHVsZXMvQHBldGFtb3Jpa2VuL2Zsb2F0MTYvc3JjL191dGlsL21lc3NhZ2VzLm1qcz84OTI3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBUSElTX0lTX05PVF9BTl9PQkpFQ1QgPSBcIlRoaXMgaXMgbm90IGFuIG9iamVjdFwiO1xuZXhwb3J0IGNvbnN0IFRISVNfSVNfTk9UX0FfRkxPQVQxNkFSUkFZX09CSkVDVCA9IFwiVGhpcyBpcyBub3QgYSBGbG9hdDE2QXJyYXkgb2JqZWN0XCI7XG5leHBvcnQgY29uc3QgVEhJU19DT05TVFJVQ1RPUl9JU19OT1RfQV9TVUJDTEFTU19PRl9GTE9BVDE2QVJSQVkgPVxuICBcIlRoaXMgY29uc3RydWN0b3IgaXMgbm90IGEgc3ViY2xhc3Mgb2YgRmxvYXQxNkFycmF5XCI7XG5leHBvcnQgY29uc3QgVEhFX0NPTlNUUlVDVE9SX1BST1BFUlRZX1ZBTFVFX0lTX05PVF9BTl9PQkpFQ1QgPVxuICBcIlRoZSBjb25zdHJ1Y3RvciBwcm9wZXJ0eSB2YWx1ZSBpcyBub3QgYW4gb2JqZWN0XCI7XG5leHBvcnQgY29uc3QgU1BFQ0lFU19DT05TVFJVQ1RPUl9ESUROVF9SRVRVUk5fVFlQRURBUlJBWV9PQkpFQ1QgPVxuICBcIlNwZWNpZXMgY29uc3RydWN0b3IgZGlkbid0IHJldHVybiBUeXBlZEFycmF5IG9iamVjdFwiO1xuZXhwb3J0IGNvbnN0IERFUklWRURfQ09OU1RSVUNUT1JfQ1JFQVRFRF9UWVBFREFSUkFZX09CSkVDVF9XSElDSF9XQVNfVE9PX1NNQUxMX0xFTkdUSCA9XG4gIFwiRGVyaXZlZCBjb25zdHJ1Y3RvciBjcmVhdGVkIFR5cGVkQXJyYXkgb2JqZWN0IHdoaWNoIHdhcyB0b28gc21hbGwgbGVuZ3RoXCI7XG5leHBvcnQgY29uc3QgQVRURU1QVElOR19UT19BQ0NFU1NfREVUQUNIRURfQVJSQVlCVUZGRVIgPVxuICBcIkF0dGVtcHRpbmcgdG8gYWNjZXNzIGRldGFjaGVkIEFycmF5QnVmZmVyXCI7XG5leHBvcnQgY29uc3QgQ0FOTk9UX0NPTlZFUlRfVU5ERUZJTkVEX09SX05VTExfVE9fT0JKRUNUID1cbiAgXCJDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3RcIjtcbmV4cG9ydCBjb25zdCBDQU5OT1RfTUlYX0JJR0lOVF9BTkRfT1RIRVJfVFlQRVMgPVxuICBcIkNhbm5vdCBtaXggQmlnSW50IGFuZCBvdGhlciB0eXBlcywgdXNlIGV4cGxpY2l0IGNvbnZlcnNpb25zXCI7XG5leHBvcnQgY29uc3QgSVRFUkFUT1JfUFJPUEVSVFlfSVNfTk9UX0NBTExBQkxFID0gXCJAQGl0ZXJhdG9yIHByb3BlcnR5IGlzIG5vdCBjYWxsYWJsZVwiO1xuZXhwb3J0IGNvbnN0IFJFRFVDRV9PRl9FTVBUWV9BUlJBWV9XSVRIX05PX0lOSVRJQUxfVkFMVUUgPVxuICBcIlJlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWVcIjtcbmV4cG9ydCBjb25zdCBUSEVfQ09NUEFSSVNPTl9GVU5DVElPTl9NVVNUX0JFX0VJVEhFUl9BX0ZVTkNUSU9OX09SX1VOREVGSU5FRCA9XG4gIFwiVGhlIGNvbXBhcmlzb24gZnVuY3Rpb24gbXVzdCBiZSBlaXRoZXIgYSBmdW5jdGlvbiBvciB1bmRlZmluZWRcIjtcbmV4cG9ydCBjb25zdCBPRkZTRVRfSVNfT1VUX09GX0JPVU5EUyA9IFwiT2Zmc2V0IGlzIG91dCBvZiBib3VuZHNcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@petamoriken/float16/src/_util/messages.mjs\n");

/***/ }),

/***/ "./node_modules/@petamoriken/float16/src/_util/primordials.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@petamoriken/float16/src/_util/primordials.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArrayBufferIsView: () => (/* binding */ ArrayBufferIsView),\n/* harmony export */   ArrayBufferPrototypeGetByteLength: () => (/* binding */ ArrayBufferPrototypeGetByteLength),\n/* harmony export */   ArrayBufferPrototypeSlice: () => (/* binding */ ArrayBufferPrototypeSlice),\n/* harmony export */   ArrayIsArray: () => (/* binding */ ArrayIsArray),\n/* harmony export */   ArrayIteratorPrototype: () => (/* binding */ ArrayIteratorPrototype),\n/* harmony export */   ArrayIteratorPrototypeNext: () => (/* binding */ ArrayIteratorPrototypeNext),\n/* harmony export */   ArrayPrototypeJoin: () => (/* binding */ ArrayPrototypeJoin),\n/* harmony export */   ArrayPrototypePush: () => (/* binding */ ArrayPrototypePush),\n/* harmony export */   ArrayPrototypeSymbolIterator: () => (/* binding */ ArrayPrototypeSymbolIterator),\n/* harmony export */   ArrayPrototypeToLocaleString: () => (/* binding */ ArrayPrototypeToLocaleString),\n/* harmony export */   DataViewPrototypeGetUint16: () => (/* binding */ DataViewPrototypeGetUint16),\n/* harmony export */   DataViewPrototypeSetUint16: () => (/* binding */ DataViewPrototypeSetUint16),\n/* harmony export */   EPSILON: () => (/* binding */ EPSILON),\n/* harmony export */   GeneratorPrototypeNext: () => (/* binding */ GeneratorPrototypeNext),\n/* harmony export */   IteratorPrototype: () => (/* binding */ IteratorPrototype),\n/* harmony export */   MAX_SAFE_INTEGER: () => (/* binding */ MAX_SAFE_INTEGER),\n/* harmony export */   MathAbs: () => (/* binding */ MathAbs),\n/* harmony export */   MathTrunc: () => (/* binding */ MathTrunc),\n/* harmony export */   NativeArrayBuffer: () => (/* binding */ NativeArrayBuffer),\n/* harmony export */   NativeArrayPrototypeSymbolIterator: () => (/* binding */ NativeArrayPrototypeSymbolIterator),\n/* harmony export */   NativeFloat32Array: () => (/* binding */ NativeFloat32Array),\n/* harmony export */   NativeObject: () => (/* binding */ NativeObject),\n/* harmony export */   NativeProxy: () => (/* binding */ NativeProxy),\n/* harmony export */   NativeRangeError: () => (/* binding */ NativeRangeError),\n/* harmony export */   NativeSharedArrayBuffer: () => (/* binding */ NativeSharedArrayBuffer),\n/* harmony export */   NativeTypeError: () => (/* binding */ NativeTypeError),\n/* harmony export */   NativeTypedArrayPrototypeSymbolIterator: () => (/* binding */ NativeTypedArrayPrototypeSymbolIterator),\n/* harmony export */   NativeUint16Array: () => (/* binding */ NativeUint16Array),\n/* harmony export */   NativeUint32Array: () => (/* binding */ NativeUint32Array),\n/* harmony export */   NativeUint8Array: () => (/* binding */ NativeUint8Array),\n/* harmony export */   NativeWeakMap: () => (/* binding */ NativeWeakMap),\n/* harmony export */   NativeWeakSet: () => (/* binding */ NativeWeakSet),\n/* harmony export */   NumberIsFinite: () => (/* binding */ NumberIsFinite),\n/* harmony export */   NumberIsNaN: () => (/* binding */ NumberIsNaN),\n/* harmony export */   ObjectCreate: () => (/* binding */ ObjectCreate),\n/* harmony export */   ObjectDefineProperty: () => (/* binding */ ObjectDefineProperty),\n/* harmony export */   ObjectFreeze: () => (/* binding */ ObjectFreeze),\n/* harmony export */   ObjectHasOwn: () => (/* binding */ ObjectHasOwn),\n/* harmony export */   ObjectIs: () => (/* binding */ ObjectIs),\n/* harmony export */   ObjectPrototype__lookupGetter__: () => (/* binding */ ObjectPrototype__lookupGetter__),\n/* harmony export */   ReflectApply: () => (/* binding */ ReflectApply),\n/* harmony export */   ReflectConstruct: () => (/* binding */ ReflectConstruct),\n/* harmony export */   ReflectDefineProperty: () => (/* binding */ ReflectDefineProperty),\n/* harmony export */   ReflectGet: () => (/* binding */ ReflectGet),\n/* harmony export */   ReflectGetOwnPropertyDescriptor: () => (/* binding */ ReflectGetOwnPropertyDescriptor),\n/* harmony export */   ReflectGetPrototypeOf: () => (/* binding */ ReflectGetPrototypeOf),\n/* harmony export */   ReflectHas: () => (/* binding */ ReflectHas),\n/* harmony export */   ReflectOwnKeys: () => (/* binding */ ReflectOwnKeys),\n/* harmony export */   ReflectSet: () => (/* binding */ ReflectSet),\n/* harmony export */   ReflectSetPrototypeOf: () => (/* binding */ ReflectSetPrototypeOf),\n/* harmony export */   SharedArrayBufferPrototypeGetByteLength: () => (/* binding */ SharedArrayBufferPrototypeGetByteLength),\n/* harmony export */   SymbolFor: () => (/* binding */ SymbolFor),\n/* harmony export */   SymbolIterator: () => (/* binding */ SymbolIterator),\n/* harmony export */   SymbolSpecies: () => (/* binding */ SymbolSpecies),\n/* harmony export */   SymbolToStringTag: () => (/* binding */ SymbolToStringTag),\n/* harmony export */   TypedArray: () => (/* binding */ TypedArray),\n/* harmony export */   TypedArrayPrototype: () => (/* binding */ TypedArrayPrototype),\n/* harmony export */   TypedArrayPrototypeCopyWithin: () => (/* binding */ TypedArrayPrototypeCopyWithin),\n/* harmony export */   TypedArrayPrototypeEntries: () => (/* binding */ TypedArrayPrototypeEntries),\n/* harmony export */   TypedArrayPrototypeFill: () => (/* binding */ TypedArrayPrototypeFill),\n/* harmony export */   TypedArrayPrototypeGetBuffer: () => (/* binding */ TypedArrayPrototypeGetBuffer),\n/* harmony export */   TypedArrayPrototypeGetByteOffset: () => (/* binding */ TypedArrayPrototypeGetByteOffset),\n/* harmony export */   TypedArrayPrototypeGetLength: () => (/* binding */ TypedArrayPrototypeGetLength),\n/* harmony export */   TypedArrayPrototypeGetSymbolToStringTag: () => (/* binding */ TypedArrayPrototypeGetSymbolToStringTag),\n/* harmony export */   TypedArrayPrototypeKeys: () => (/* binding */ TypedArrayPrototypeKeys),\n/* harmony export */   TypedArrayPrototypeReverse: () => (/* binding */ TypedArrayPrototypeReverse),\n/* harmony export */   TypedArrayPrototypeSet: () => (/* binding */ TypedArrayPrototypeSet),\n/* harmony export */   TypedArrayPrototypeSlice: () => (/* binding */ TypedArrayPrototypeSlice),\n/* harmony export */   TypedArrayPrototypeSort: () => (/* binding */ TypedArrayPrototypeSort),\n/* harmony export */   TypedArrayPrototypeSubarray: () => (/* binding */ TypedArrayPrototypeSubarray),\n/* harmony export */   TypedArrayPrototypeValues: () => (/* binding */ TypedArrayPrototypeValues),\n/* harmony export */   Uint16ArrayFrom: () => (/* binding */ Uint16ArrayFrom),\n/* harmony export */   WeakMapPrototypeGet: () => (/* binding */ WeakMapPrototypeGet),\n/* harmony export */   WeakMapPrototypeHas: () => (/* binding */ WeakMapPrototypeHas),\n/* harmony export */   WeakMapPrototypeSet: () => (/* binding */ WeakMapPrototypeSet),\n/* harmony export */   WeakSetPrototypeAdd: () => (/* binding */ WeakSetPrototypeAdd),\n/* harmony export */   WeakSetPrototypeHas: () => (/* binding */ WeakSetPrototypeHas)\n/* harmony export */ });\n/* harmony import */ var _messages_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./messages.mjs */ \"./node_modules/@petamoriken/float16/src/_util/messages.mjs\");\n/* eslint-disable no-restricted-globals, no-restricted-syntax */\n/* global SharedArrayBuffer */\n\n\n\n/** @type {<T extends (...args: any) => any>(target: T) => (thisArg: ThisType<T>, ...args: any[]) => any} */\nfunction uncurryThis(target) {\n  return (thisArg, ...args) => {\n    return ReflectApply(target, thisArg, args);\n  };\n}\n\n/** @type {(target: any, key: string | symbol) => (thisArg: any, ...args: any[]) => any} */\nfunction uncurryThisGetter(target, key) {\n  return uncurryThis(\n    ReflectGetOwnPropertyDescriptor(\n      target,\n      key\n    ).get\n  );\n}\n\n// Reflect\nconst {\n  apply: ReflectApply,\n  construct: ReflectConstruct,\n  defineProperty: ReflectDefineProperty,\n  get: ReflectGet,\n  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor,\n  getPrototypeOf: ReflectGetPrototypeOf,\n  has: ReflectHas,\n  ownKeys: ReflectOwnKeys,\n  set: ReflectSet,\n  setPrototypeOf: ReflectSetPrototypeOf,\n} = Reflect;\n\n// Proxy\nconst NativeProxy = Proxy;\n\n// Number\nconst {\n  EPSILON,\n  MAX_SAFE_INTEGER,\n  isFinite: NumberIsFinite,\n  isNaN: NumberIsNaN,\n} = Number;\n\n// Symbol\nconst {\n  iterator: SymbolIterator,\n  species: SymbolSpecies,\n  toStringTag: SymbolToStringTag,\n  for: SymbolFor,\n} = Symbol;\n\n// Object\nconst NativeObject = Object;\nconst {\n  create: ObjectCreate,\n  defineProperty: ObjectDefineProperty,\n  freeze: ObjectFreeze,\n  is: ObjectIs,\n} = NativeObject;\nconst ObjectPrototype = NativeObject.prototype;\n/** @type {(object: object, key: PropertyKey) => Function | undefined} */\nconst ObjectPrototype__lookupGetter__ = /** @type {any} */ (ObjectPrototype).__lookupGetter__\n  ? uncurryThis(/** @type {any} */ (ObjectPrototype).__lookupGetter__)\n  : (object, key) => {\n    if (object == null) {\n      throw NativeTypeError(\n        _messages_mjs__WEBPACK_IMPORTED_MODULE_0__.CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT\n      );\n    }\n\n    let target = NativeObject(object);\n    do {\n      const descriptor = ReflectGetOwnPropertyDescriptor(target, key);\n      if (descriptor !== undefined) {\n        if (ObjectHasOwn(descriptor, \"get\")) {\n          return descriptor.get;\n        }\n\n        return;\n      }\n    } while ((target = ReflectGetPrototypeOf(target)) !== null);\n  };\n/** @type {(object: object, key: PropertyKey) => boolean} */\nconst ObjectHasOwn = /** @type {any} */ (NativeObject).hasOwn ||\n  uncurryThis(ObjectPrototype.hasOwnProperty);\n\n// Array\nconst NativeArray = Array;\nconst ArrayIsArray = NativeArray.isArray;\nconst ArrayPrototype = NativeArray.prototype;\n/** @type {(array: ArrayLike<unknown>, separator?: string) => string} */\nconst ArrayPrototypeJoin = uncurryThis(ArrayPrototype.join);\n/** @type {<T>(array: T[], ...items: T[]) => number} */\nconst ArrayPrototypePush = uncurryThis(ArrayPrototype.push);\n/** @type {(array: ArrayLike<unknown>, ...opts: any[]) => string} */\nconst ArrayPrototypeToLocaleString = uncurryThis(\n  ArrayPrototype.toLocaleString\n);\nconst NativeArrayPrototypeSymbolIterator = ArrayPrototype[SymbolIterator];\n/** @type {<T>(array: T[]) => IterableIterator<T>} */\nconst ArrayPrototypeSymbolIterator = uncurryThis(NativeArrayPrototypeSymbolIterator);\n\n// Math\nconst {\n  abs: MathAbs,\n  trunc: MathTrunc,\n} = Math;\n\n// ArrayBuffer\nconst NativeArrayBuffer = ArrayBuffer;\nconst ArrayBufferIsView = NativeArrayBuffer.isView;\nconst ArrayBufferPrototype = NativeArrayBuffer.prototype;\n/** @type {(buffer: ArrayBuffer, begin?: number, end?: number) => number} */\nconst ArrayBufferPrototypeSlice = uncurryThis(ArrayBufferPrototype.slice);\n/** @type {(buffer: ArrayBuffer) => ArrayBuffer} */\nconst ArrayBufferPrototypeGetByteLength = uncurryThisGetter(ArrayBufferPrototype, \"byteLength\");\n\n// SharedArrayBuffer\nconst NativeSharedArrayBuffer = typeof SharedArrayBuffer !== \"undefined\" ? SharedArrayBuffer : null;\n/** @type {(buffer: SharedArrayBuffer) => SharedArrayBuffer} */\nconst SharedArrayBufferPrototypeGetByteLength = NativeSharedArrayBuffer\n  && uncurryThisGetter(NativeSharedArrayBuffer.prototype, \"byteLength\");\n\n// TypedArray\n/** @typedef {Uint8Array|Uint8ClampedArray|Uint16Array|Uint32Array|Int8Array|Int16Array|Int32Array|Float32Array|Float64Array|BigUint64Array|BigInt64Array} TypedArray */\n/** @type {any} */\nconst TypedArray = ReflectGetPrototypeOf(Uint8Array);\nconst TypedArrayFrom = TypedArray.from;\nconst TypedArrayPrototype = TypedArray.prototype;\nconst NativeTypedArrayPrototypeSymbolIterator = TypedArrayPrototype[SymbolIterator];\n/** @type {(typedArray: TypedArray) => IterableIterator<number>} */\nconst TypedArrayPrototypeKeys = uncurryThis(TypedArrayPrototype.keys);\n/** @type {(typedArray: TypedArray) => IterableIterator<number>} */\nconst TypedArrayPrototypeValues = uncurryThis(\n  TypedArrayPrototype.values\n);\n/** @type {(typedArray: TypedArray) => IterableIterator<[number, number]>} */\nconst TypedArrayPrototypeEntries = uncurryThis(\n  TypedArrayPrototype.entries\n);\n/** @type {(typedArray: TypedArray, array: ArrayLike<number>, offset?: number) => void} */\nconst TypedArrayPrototypeSet = uncurryThis(TypedArrayPrototype.set);\n/** @type {<T extends TypedArray>(typedArray: T) => T} */\nconst TypedArrayPrototypeReverse = uncurryThis(\n  TypedArrayPrototype.reverse\n);\n/** @type {<T extends TypedArray>(typedArray: T, value: number, start?: number, end?: number) => T} */\nconst TypedArrayPrototypeFill = uncurryThis(TypedArrayPrototype.fill);\n/** @type {<T extends TypedArray>(typedArray: T, target: number, start: number, end?: number) => T} */\nconst TypedArrayPrototypeCopyWithin = uncurryThis(\n  TypedArrayPrototype.copyWithin\n);\n/** @type {<T extends TypedArray>(typedArray: T, compareFn?: (a: number, b: number) => number) => T} */\nconst TypedArrayPrototypeSort = uncurryThis(TypedArrayPrototype.sort);\n/** @type {<T extends TypedArray>(typedArray: T, start?: number, end?: number) => T} */\nconst TypedArrayPrototypeSlice = uncurryThis(TypedArrayPrototype.slice);\n/** @type {<T extends TypedArray>(typedArray: T, start?: number, end?: number) => T} */\nconst TypedArrayPrototypeSubarray = uncurryThis(\n  TypedArrayPrototype.subarray\n);\n/** @type {((typedArray: TypedArray) => ArrayBuffer)} */\nconst TypedArrayPrototypeGetBuffer = uncurryThisGetter(\n  TypedArrayPrototype,\n  \"buffer\"\n);\n/** @type {((typedArray: TypedArray) => number)} */\nconst TypedArrayPrototypeGetByteOffset = uncurryThisGetter(\n  TypedArrayPrototype,\n  \"byteOffset\"\n);\n/** @type {((typedArray: TypedArray) => number)} */\nconst TypedArrayPrototypeGetLength = uncurryThisGetter(\n  TypedArrayPrototype,\n  \"length\"\n);\n/** @type {(target: unknown) => string} */\nconst TypedArrayPrototypeGetSymbolToStringTag = uncurryThisGetter(\n  TypedArrayPrototype,\n  SymbolToStringTag\n);\n\n// Uint8Array\nconst NativeUint8Array = Uint8Array;\n\n// Uint16Array\nconst NativeUint16Array = Uint16Array;\n/** @type {Uint16ArrayConstructor[\"from\"]} */\nconst Uint16ArrayFrom = (...args) => {\n  return ReflectApply(TypedArrayFrom, NativeUint16Array, args);\n};\n\n// Uint32Array\nconst NativeUint32Array = Uint32Array;\n\n// Float32Array\nconst NativeFloat32Array = Float32Array;\n\n// ArrayIterator\n/** @type {any} */\nconst ArrayIteratorPrototype = ReflectGetPrototypeOf([][SymbolIterator]());\n/** @type {<T>(arrayIterator: IterableIterator<T>) => IteratorResult<T>} */\nconst ArrayIteratorPrototypeNext = uncurryThis(ArrayIteratorPrototype.next);\n\n// Generator\n/** @type {<T = unknown, TReturn = any, TNext = unknown>(generator: Generator<T, TReturn, TNext>, value?: TNext) => T} */\nconst GeneratorPrototypeNext = uncurryThis((function* () {})().next);\n\n// Iterator\nconst IteratorPrototype = ReflectGetPrototypeOf(ArrayIteratorPrototype);\n\n// DataView\nconst DataViewPrototype = DataView.prototype;\n/** @type {(dataView: DataView, byteOffset: number, littleEndian?: boolean) => number} */\nconst DataViewPrototypeGetUint16 = uncurryThis(\n  DataViewPrototype.getUint16\n);\n/** @type {(dataView: DataView, byteOffset: number, value: number, littleEndian?: boolean) => void} */\nconst DataViewPrototypeSetUint16 = uncurryThis(\n  DataViewPrototype.setUint16\n);\n\n// Error\nconst NativeTypeError = TypeError;\nconst NativeRangeError = RangeError;\n\n// WeakSet\n/**\n * Do not construct with arguments to avoid calling the \"add\" method\n * @type {{new <T extends {}>(): WeakSet<T>}}\n */\nconst NativeWeakSet = WeakSet;\nconst WeakSetPrototype = NativeWeakSet.prototype;\n/** @type {<T extends {}>(set: WeakSet<T>, value: T) => Set<T>} */\nconst WeakSetPrototypeAdd = uncurryThis(WeakSetPrototype.add);\n/** @type {<T extends {}>(set: WeakSet<T>, value: T) => boolean} */\nconst WeakSetPrototypeHas = uncurryThis(WeakSetPrototype.has);\n\n// WeakMap\n/**\n * Do not construct with arguments to avoid calling the \"set\" method\n * @type {{new <K extends {}, V>(): WeakMap<K, V>}}\n */\nconst NativeWeakMap = WeakMap;\nconst WeakMapPrototype = NativeWeakMap.prototype;\n/** @type {<K extends {}, V>(weakMap: WeakMap<K, V>, key: K) => V} */\nconst WeakMapPrototypeGet = uncurryThis(WeakMapPrototype.get);\n/** @type {<K extends {}, V>(weakMap: WeakMap<K, V>, key: K) => boolean} */\nconst WeakMapPrototypeHas = uncurryThis(WeakMapPrototype.has);\n/** @type {<K extends {}, V>(weakMap: WeakMap<K, V>, key: K, value: V) => WeakMap} */\nconst WeakMapPrototypeSet = uncurryThis(WeakMapPrototype.set);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHBldGFtb3Jpa2VuL2Zsb2F0MTYvc3JjL191dGlsL3ByaW1vcmRpYWxzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVycmlhanMtbWFwLy4vbm9kZV9tb2R1bGVzL0BwZXRhbW9yaWtlbi9mbG9hdDE2L3NyYy9fdXRpbC9wcmltb3JkaWFscy5tanM/ZGY3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLWdsb2JhbHMsIG5vLXJlc3RyaWN0ZWQtc3ludGF4ICovXG4vKiBnbG9iYWwgU2hhcmVkQXJyYXlCdWZmZXIgKi9cblxuaW1wb3J0IHsgQ0FOTk9UX0NPTlZFUlRfVU5ERUZJTkVEX09SX05VTExfVE9fT0JKRUNUIH0gZnJvbSBcIi4vbWVzc2FnZXMubWpzXCI7XG5cbi8qKiBAdHlwZSB7PFQgZXh0ZW5kcyAoLi4uYXJnczogYW55KSA9PiBhbnk+KHRhcmdldDogVCkgPT4gKHRoaXNBcmc6IFRoaXNUeXBlPFQ+LCAuLi5hcmdzOiBhbnlbXSkgPT4gYW55fSAqL1xuZnVuY3Rpb24gdW5jdXJyeVRoaXModGFyZ2V0KSB7XG4gIHJldHVybiAodGhpc0FyZywgLi4uYXJncykgPT4ge1xuICAgIHJldHVybiBSZWZsZWN0QXBwbHkodGFyZ2V0LCB0aGlzQXJnLCBhcmdzKTtcbiAgfTtcbn1cblxuLyoqIEB0eXBlIHsodGFyZ2V0OiBhbnksIGtleTogc3RyaW5nIHwgc3ltYm9sKSA9PiAodGhpc0FyZzogYW55LCAuLi5hcmdzOiBhbnlbXSkgPT4gYW55fSAqL1xuZnVuY3Rpb24gdW5jdXJyeVRoaXNHZXR0ZXIodGFyZ2V0LCBrZXkpIHtcbiAgcmV0dXJuIHVuY3VycnlUaGlzKFxuICAgIFJlZmxlY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgICB0YXJnZXQsXG4gICAgICBrZXlcbiAgICApLmdldFxuICApO1xufVxuXG4vLyBSZWZsZWN0XG5leHBvcnQgY29uc3Qge1xuICBhcHBseTogUmVmbGVjdEFwcGx5LFxuICBjb25zdHJ1Y3Q6IFJlZmxlY3RDb25zdHJ1Y3QsXG4gIGRlZmluZVByb3BlcnR5OiBSZWZsZWN0RGVmaW5lUHJvcGVydHksXG4gIGdldDogUmVmbGVjdEdldCxcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBSZWZsZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICBnZXRQcm90b3R5cGVPZjogUmVmbGVjdEdldFByb3RvdHlwZU9mLFxuICBoYXM6IFJlZmxlY3RIYXMsXG4gIG93bktleXM6IFJlZmxlY3RPd25LZXlzLFxuICBzZXQ6IFJlZmxlY3RTZXQsXG4gIHNldFByb3RvdHlwZU9mOiBSZWZsZWN0U2V0UHJvdG90eXBlT2YsXG59ID0gUmVmbGVjdDtcblxuLy8gUHJveHlcbmV4cG9ydCBjb25zdCBOYXRpdmVQcm94eSA9IFByb3h5O1xuXG4vLyBOdW1iZXJcbmV4cG9ydCBjb25zdCB7XG4gIEVQU0lMT04sXG4gIE1BWF9TQUZFX0lOVEVHRVIsXG4gIGlzRmluaXRlOiBOdW1iZXJJc0Zpbml0ZSxcbiAgaXNOYU46IE51bWJlcklzTmFOLFxufSA9IE51bWJlcjtcblxuLy8gU3ltYm9sXG5leHBvcnQgY29uc3Qge1xuICBpdGVyYXRvcjogU3ltYm9sSXRlcmF0b3IsXG4gIHNwZWNpZXM6IFN5bWJvbFNwZWNpZXMsXG4gIHRvU3RyaW5nVGFnOiBTeW1ib2xUb1N0cmluZ1RhZyxcbiAgZm9yOiBTeW1ib2xGb3IsXG59ID0gU3ltYm9sO1xuXG4vLyBPYmplY3RcbmV4cG9ydCBjb25zdCBOYXRpdmVPYmplY3QgPSBPYmplY3Q7XG5leHBvcnQgY29uc3Qge1xuICBjcmVhdGU6IE9iamVjdENyZWF0ZSxcbiAgZGVmaW5lUHJvcGVydHk6IE9iamVjdERlZmluZVByb3BlcnR5LFxuICBmcmVlemU6IE9iamVjdEZyZWV6ZSxcbiAgaXM6IE9iamVjdElzLFxufSA9IE5hdGl2ZU9iamVjdDtcbmNvbnN0IE9iamVjdFByb3RvdHlwZSA9IE5hdGl2ZU9iamVjdC5wcm90b3R5cGU7XG4vKiogQHR5cGUgeyhvYmplY3Q6IG9iamVjdCwga2V5OiBQcm9wZXJ0eUtleSkgPT4gRnVuY3Rpb24gfCB1bmRlZmluZWR9ICovXG5leHBvcnQgY29uc3QgT2JqZWN0UHJvdG90eXBlX19sb29rdXBHZXR0ZXJfXyA9IC8qKiBAdHlwZSB7YW55fSAqLyAoT2JqZWN0UHJvdG90eXBlKS5fX2xvb2t1cEdldHRlcl9fXG4gID8gdW5jdXJyeVRoaXMoLyoqIEB0eXBlIHthbnl9ICovIChPYmplY3RQcm90b3R5cGUpLl9fbG9va3VwR2V0dGVyX18pXG4gIDogKG9iamVjdCwga2V5KSA9PiB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBOYXRpdmVUeXBlRXJyb3IoXG4gICAgICAgIENBTk5PVF9DT05WRVJUX1VOREVGSU5FRF9PUl9OVUxMX1RPX09CSkVDVFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgdGFyZ2V0ID0gTmF0aXZlT2JqZWN0KG9iamVjdCk7XG4gICAgZG8ge1xuICAgICAgY29uc3QgZGVzY3JpcHRvciA9IFJlZmxlY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xuICAgICAgaWYgKGRlc2NyaXB0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoT2JqZWN0SGFzT3duKGRlc2NyaXB0b3IsIFwiZ2V0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3IuZ2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKCh0YXJnZXQgPSBSZWZsZWN0R2V0UHJvdG90eXBlT2YodGFyZ2V0KSkgIT09IG51bGwpO1xuICB9O1xuLyoqIEB0eXBlIHsob2JqZWN0OiBvYmplY3QsIGtleTogUHJvcGVydHlLZXkpID0+IGJvb2xlYW59ICovXG5leHBvcnQgY29uc3QgT2JqZWN0SGFzT3duID0gLyoqIEB0eXBlIHthbnl9ICovIChOYXRpdmVPYmplY3QpLmhhc093biB8fFxuICB1bmN1cnJ5VGhpcyhPYmplY3RQcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG4vLyBBcnJheVxuY29uc3QgTmF0aXZlQXJyYXkgPSBBcnJheTtcbmV4cG9ydCBjb25zdCBBcnJheUlzQXJyYXkgPSBOYXRpdmVBcnJheS5pc0FycmF5O1xuY29uc3QgQXJyYXlQcm90b3R5cGUgPSBOYXRpdmVBcnJheS5wcm90b3R5cGU7XG4vKiogQHR5cGUgeyhhcnJheTogQXJyYXlMaWtlPHVua25vd24+LCBzZXBhcmF0b3I/OiBzdHJpbmcpID0+IHN0cmluZ30gKi9cbmV4cG9ydCBjb25zdCBBcnJheVByb3RvdHlwZUpvaW4gPSB1bmN1cnJ5VGhpcyhBcnJheVByb3RvdHlwZS5qb2luKTtcbi8qKiBAdHlwZSB7PFQ+KGFycmF5OiBUW10sIC4uLml0ZW1zOiBUW10pID0+IG51bWJlcn0gKi9cbmV4cG9ydCBjb25zdCBBcnJheVByb3RvdHlwZVB1c2ggPSB1bmN1cnJ5VGhpcyhBcnJheVByb3RvdHlwZS5wdXNoKTtcbi8qKiBAdHlwZSB7KGFycmF5OiBBcnJheUxpa2U8dW5rbm93bj4sIC4uLm9wdHM6IGFueVtdKSA9PiBzdHJpbmd9ICovXG5leHBvcnQgY29uc3QgQXJyYXlQcm90b3R5cGVUb0xvY2FsZVN0cmluZyA9IHVuY3VycnlUaGlzKFxuICBBcnJheVByb3RvdHlwZS50b0xvY2FsZVN0cmluZ1xuKTtcbmV4cG9ydCBjb25zdCBOYXRpdmVBcnJheVByb3RvdHlwZVN5bWJvbEl0ZXJhdG9yID0gQXJyYXlQcm90b3R5cGVbU3ltYm9sSXRlcmF0b3JdO1xuLyoqIEB0eXBlIHs8VD4oYXJyYXk6IFRbXSkgPT4gSXRlcmFibGVJdGVyYXRvcjxUPn0gKi9cbmV4cG9ydCBjb25zdCBBcnJheVByb3RvdHlwZVN5bWJvbEl0ZXJhdG9yID0gdW5jdXJyeVRoaXMoTmF0aXZlQXJyYXlQcm90b3R5cGVTeW1ib2xJdGVyYXRvcik7XG5cbi8vIE1hdGhcbmV4cG9ydCBjb25zdCB7XG4gIGFiczogTWF0aEFicyxcbiAgdHJ1bmM6IE1hdGhUcnVuYyxcbn0gPSBNYXRoO1xuXG4vLyBBcnJheUJ1ZmZlclxuZXhwb3J0IGNvbnN0IE5hdGl2ZUFycmF5QnVmZmVyID0gQXJyYXlCdWZmZXI7XG5leHBvcnQgY29uc3QgQXJyYXlCdWZmZXJJc1ZpZXcgPSBOYXRpdmVBcnJheUJ1ZmZlci5pc1ZpZXc7XG5jb25zdCBBcnJheUJ1ZmZlclByb3RvdHlwZSA9IE5hdGl2ZUFycmF5QnVmZmVyLnByb3RvdHlwZTtcbi8qKiBAdHlwZSB7KGJ1ZmZlcjogQXJyYXlCdWZmZXIsIGJlZ2luPzogbnVtYmVyLCBlbmQ/OiBudW1iZXIpID0+IG51bWJlcn0gKi9cbmV4cG9ydCBjb25zdCBBcnJheUJ1ZmZlclByb3RvdHlwZVNsaWNlID0gdW5jdXJyeVRoaXMoQXJyYXlCdWZmZXJQcm90b3R5cGUuc2xpY2UpO1xuLyoqIEB0eXBlIHsoYnVmZmVyOiBBcnJheUJ1ZmZlcikgPT4gQXJyYXlCdWZmZXJ9ICovXG5leHBvcnQgY29uc3QgQXJyYXlCdWZmZXJQcm90b3R5cGVHZXRCeXRlTGVuZ3RoID0gdW5jdXJyeVRoaXNHZXR0ZXIoQXJyYXlCdWZmZXJQcm90b3R5cGUsIFwiYnl0ZUxlbmd0aFwiKTtcblxuLy8gU2hhcmVkQXJyYXlCdWZmZXJcbmV4cG9ydCBjb25zdCBOYXRpdmVTaGFyZWRBcnJheUJ1ZmZlciA9IHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIiA/IFNoYXJlZEFycmF5QnVmZmVyIDogbnVsbDtcbi8qKiBAdHlwZSB7KGJ1ZmZlcjogU2hhcmVkQXJyYXlCdWZmZXIpID0+IFNoYXJlZEFycmF5QnVmZmVyfSAqL1xuZXhwb3J0IGNvbnN0IFNoYXJlZEFycmF5QnVmZmVyUHJvdG90eXBlR2V0Qnl0ZUxlbmd0aCA9IE5hdGl2ZVNoYXJlZEFycmF5QnVmZmVyXG4gICYmIHVuY3VycnlUaGlzR2V0dGVyKE5hdGl2ZVNoYXJlZEFycmF5QnVmZmVyLnByb3RvdHlwZSwgXCJieXRlTGVuZ3RoXCIpO1xuXG4vLyBUeXBlZEFycmF5XG4vKiogQHR5cGVkZWYge1VpbnQ4QXJyYXl8VWludDhDbGFtcGVkQXJyYXl8VWludDE2QXJyYXl8VWludDMyQXJyYXl8SW50OEFycmF5fEludDE2QXJyYXl8SW50MzJBcnJheXxGbG9hdDMyQXJyYXl8RmxvYXQ2NEFycmF5fEJpZ1VpbnQ2NEFycmF5fEJpZ0ludDY0QXJyYXl9IFR5cGVkQXJyYXkgKi9cbi8qKiBAdHlwZSB7YW55fSAqL1xuZXhwb3J0IGNvbnN0IFR5cGVkQXJyYXkgPSBSZWZsZWN0R2V0UHJvdG90eXBlT2YoVWludDhBcnJheSk7XG5jb25zdCBUeXBlZEFycmF5RnJvbSA9IFR5cGVkQXJyYXkuZnJvbTtcbmV4cG9ydCBjb25zdCBUeXBlZEFycmF5UHJvdG90eXBlID0gVHlwZWRBcnJheS5wcm90b3R5cGU7XG5leHBvcnQgY29uc3QgTmF0aXZlVHlwZWRBcnJheVByb3RvdHlwZVN5bWJvbEl0ZXJhdG9yID0gVHlwZWRBcnJheVByb3RvdHlwZVtTeW1ib2xJdGVyYXRvcl07XG4vKiogQHR5cGUgeyh0eXBlZEFycmF5OiBUeXBlZEFycmF5KSA9PiBJdGVyYWJsZUl0ZXJhdG9yPG51bWJlcj59ICovXG5leHBvcnQgY29uc3QgVHlwZWRBcnJheVByb3RvdHlwZUtleXMgPSB1bmN1cnJ5VGhpcyhUeXBlZEFycmF5UHJvdG90eXBlLmtleXMpO1xuLyoqIEB0eXBlIHsodHlwZWRBcnJheTogVHlwZWRBcnJheSkgPT4gSXRlcmFibGVJdGVyYXRvcjxudW1iZXI+fSAqL1xuZXhwb3J0IGNvbnN0IFR5cGVkQXJyYXlQcm90b3R5cGVWYWx1ZXMgPSB1bmN1cnJ5VGhpcyhcbiAgVHlwZWRBcnJheVByb3RvdHlwZS52YWx1ZXNcbik7XG4vKiogQHR5cGUgeyh0eXBlZEFycmF5OiBUeXBlZEFycmF5KSA9PiBJdGVyYWJsZUl0ZXJhdG9yPFtudW1iZXIsIG51bWJlcl0+fSAqL1xuZXhwb3J0IGNvbnN0IFR5cGVkQXJyYXlQcm90b3R5cGVFbnRyaWVzID0gdW5jdXJyeVRoaXMoXG4gIFR5cGVkQXJyYXlQcm90b3R5cGUuZW50cmllc1xuKTtcbi8qKiBAdHlwZSB7KHR5cGVkQXJyYXk6IFR5cGVkQXJyYXksIGFycmF5OiBBcnJheUxpa2U8bnVtYmVyPiwgb2Zmc2V0PzogbnVtYmVyKSA9PiB2b2lkfSAqL1xuZXhwb3J0IGNvbnN0IFR5cGVkQXJyYXlQcm90b3R5cGVTZXQgPSB1bmN1cnJ5VGhpcyhUeXBlZEFycmF5UHJvdG90eXBlLnNldCk7XG4vKiogQHR5cGUgezxUIGV4dGVuZHMgVHlwZWRBcnJheT4odHlwZWRBcnJheTogVCkgPT4gVH0gKi9cbmV4cG9ydCBjb25zdCBUeXBlZEFycmF5UHJvdG90eXBlUmV2ZXJzZSA9IHVuY3VycnlUaGlzKFxuICBUeXBlZEFycmF5UHJvdG90eXBlLnJldmVyc2Vcbik7XG4vKiogQHR5cGUgezxUIGV4dGVuZHMgVHlwZWRBcnJheT4odHlwZWRBcnJheTogVCwgdmFsdWU6IG51bWJlciwgc3RhcnQ/OiBudW1iZXIsIGVuZD86IG51bWJlcikgPT4gVH0gKi9cbmV4cG9ydCBjb25zdCBUeXBlZEFycmF5UHJvdG90eXBlRmlsbCA9IHVuY3VycnlUaGlzKFR5cGVkQXJyYXlQcm90b3R5cGUuZmlsbCk7XG4vKiogQHR5cGUgezxUIGV4dGVuZHMgVHlwZWRBcnJheT4odHlwZWRBcnJheTogVCwgdGFyZ2V0OiBudW1iZXIsIHN0YXJ0OiBudW1iZXIsIGVuZD86IG51bWJlcikgPT4gVH0gKi9cbmV4cG9ydCBjb25zdCBUeXBlZEFycmF5UHJvdG90eXBlQ29weVdpdGhpbiA9IHVuY3VycnlUaGlzKFxuICBUeXBlZEFycmF5UHJvdG90eXBlLmNvcHlXaXRoaW5cbik7XG4vKiogQHR5cGUgezxUIGV4dGVuZHMgVHlwZWRBcnJheT4odHlwZWRBcnJheTogVCwgY29tcGFyZUZuPzogKGE6IG51bWJlciwgYjogbnVtYmVyKSA9PiBudW1iZXIpID0+IFR9ICovXG5leHBvcnQgY29uc3QgVHlwZWRBcnJheVByb3RvdHlwZVNvcnQgPSB1bmN1cnJ5VGhpcyhUeXBlZEFycmF5UHJvdG90eXBlLnNvcnQpO1xuLyoqIEB0eXBlIHs8VCBleHRlbmRzIFR5cGVkQXJyYXk+KHR5cGVkQXJyYXk6IFQsIHN0YXJ0PzogbnVtYmVyLCBlbmQ/OiBudW1iZXIpID0+IFR9ICovXG5leHBvcnQgY29uc3QgVHlwZWRBcnJheVByb3RvdHlwZVNsaWNlID0gdW5jdXJyeVRoaXMoVHlwZWRBcnJheVByb3RvdHlwZS5zbGljZSk7XG4vKiogQHR5cGUgezxUIGV4dGVuZHMgVHlwZWRBcnJheT4odHlwZWRBcnJheTogVCwgc3RhcnQ/OiBudW1iZXIsIGVuZD86IG51bWJlcikgPT4gVH0gKi9cbmV4cG9ydCBjb25zdCBUeXBlZEFycmF5UHJvdG90eXBlU3ViYXJyYXkgPSB1bmN1cnJ5VGhpcyhcbiAgVHlwZWRBcnJheVByb3RvdHlwZS5zdWJhcnJheVxuKTtcbi8qKiBAdHlwZSB7KCh0eXBlZEFycmF5OiBUeXBlZEFycmF5KSA9PiBBcnJheUJ1ZmZlcil9ICovXG5leHBvcnQgY29uc3QgVHlwZWRBcnJheVByb3RvdHlwZUdldEJ1ZmZlciA9IHVuY3VycnlUaGlzR2V0dGVyKFxuICBUeXBlZEFycmF5UHJvdG90eXBlLFxuICBcImJ1ZmZlclwiXG4pO1xuLyoqIEB0eXBlIHsoKHR5cGVkQXJyYXk6IFR5cGVkQXJyYXkpID0+IG51bWJlcil9ICovXG5leHBvcnQgY29uc3QgVHlwZWRBcnJheVByb3RvdHlwZUdldEJ5dGVPZmZzZXQgPSB1bmN1cnJ5VGhpc0dldHRlcihcbiAgVHlwZWRBcnJheVByb3RvdHlwZSxcbiAgXCJieXRlT2Zmc2V0XCJcbik7XG4vKiogQHR5cGUgeygodHlwZWRBcnJheTogVHlwZWRBcnJheSkgPT4gbnVtYmVyKX0gKi9cbmV4cG9ydCBjb25zdCBUeXBlZEFycmF5UHJvdG90eXBlR2V0TGVuZ3RoID0gdW5jdXJyeVRoaXNHZXR0ZXIoXG4gIFR5cGVkQXJyYXlQcm90b3R5cGUsXG4gIFwibGVuZ3RoXCJcbik7XG4vKiogQHR5cGUgeyh0YXJnZXQ6IHVua25vd24pID0+IHN0cmluZ30gKi9cbmV4cG9ydCBjb25zdCBUeXBlZEFycmF5UHJvdG90eXBlR2V0U3ltYm9sVG9TdHJpbmdUYWcgPSB1bmN1cnJ5VGhpc0dldHRlcihcbiAgVHlwZWRBcnJheVByb3RvdHlwZSxcbiAgU3ltYm9sVG9TdHJpbmdUYWdcbik7XG5cbi8vIFVpbnQ4QXJyYXlcbmV4cG9ydCBjb25zdCBOYXRpdmVVaW50OEFycmF5ID0gVWludDhBcnJheTtcblxuLy8gVWludDE2QXJyYXlcbmV4cG9ydCBjb25zdCBOYXRpdmVVaW50MTZBcnJheSA9IFVpbnQxNkFycmF5O1xuLyoqIEB0eXBlIHtVaW50MTZBcnJheUNvbnN0cnVjdG9yW1wiZnJvbVwiXX0gKi9cbmV4cG9ydCBjb25zdCBVaW50MTZBcnJheUZyb20gPSAoLi4uYXJncykgPT4ge1xuICByZXR1cm4gUmVmbGVjdEFwcGx5KFR5cGVkQXJyYXlGcm9tLCBOYXRpdmVVaW50MTZBcnJheSwgYXJncyk7XG59O1xuXG4vLyBVaW50MzJBcnJheVxuZXhwb3J0IGNvbnN0IE5hdGl2ZVVpbnQzMkFycmF5ID0gVWludDMyQXJyYXk7XG5cbi8vIEZsb2F0MzJBcnJheVxuZXhwb3J0IGNvbnN0IE5hdGl2ZUZsb2F0MzJBcnJheSA9IEZsb2F0MzJBcnJheTtcblxuLy8gQXJyYXlJdGVyYXRvclxuLyoqIEB0eXBlIHthbnl9ICovXG5leHBvcnQgY29uc3QgQXJyYXlJdGVyYXRvclByb3RvdHlwZSA9IFJlZmxlY3RHZXRQcm90b3R5cGVPZihbXVtTeW1ib2xJdGVyYXRvcl0oKSk7XG4vKiogQHR5cGUgezxUPihhcnJheUl0ZXJhdG9yOiBJdGVyYWJsZUl0ZXJhdG9yPFQ+KSA9PiBJdGVyYXRvclJlc3VsdDxUPn0gKi9cbmV4cG9ydCBjb25zdCBBcnJheUl0ZXJhdG9yUHJvdG90eXBlTmV4dCA9IHVuY3VycnlUaGlzKEFycmF5SXRlcmF0b3JQcm90b3R5cGUubmV4dCk7XG5cbi8vIEdlbmVyYXRvclxuLyoqIEB0eXBlIHs8VCA9IHVua25vd24sIFRSZXR1cm4gPSBhbnksIFROZXh0ID0gdW5rbm93bj4oZ2VuZXJhdG9yOiBHZW5lcmF0b3I8VCwgVFJldHVybiwgVE5leHQ+LCB2YWx1ZT86IFROZXh0KSA9PiBUfSAqL1xuZXhwb3J0IGNvbnN0IEdlbmVyYXRvclByb3RvdHlwZU5leHQgPSB1bmN1cnJ5VGhpcygoZnVuY3Rpb24qICgpIHt9KSgpLm5leHQpO1xuXG4vLyBJdGVyYXRvclxuZXhwb3J0IGNvbnN0IEl0ZXJhdG9yUHJvdG90eXBlID0gUmVmbGVjdEdldFByb3RvdHlwZU9mKEFycmF5SXRlcmF0b3JQcm90b3R5cGUpO1xuXG4vLyBEYXRhVmlld1xuY29uc3QgRGF0YVZpZXdQcm90b3R5cGUgPSBEYXRhVmlldy5wcm90b3R5cGU7XG4vKiogQHR5cGUgeyhkYXRhVmlldzogRGF0YVZpZXcsIGJ5dGVPZmZzZXQ6IG51bWJlciwgbGl0dGxlRW5kaWFuPzogYm9vbGVhbikgPT4gbnVtYmVyfSAqL1xuZXhwb3J0IGNvbnN0IERhdGFWaWV3UHJvdG90eXBlR2V0VWludDE2ID0gdW5jdXJyeVRoaXMoXG4gIERhdGFWaWV3UHJvdG90eXBlLmdldFVpbnQxNlxuKTtcbi8qKiBAdHlwZSB7KGRhdGFWaWV3OiBEYXRhVmlldywgYnl0ZU9mZnNldDogbnVtYmVyLCB2YWx1ZTogbnVtYmVyLCBsaXR0bGVFbmRpYW4/OiBib29sZWFuKSA9PiB2b2lkfSAqL1xuZXhwb3J0IGNvbnN0IERhdGFWaWV3UHJvdG90eXBlU2V0VWludDE2ID0gdW5jdXJyeVRoaXMoXG4gIERhdGFWaWV3UHJvdG90eXBlLnNldFVpbnQxNlxuKTtcblxuLy8gRXJyb3JcbmV4cG9ydCBjb25zdCBOYXRpdmVUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5leHBvcnQgY29uc3QgTmF0aXZlUmFuZ2VFcnJvciA9IFJhbmdlRXJyb3I7XG5cbi8vIFdlYWtTZXRcbi8qKlxuICogRG8gbm90IGNvbnN0cnVjdCB3aXRoIGFyZ3VtZW50cyB0byBhdm9pZCBjYWxsaW5nIHRoZSBcImFkZFwiIG1ldGhvZFxuICogQHR5cGUge3tuZXcgPFQgZXh0ZW5kcyB7fT4oKTogV2Vha1NldDxUPn19XG4gKi9cbmV4cG9ydCBjb25zdCBOYXRpdmVXZWFrU2V0ID0gV2Vha1NldDtcbmNvbnN0IFdlYWtTZXRQcm90b3R5cGUgPSBOYXRpdmVXZWFrU2V0LnByb3RvdHlwZTtcbi8qKiBAdHlwZSB7PFQgZXh0ZW5kcyB7fT4oc2V0OiBXZWFrU2V0PFQ+LCB2YWx1ZTogVCkgPT4gU2V0PFQ+fSAqL1xuZXhwb3J0IGNvbnN0IFdlYWtTZXRQcm90b3R5cGVBZGQgPSB1bmN1cnJ5VGhpcyhXZWFrU2V0UHJvdG90eXBlLmFkZCk7XG4vKiogQHR5cGUgezxUIGV4dGVuZHMge30+KHNldDogV2Vha1NldDxUPiwgdmFsdWU6IFQpID0+IGJvb2xlYW59ICovXG5leHBvcnQgY29uc3QgV2Vha1NldFByb3RvdHlwZUhhcyA9IHVuY3VycnlUaGlzKFdlYWtTZXRQcm90b3R5cGUuaGFzKTtcblxuLy8gV2Vha01hcFxuLyoqXG4gKiBEbyBub3QgY29uc3RydWN0IHdpdGggYXJndW1lbnRzIHRvIGF2b2lkIGNhbGxpbmcgdGhlIFwic2V0XCIgbWV0aG9kXG4gKiBAdHlwZSB7e25ldyA8SyBleHRlbmRzIHt9LCBWPigpOiBXZWFrTWFwPEssIFY+fX1cbiAqL1xuZXhwb3J0IGNvbnN0IE5hdGl2ZVdlYWtNYXAgPSBXZWFrTWFwO1xuY29uc3QgV2Vha01hcFByb3RvdHlwZSA9IE5hdGl2ZVdlYWtNYXAucHJvdG90eXBlO1xuLyoqIEB0eXBlIHs8SyBleHRlbmRzIHt9LCBWPih3ZWFrTWFwOiBXZWFrTWFwPEssIFY+LCBrZXk6IEspID0+IFZ9ICovXG5leHBvcnQgY29uc3QgV2Vha01hcFByb3RvdHlwZUdldCA9IHVuY3VycnlUaGlzKFdlYWtNYXBQcm90b3R5cGUuZ2V0KTtcbi8qKiBAdHlwZSB7PEsgZXh0ZW5kcyB7fSwgVj4od2Vha01hcDogV2Vha01hcDxLLCBWPiwga2V5OiBLKSA9PiBib29sZWFufSAqL1xuZXhwb3J0IGNvbnN0IFdlYWtNYXBQcm90b3R5cGVIYXMgPSB1bmN1cnJ5VGhpcyhXZWFrTWFwUHJvdG90eXBlLmhhcyk7XG4vKiogQHR5cGUgezxLIGV4dGVuZHMge30sIFY+KHdlYWtNYXA6IFdlYWtNYXA8SywgVj4sIGtleTogSywgdmFsdWU6IFYpID0+IFdlYWtNYXB9ICovXG5leHBvcnQgY29uc3QgV2Vha01hcFByb3RvdHlwZVNldCA9IHVuY3VycnlUaGlzKFdlYWtNYXBQcm90b3R5cGUuc2V0KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@petamoriken/float16/src/_util/primordials.mjs\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/compression/basedecoder.js":
/*!*********************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/basedecoder.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ BaseDecoder)\n/* harmony export */ });\n/* harmony import */ var _predictor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../predictor.js */ \"./node_modules/geotiff/dist-module/predictor.js\");\n\n\nclass BaseDecoder {\n  async decode(fileDirectory, buffer) {\n    const decoded = await this.decodeBlock(buffer);\n    const predictor = fileDirectory.Predictor || 1;\n    if (predictor !== 1) {\n      const isTiled = !fileDirectory.StripOffsets;\n      const tileWidth = isTiled ? fileDirectory.TileWidth : fileDirectory.ImageWidth;\n      const tileHeight = isTiled ? fileDirectory.TileLength : (\n        fileDirectory.RowsPerStrip || fileDirectory.ImageLength\n      );\n      return (0,_predictor_js__WEBPACK_IMPORTED_MODULE_0__.applyPredictor)(\n        decoded, predictor, tileWidth, tileHeight, fileDirectory.BitsPerSample,\n        fileDirectory.PlanarConfiguration,\n      );\n    }\n    return decoded;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9jb21wcmVzc2lvbi9iYXNlZGVjb2Rlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZXJyaWFqcy1tYXAvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9jb21wcmVzc2lvbi9iYXNlZGVjb2Rlci5qcz82ZWIwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFwcGx5UHJlZGljdG9yIH0gZnJvbSAnLi4vcHJlZGljdG9yLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZURlY29kZXIge1xuICBhc3luYyBkZWNvZGUoZmlsZURpcmVjdG9yeSwgYnVmZmVyKSB7XG4gICAgY29uc3QgZGVjb2RlZCA9IGF3YWl0IHRoaXMuZGVjb2RlQmxvY2soYnVmZmVyKTtcbiAgICBjb25zdCBwcmVkaWN0b3IgPSBmaWxlRGlyZWN0b3J5LlByZWRpY3RvciB8fCAxO1xuICAgIGlmIChwcmVkaWN0b3IgIT09IDEpIHtcbiAgICAgIGNvbnN0IGlzVGlsZWQgPSAhZmlsZURpcmVjdG9yeS5TdHJpcE9mZnNldHM7XG4gICAgICBjb25zdCB0aWxlV2lkdGggPSBpc1RpbGVkID8gZmlsZURpcmVjdG9yeS5UaWxlV2lkdGggOiBmaWxlRGlyZWN0b3J5LkltYWdlV2lkdGg7XG4gICAgICBjb25zdCB0aWxlSGVpZ2h0ID0gaXNUaWxlZCA/IGZpbGVEaXJlY3RvcnkuVGlsZUxlbmd0aCA6IChcbiAgICAgICAgZmlsZURpcmVjdG9yeS5Sb3dzUGVyU3RyaXAgfHwgZmlsZURpcmVjdG9yeS5JbWFnZUxlbmd0aFxuICAgICAgKTtcbiAgICAgIHJldHVybiBhcHBseVByZWRpY3RvcihcbiAgICAgICAgZGVjb2RlZCwgcHJlZGljdG9yLCB0aWxlV2lkdGgsIHRpbGVIZWlnaHQsIGZpbGVEaXJlY3RvcnkuQml0c1BlclNhbXBsZSxcbiAgICAgICAgZmlsZURpcmVjdG9yeS5QbGFuYXJDb25maWd1cmF0aW9uLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZWQ7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/compression/basedecoder.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/compression/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/compression/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addDecoder: () => (/* binding */ addDecoder),\n/* harmony export */   getDecoder: () => (/* binding */ getDecoder)\n/* harmony export */ });\nconst registry = new Map();\n\nfunction addDecoder(cases, importFn) {\n  if (!Array.isArray(cases)) {\n    cases = [cases]; // eslint-disable-line no-param-reassign\n  }\n  cases.forEach((c) => registry.set(c, importFn));\n}\n\nasync function getDecoder(fileDirectory) {\n  const importFn = registry.get(fileDirectory.Compression);\n  if (!importFn) {\n    throw new Error(`Unknown compression method identifier: ${fileDirectory.Compression}`);\n  }\n  const Decoder = await importFn();\n  return new Decoder(fileDirectory);\n}\n\n// Add default decoders to registry (end-user may override with other implementations)\naddDecoder([undefined, 1], () => __webpack_require__.e(/*! import() */ \"node_modules_geotiff_dist-module_compression_raw_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./raw.js */ \"./node_modules/geotiff/dist-module/compression/raw.js\")).then((m) => m.default));\naddDecoder(5, () => __webpack_require__.e(/*! import() */ \"node_modules_geotiff_dist-module_compression_lzw_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./lzw.js */ \"./node_modules/geotiff/dist-module/compression/lzw.js\")).then((m) => m.default));\naddDecoder(6, () => {\n  throw new Error('old style JPEG compression is not supported.');\n});\naddDecoder(7, () => __webpack_require__.e(/*! import() */ \"vendors-node_modules_geotiff_dist-module_compression_jpeg_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./jpeg.js */ \"./node_modules/geotiff/dist-module/compression/jpeg.js\")).then((m) => m.default));\naddDecoder([8, 32946], () => Promise.all(/*! import() */[__webpack_require__.e(\"vendors-node_modules_pako_dist_pako_esm_mjs\"), __webpack_require__.e(\"node_modules_geotiff_dist-module_compression_deflate_js\")]).then(__webpack_require__.bind(__webpack_require__, /*! ./deflate.js */ \"./node_modules/geotiff/dist-module/compression/deflate.js\")).then((m) => m.default));\naddDecoder(32773, () => __webpack_require__.e(/*! import() */ \"node_modules_geotiff_dist-module_compression_packbits_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./packbits.js */ \"./node_modules/geotiff/dist-module/compression/packbits.js\")).then((m) => m.default));\naddDecoder(34887, () => Promise.all(/*! import() */[__webpack_require__.e(\"vendors-node_modules_pako_dist_pako_esm_mjs\"), __webpack_require__.e(\"vendors-node_modules_geotiff_dist-module_compression_lerc_js\")]).then(__webpack_require__.bind(__webpack_require__, /*! ./lerc.js */ \"./node_modules/geotiff/dist-module/compression/lerc.js\"))\n  .then(async (m) => {\n    await m.zstd.init();\n    return m;\n  })\n  .then((m) => m.default),\n);\naddDecoder(50001, () => __webpack_require__.e(/*! import() */ \"node_modules_geotiff_dist-module_compression_webimage_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./webimage.js */ \"./node_modules/geotiff/dist-module/compression/webimage.js\")).then((m) => m.default));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9jb21wcmVzc2lvbi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZXJyaWFqcy1tYXAvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9jb21wcmVzc2lvbi9pbmRleC5qcz8wMDg0Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHJlZ2lzdHJ5ID0gbmV3IE1hcCgpO1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkRGVjb2RlcihjYXNlcywgaW1wb3J0Rm4pIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGNhc2VzKSkge1xuICAgIGNhc2VzID0gW2Nhc2VzXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICB9XG4gIGNhc2VzLmZvckVhY2goKGMpID0+IHJlZ2lzdHJ5LnNldChjLCBpbXBvcnRGbikpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RGVjb2RlcihmaWxlRGlyZWN0b3J5KSB7XG4gIGNvbnN0IGltcG9ydEZuID0gcmVnaXN0cnkuZ2V0KGZpbGVEaXJlY3RvcnkuQ29tcHJlc3Npb24pO1xuICBpZiAoIWltcG9ydEZuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCBpZGVudGlmaWVyOiAke2ZpbGVEaXJlY3RvcnkuQ29tcHJlc3Npb259YCk7XG4gIH1cbiAgY29uc3QgRGVjb2RlciA9IGF3YWl0IGltcG9ydEZuKCk7XG4gIHJldHVybiBuZXcgRGVjb2RlcihmaWxlRGlyZWN0b3J5KTtcbn1cblxuLy8gQWRkIGRlZmF1bHQgZGVjb2RlcnMgdG8gcmVnaXN0cnkgKGVuZC11c2VyIG1heSBvdmVycmlkZSB3aXRoIG90aGVyIGltcGxlbWVudGF0aW9ucylcbmFkZERlY29kZXIoW3VuZGVmaW5lZCwgMV0sICgpID0+IGltcG9ydCgnLi9yYXcuanMnKS50aGVuKChtKSA9PiBtLmRlZmF1bHQpKTtcbmFkZERlY29kZXIoNSwgKCkgPT4gaW1wb3J0KCcuL2x6dy5qcycpLnRoZW4oKG0pID0+IG0uZGVmYXVsdCkpO1xuYWRkRGVjb2Rlcig2LCAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcignb2xkIHN0eWxlIEpQRUcgY29tcHJlc3Npb24gaXMgbm90IHN1cHBvcnRlZC4nKTtcbn0pO1xuYWRkRGVjb2Rlcig3LCAoKSA9PiBpbXBvcnQoJy4vanBlZy5qcycpLnRoZW4oKG0pID0+IG0uZGVmYXVsdCkpO1xuYWRkRGVjb2RlcihbOCwgMzI5NDZdLCAoKSA9PiBpbXBvcnQoJy4vZGVmbGF0ZS5qcycpLnRoZW4oKG0pID0+IG0uZGVmYXVsdCkpO1xuYWRkRGVjb2RlcigzMjc3MywgKCkgPT4gaW1wb3J0KCcuL3BhY2tiaXRzLmpzJykudGhlbigobSkgPT4gbS5kZWZhdWx0KSk7XG5hZGREZWNvZGVyKDM0ODg3LCAoKSA9PiBpbXBvcnQoJy4vbGVyYy5qcycpXG4gIC50aGVuKGFzeW5jIChtKSA9PiB7XG4gICAgYXdhaXQgbS56c3RkLmluaXQoKTtcbiAgICByZXR1cm4gbTtcbiAgfSlcbiAgLnRoZW4oKG0pID0+IG0uZGVmYXVsdCksXG4pO1xuYWRkRGVjb2Rlcig1MDAwMSwgKCkgPT4gaW1wb3J0KCcuL3dlYmltYWdlLmpzJykudGhlbigobSkgPT4gbS5kZWZhdWx0KSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/compression/index.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/dataslice.js":
/*!*******************************************************!*\
  !*** ./node_modules/geotiff/dist-module/dataslice.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ DataSlice)\n/* harmony export */ });\nclass DataSlice {\n  constructor(arrayBuffer, sliceOffset, littleEndian, bigTiff) {\n    this._dataView = new DataView(arrayBuffer);\n    this._sliceOffset = sliceOffset;\n    this._littleEndian = littleEndian;\n    this._bigTiff = bigTiff;\n  }\n\n  get sliceOffset() {\n    return this._sliceOffset;\n  }\n\n  get sliceTop() {\n    return this._sliceOffset + this.buffer.byteLength;\n  }\n\n  get littleEndian() {\n    return this._littleEndian;\n  }\n\n  get bigTiff() {\n    return this._bigTiff;\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  covers(offset, length) {\n    return this.sliceOffset <= offset && this.sliceTop >= offset + length;\n  }\n\n  readUint8(offset) {\n    return this._dataView.getUint8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt8(offset) {\n    return this._dataView.getInt8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint16(offset) {\n    return this._dataView.getUint16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt16(offset) {\n    return this._dataView.getInt16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint32(offset) {\n    return this._dataView.getUint32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt32(offset) {\n    return this._dataView.getInt32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat32(offset) {\n    return this._dataView.getFloat32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat64(offset) {\n    return this._dataView.getFloat64(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint64(offset) {\n    const left = this.readUint32(offset);\n    const right = this.readUint32(offset + 4);\n    let combined;\n    if (this._littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  readInt64(offset) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (this._littleEndian ? 7 : 0)) & 0x80)\n      > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(\n        offset + (this._littleEndian ? i : 7 - i),\n      );\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  readOffset(offset) {\n    if (this._bigTiff) {\n      return this.readUint64(offset);\n    }\n    return this.readUint32(offset);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9kYXRhc2xpY2UuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZXJyaWFqcy1tYXAvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9kYXRhc2xpY2UuanM/MmRiOCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBjbGFzcyBEYXRhU2xpY2Uge1xuICBjb25zdHJ1Y3RvcihhcnJheUJ1ZmZlciwgc2xpY2VPZmZzZXQsIGxpdHRsZUVuZGlhbiwgYmlnVGlmZikge1xuICAgIHRoaXMuX2RhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGFycmF5QnVmZmVyKTtcbiAgICB0aGlzLl9zbGljZU9mZnNldCA9IHNsaWNlT2Zmc2V0O1xuICAgIHRoaXMuX2xpdHRsZUVuZGlhbiA9IGxpdHRsZUVuZGlhbjtcbiAgICB0aGlzLl9iaWdUaWZmID0gYmlnVGlmZjtcbiAgfVxuXG4gIGdldCBzbGljZU9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2xpY2VPZmZzZXQ7XG4gIH1cblxuICBnZXQgc2xpY2VUb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NsaWNlT2Zmc2V0ICsgdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgfVxuXG4gIGdldCBsaXR0bGVFbmRpYW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xpdHRsZUVuZGlhbjtcbiAgfVxuXG4gIGdldCBiaWdUaWZmKCkge1xuICAgIHJldHVybiB0aGlzLl9iaWdUaWZmO1xuICB9XG5cbiAgZ2V0IGJ1ZmZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuYnVmZmVyO1xuICB9XG5cbiAgY292ZXJzKG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2xpY2VPZmZzZXQgPD0gb2Zmc2V0ICYmIHRoaXMuc2xpY2VUb3AgPj0gb2Zmc2V0ICsgbGVuZ3RoO1xuICB9XG5cbiAgcmVhZFVpbnQ4KG9mZnNldCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRVaW50OChcbiAgICAgIG9mZnNldCAtIHRoaXMuX3NsaWNlT2Zmc2V0LCB0aGlzLl9saXR0bGVFbmRpYW4sXG4gICAgKTtcbiAgfVxuXG4gIHJlYWRJbnQ4KG9mZnNldCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRJbnQ4KFxuICAgICAgb2Zmc2V0IC0gdGhpcy5fc2xpY2VPZmZzZXQsIHRoaXMuX2xpdHRsZUVuZGlhbixcbiAgICApO1xuICB9XG5cbiAgcmVhZFVpbnQxNihvZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0VWludDE2KFxuICAgICAgb2Zmc2V0IC0gdGhpcy5fc2xpY2VPZmZzZXQsIHRoaXMuX2xpdHRsZUVuZGlhbixcbiAgICApO1xuICB9XG5cbiAgcmVhZEludDE2KG9mZnNldCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRJbnQxNihcbiAgICAgIG9mZnNldCAtIHRoaXMuX3NsaWNlT2Zmc2V0LCB0aGlzLl9saXR0bGVFbmRpYW4sXG4gICAgKTtcbiAgfVxuXG4gIHJlYWRVaW50MzIob2Zmc2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmdldFVpbnQzMihcbiAgICAgIG9mZnNldCAtIHRoaXMuX3NsaWNlT2Zmc2V0LCB0aGlzLl9saXR0bGVFbmRpYW4sXG4gICAgKTtcbiAgfVxuXG4gIHJlYWRJbnQzMihvZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0SW50MzIoXG4gICAgICBvZmZzZXQgLSB0aGlzLl9zbGljZU9mZnNldCwgdGhpcy5fbGl0dGxlRW5kaWFuLFxuICAgICk7XG4gIH1cblxuICByZWFkRmxvYXQzMihvZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0RmxvYXQzMihcbiAgICAgIG9mZnNldCAtIHRoaXMuX3NsaWNlT2Zmc2V0LCB0aGlzLl9saXR0bGVFbmRpYW4sXG4gICAgKTtcbiAgfVxuXG4gIHJlYWRGbG9hdDY0KG9mZnNldCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRGbG9hdDY0KFxuICAgICAgb2Zmc2V0IC0gdGhpcy5fc2xpY2VPZmZzZXQsIHRoaXMuX2xpdHRsZUVuZGlhbixcbiAgICApO1xuICB9XG5cbiAgcmVhZFVpbnQ2NChvZmZzZXQpIHtcbiAgICBjb25zdCBsZWZ0ID0gdGhpcy5yZWFkVWludDMyKG9mZnNldCk7XG4gICAgY29uc3QgcmlnaHQgPSB0aGlzLnJlYWRVaW50MzIob2Zmc2V0ICsgNCk7XG4gICAgbGV0IGNvbWJpbmVkO1xuICAgIGlmICh0aGlzLl9saXR0bGVFbmRpYW4pIHtcbiAgICAgIGNvbWJpbmVkID0gbGVmdCArICgoMiAqKiAzMikgKiByaWdodCk7XG4gICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGNvbWJpbmVkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYCR7Y29tYmluZWR9IGV4Y2VlZHMgTUFYX1NBRkVfSU5URUdFUi4gYFxuICAgICAgICAgICsgJ1ByZWNpc2lvbiBtYXkgYmUgbG9zdC4gUGxlYXNlIHJlcG9ydCBpZiB5b3UgZ2V0IHRoaXMgbWVzc2FnZSB0byBodHRwczovL2dpdGh1Yi5jb20vZ2VvdGlmZmpzL2dlb3RpZmYuanMvaXNzdWVzJyxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21iaW5lZDtcbiAgICB9XG4gICAgY29tYmluZWQgPSAoKDIgKiogMzIpICogbGVmdCkgKyByaWdodDtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGNvbWJpbmVkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgJHtjb21iaW5lZH0gZXhjZWVkcyBNQVhfU0FGRV9JTlRFR0VSLiBgXG4gICAgICAgICsgJ1ByZWNpc2lvbiBtYXkgYmUgbG9zdC4gUGxlYXNlIHJlcG9ydCBpZiB5b3UgZ2V0IHRoaXMgbWVzc2FnZSB0byBodHRwczovL2dpdGh1Yi5jb20vZ2VvdGlmZmpzL2dlb3RpZmYuanMvaXNzdWVzJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbWJpbmVkO1xuICB9XG5cbiAgLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81NTMzODM4NC84MDYwNTkxXG4gIHJlYWRJbnQ2NChvZmZzZXQpIHtcbiAgICBsZXQgdmFsdWUgPSAwO1xuICAgIGNvbnN0IGlzTmVnYXRpdmUgPSAodGhpcy5fZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgKHRoaXMuX2xpdHRsZUVuZGlhbiA/IDcgOiAwKSkgJiAweDgwKVxuICAgICAgPiAwO1xuICAgIGxldCBjYXJyeWluZyA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICAgIGxldCBieXRlID0gdGhpcy5fZGF0YVZpZXcuZ2V0VWludDgoXG4gICAgICAgIG9mZnNldCArICh0aGlzLl9saXR0bGVFbmRpYW4gPyBpIDogNyAtIGkpLFxuICAgICAgKTtcbiAgICAgIGlmIChpc05lZ2F0aXZlKSB7XG4gICAgICAgIGlmIChjYXJyeWluZykge1xuICAgICAgICAgIGlmIChieXRlICE9PSAweDAwKSB7XG4gICAgICAgICAgICBieXRlID0gfihieXRlIC0gMSkgJiAweGZmO1xuICAgICAgICAgICAgY2FycnlpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnl0ZSA9IH5ieXRlICYgMHhmZjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFsdWUgKz0gYnl0ZSAqICgyNTYgKiogaSk7XG4gICAgfVxuICAgIGlmIChpc05lZ2F0aXZlKSB7XG4gICAgICB2YWx1ZSA9IC12YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcmVhZE9mZnNldChvZmZzZXQpIHtcbiAgICBpZiAodGhpcy5fYmlnVGlmZikge1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFVpbnQ2NChvZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZWFkVWludDMyKG9mZnNldCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/dataslice.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/dataview64.js":
/*!********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/dataview64.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ DataView64)\n/* harmony export */ });\n/* harmony import */ var _petamoriken_float16__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @petamoriken/float16 */ \"./node_modules/@petamoriken/float16/src/DataView.mjs\");\n\n\nclass DataView64 {\n  constructor(arrayBuffer) {\n    this._dataView = new DataView(arrayBuffer);\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  getUint64(offset, littleEndian) {\n    const left = this.getUint32(offset, littleEndian);\n    const right = this.getUint32(offset + 4, littleEndian);\n    let combined;\n    if (littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  getInt64(offset, littleEndian) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (littleEndian ? 7 : 0)) & 0x80) > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(offset + (littleEndian ? i : 7 - i));\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  getUint8(offset, littleEndian) {\n    return this._dataView.getUint8(offset, littleEndian);\n  }\n\n  getInt8(offset, littleEndian) {\n    return this._dataView.getInt8(offset, littleEndian);\n  }\n\n  getUint16(offset, littleEndian) {\n    return this._dataView.getUint16(offset, littleEndian);\n  }\n\n  getInt16(offset, littleEndian) {\n    return this._dataView.getInt16(offset, littleEndian);\n  }\n\n  getUint32(offset, littleEndian) {\n    return this._dataView.getUint32(offset, littleEndian);\n  }\n\n  getInt32(offset, littleEndian) {\n    return this._dataView.getInt32(offset, littleEndian);\n  }\n\n  getFloat16(offset, littleEndian) {\n    return (0,_petamoriken_float16__WEBPACK_IMPORTED_MODULE_0__.getFloat16)(this._dataView, offset, littleEndian);\n  }\n\n  getFloat32(offset, littleEndian) {\n    return this._dataView.getFloat32(offset, littleEndian);\n  }\n\n  getFloat64(offset, littleEndian) {\n    return this._dataView.getFloat64(offset, littleEndian);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9kYXRhdmlldzY0LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZXJyaWFqcy1tYXAvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9kYXRhdmlldzY0LmpzP2VjMGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0RmxvYXQxNiB9IGZyb20gJ0BwZXRhbW9yaWtlbi9mbG9hdDE2JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGF0YVZpZXc2NCB7XG4gIGNvbnN0cnVjdG9yKGFycmF5QnVmZmVyKSB7XG4gICAgdGhpcy5fZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIpO1xuICB9XG5cbiAgZ2V0IGJ1ZmZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuYnVmZmVyO1xuICB9XG5cbiAgZ2V0VWludDY0KG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgY29uc3QgbGVmdCA9IHRoaXMuZ2V0VWludDMyKG9mZnNldCwgbGl0dGxlRW5kaWFuKTtcbiAgICBjb25zdCByaWdodCA9IHRoaXMuZ2V0VWludDMyKG9mZnNldCArIDQsIGxpdHRsZUVuZGlhbik7XG4gICAgbGV0IGNvbWJpbmVkO1xuICAgIGlmIChsaXR0bGVFbmRpYW4pIHtcbiAgICAgIGNvbWJpbmVkID0gbGVmdCArICgoMiAqKiAzMikgKiByaWdodCk7XG4gICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGNvbWJpbmVkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYCR7Y29tYmluZWR9IGV4Y2VlZHMgTUFYX1NBRkVfSU5URUdFUi4gYFxuICAgICAgICAgICsgJ1ByZWNpc2lvbiBtYXkgYmUgbG9zdC4gUGxlYXNlIHJlcG9ydCBpZiB5b3UgZ2V0IHRoaXMgbWVzc2FnZSB0byBodHRwczovL2dpdGh1Yi5jb20vZ2VvdGlmZmpzL2dlb3RpZmYuanMvaXNzdWVzJyxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21iaW5lZDtcbiAgICB9XG4gICAgY29tYmluZWQgPSAoKDIgKiogMzIpICogbGVmdCkgKyByaWdodDtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGNvbWJpbmVkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgJHtjb21iaW5lZH0gZXhjZWVkcyBNQVhfU0FGRV9JTlRFR0VSLiBgXG4gICAgICAgICsgJ1ByZWNpc2lvbiBtYXkgYmUgbG9zdC4gUGxlYXNlIHJlcG9ydCBpZiB5b3UgZ2V0IHRoaXMgbWVzc2FnZSB0byBodHRwczovL2dpdGh1Yi5jb20vZ2VvdGlmZmpzL2dlb3RpZmYuanMvaXNzdWVzJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbWJpbmVkO1xuICB9XG5cbiAgLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81NTMzODM4NC84MDYwNTkxXG4gIGdldEludDY0KG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgbGV0IHZhbHVlID0gMDtcbiAgICBjb25zdCBpc05lZ2F0aXZlID0gKHRoaXMuX2RhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIChsaXR0bGVFbmRpYW4gPyA3IDogMCkpICYgMHg4MCkgPiAwO1xuICAgIGxldCBjYXJyeWluZyA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICAgIGxldCBieXRlID0gdGhpcy5fZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgKGxpdHRsZUVuZGlhbiA/IGkgOiA3IC0gaSkpO1xuICAgICAgaWYgKGlzTmVnYXRpdmUpIHtcbiAgICAgICAgaWYgKGNhcnJ5aW5nKSB7XG4gICAgICAgICAgaWYgKGJ5dGUgIT09IDB4MDApIHtcbiAgICAgICAgICAgIGJ5dGUgPSB+KGJ5dGUgLSAxKSAmIDB4ZmY7XG4gICAgICAgICAgICBjYXJyeWluZyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBieXRlID0gfmJ5dGUgJiAweGZmO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YWx1ZSArPSBieXRlICogKDI1NiAqKiBpKTtcbiAgICB9XG4gICAgaWYgKGlzTmVnYXRpdmUpIHtcbiAgICAgIHZhbHVlID0gLXZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBnZXRVaW50OChvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRVaW50OChvZmZzZXQsIGxpdHRsZUVuZGlhbik7XG4gIH1cblxuICBnZXRJbnQ4KG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmdldEludDgob2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICB9XG5cbiAgZ2V0VWludDE2KG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQsIGxpdHRsZUVuZGlhbik7XG4gIH1cblxuICBnZXRJbnQxNihvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRJbnQxNihvZmZzZXQsIGxpdHRsZUVuZGlhbik7XG4gIH1cblxuICBnZXRVaW50MzIob2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0VWludDMyKG9mZnNldCwgbGl0dGxlRW5kaWFuKTtcbiAgfVxuXG4gIGdldEludDMyKG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFWaWV3LmdldEludDMyKG9mZnNldCwgbGl0dGxlRW5kaWFuKTtcbiAgfVxuXG4gIGdldEZsb2F0MTYob2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICByZXR1cm4gZ2V0RmxvYXQxNih0aGlzLl9kYXRhVmlldywgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pO1xuICB9XG5cbiAgZ2V0RmxvYXQzMihvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgIHJldHVybiB0aGlzLl9kYXRhVmlldy5nZXRGbG9hdDMyKG9mZnNldCwgbGl0dGxlRW5kaWFuKTtcbiAgfVxuXG4gIGdldEZsb2F0NjQob2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVZpZXcuZ2V0RmxvYXQ2NChvZmZzZXQsIGxpdHRsZUVuZGlhbik7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/dataview64.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/geotiff.js":
/*!*****************************************************!*\
  !*** ./node_modules/geotiff/dist-module/geotiff.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseClient: () => (/* reexport safe */ _source_client_base_js__WEBPACK_IMPORTED_MODULE_14__.BaseClient),\n/* harmony export */   BaseDecoder: () => (/* reexport safe */ _compression_basedecoder_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   BaseResponse: () => (/* reexport safe */ _source_client_base_js__WEBPACK_IMPORTED_MODULE_14__.BaseResponse),\n/* harmony export */   GeoTIFF: () => (/* binding */ GeoTIFF),\n/* harmony export */   GeoTIFFImage: () => (/* reexport safe */ _geotiffimage_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   MultiGeoTIFF: () => (/* binding */ MultiGeoTIFF),\n/* harmony export */   Pool: () => (/* reexport safe */ _pool_js__WEBPACK_IMPORTED_MODULE_13__[\"default\"]),\n/* harmony export */   addDecoder: () => (/* reexport safe */ _compression_index_js__WEBPACK_IMPORTED_MODULE_3__.addDecoder),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromArrayBuffer: () => (/* binding */ fromArrayBuffer),\n/* harmony export */   fromBlob: () => (/* binding */ fromBlob),\n/* harmony export */   fromCustomClient: () => (/* binding */ fromCustomClient),\n/* harmony export */   fromFile: () => (/* binding */ fromFile),\n/* harmony export */   fromUrl: () => (/* binding */ fromUrl),\n/* harmony export */   fromUrls: () => (/* binding */ fromUrls),\n/* harmony export */   getDecoder: () => (/* reexport safe */ _compression_index_js__WEBPACK_IMPORTED_MODULE_3__.getDecoder),\n/* harmony export */   globals: () => (/* reexport module object */ _globals_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   rgb: () => (/* reexport module object */ _rgb_js__WEBPACK_IMPORTED_MODULE_1__),\n/* harmony export */   setLogger: () => (/* reexport safe */ _logging_js__WEBPACK_IMPORTED_MODULE_4__.setLogger),\n/* harmony export */   writeArrayBuffer: () => (/* binding */ writeArrayBuffer)\n/* harmony export */ });\n/* harmony import */ var _geotiffimage_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./geotiffimage.js */ \"./node_modules/geotiff/dist-module/geotiffimage.js\");\n/* harmony import */ var _dataview64_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./dataview64.js */ \"./node_modules/geotiff/dist-module/dataview64.js\");\n/* harmony import */ var _dataslice_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dataslice.js */ \"./node_modules/geotiff/dist-module/dataslice.js\");\n/* harmony import */ var _pool_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./pool.js */ \"./node_modules/geotiff/dist-module/pool.js\");\n/* harmony import */ var _source_remote_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./source/remote.js */ \"./node_modules/geotiff/dist-module/source/remote.js\");\n/* harmony import */ var _source_arraybuffer_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./source/arraybuffer.js */ \"./node_modules/geotiff/dist-module/source/arraybuffer.js\");\n/* harmony import */ var _source_filereader_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./source/filereader.js */ \"./node_modules/geotiff/dist-module/source/filereader.js\");\n/* harmony import */ var _source_file_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./source/file.js */ \"./node_modules/geotiff/dist-module/source/file.js\");\n/* harmony import */ var _source_client_base_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./source/client/base.js */ \"./node_modules/geotiff/dist-module/source/client/base.js\");\n/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals.js */ \"./node_modules/geotiff/dist-module/globals.js\");\n/* harmony import */ var _geotiffwriter_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./geotiffwriter.js */ \"./node_modules/geotiff/dist-module/geotiffwriter.js\");\n/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rgb.js */ \"./node_modules/geotiff/dist-module/rgb.js\");\n/* harmony import */ var _compression_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./compression/index.js */ \"./node_modules/geotiff/dist-module/compression/index.js\");\n/* harmony import */ var _logging_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./logging.js */ \"./node_modules/geotiff/dist-module/logging.js\");\n/* harmony import */ var _compression_basedecoder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./compression/basedecoder.js */ \"./node_modules/geotiff/dist-module/compression/basedecoder.js\");\n/** @module geotiff */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @typedef {Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array}\n * TypedArray\n */\n\n/**\n * @typedef {{ height:number, width: number }} Dimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray & { height: number; width: number}`\n * @typedef {TypedArray & Dimensions} TypedArrayWithDimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray[] & { height: number; width: number}`\n * @typedef {TypedArray[] & Dimensions} TypedArrayArrayWithDimensions\n */\n\n/**\n *  The autogenerated docs are a little confusing here. The effective type is:\n *\n * `(TypedArray | TypedArray[]) & { height: number; width: number}`\n * @typedef {TypedArrayWithDimensions | TypedArrayArrayWithDimensions} ReadRasterResult\n */\n\nfunction getFieldTypeLength(fieldType) {\n  switch (fieldType) {\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.BYTE: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SBYTE: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.UNDEFINED:\n      return 1;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SHORT: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SSHORT:\n      return 2;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.LONG: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SLONG: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.FLOAT: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.IFD:\n      return 4;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.RATIONAL: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SRATIONAL: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.DOUBLE:\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.LONG8: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SLONG8: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.IFD8:\n      return 8;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n}\n\nfunction parseGeoKeyDirectory(fileDirectory) {\n  const rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;\n  if (!rawGeoKeyDirectory) {\n    return null;\n  }\n\n  const geoKeyDirectory = {};\n  for (let i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {\n    const key = _globals_js__WEBPACK_IMPORTED_MODULE_0__.geoKeyNames[rawGeoKeyDirectory[i]];\n    const location = (rawGeoKeyDirectory[i + 1])\n      ? (_globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTagNames[rawGeoKeyDirectory[i + 1]]) : null;\n    const count = rawGeoKeyDirectory[i + 2];\n    const offset = rawGeoKeyDirectory[i + 3];\n\n    let value = null;\n    if (!location) {\n      value = offset;\n    } else {\n      value = fileDirectory[location];\n      if (typeof value === 'undefined' || value === null) {\n        throw new Error(`Could not get value of geoKey '${key}'.`);\n      } else if (typeof value === 'string') {\n        value = value.substring(offset, offset + count - 1);\n      } else if (value.subarray) {\n        value = value.subarray(offset, offset + count);\n        if (count === 1) {\n          value = value[0];\n        }\n      }\n    }\n    geoKeyDirectory[key] = value;\n  }\n  return geoKeyDirectory;\n}\n\nfunction getValues(dataSlice, fieldType, count, offset) {\n  let values = null;\n  let readMethod = null;\n  const fieldTypeLength = getFieldTypeLength(fieldType);\n\n  switch (fieldType) {\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.BYTE: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.UNDEFINED:\n      values = new Uint8Array(count); readMethod = dataSlice.readUint8;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SBYTE:\n      values = new Int8Array(count); readMethod = dataSlice.readInt8;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SHORT:\n      values = new Uint16Array(count); readMethod = dataSlice.readUint16;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SSHORT:\n      values = new Int16Array(count); readMethod = dataSlice.readInt16;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.LONG: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.IFD:\n      values = new Uint32Array(count); readMethod = dataSlice.readUint32;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SLONG:\n      values = new Int32Array(count); readMethod = dataSlice.readInt32;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.LONG8: case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.IFD8:\n      values = new Array(count); readMethod = dataSlice.readUint64;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SLONG8:\n      values = new Array(count); readMethod = dataSlice.readInt64;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.RATIONAL:\n      values = new Uint32Array(count * 2); readMethod = dataSlice.readUint32;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SRATIONAL:\n      values = new Int32Array(count * 2); readMethod = dataSlice.readInt32;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.FLOAT:\n      values = new Float32Array(count); readMethod = dataSlice.readFloat32;\n      break;\n    case _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.DOUBLE:\n      values = new Float64Array(count); readMethod = dataSlice.readFloat64;\n      break;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n\n  // normal fields\n  if (!(fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.RATIONAL || fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SRATIONAL)) {\n    for (let i = 0; i < count; ++i) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n    }\n  } else { // RATIONAL or SRATIONAL\n    for (let i = 0; i < count; i += 2) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n      values[i + 1] = readMethod.call(\n        dataSlice, offset + ((i * fieldTypeLength) + 4),\n      );\n    }\n  }\n\n  if (fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII) {\n    return new TextDecoder('utf-8').decode(values);\n  }\n  return values;\n}\n\n/**\n * Data class to store the parsed file directory, geo key directory and\n * offset to the next IFD\n */\nclass ImageFileDirectory {\n  constructor(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeyDirectory = geoKeyDirectory;\n    this.nextIFDByteOffset = nextIFDByteOffset;\n  }\n}\n\n/**\n * Error class for cases when an IFD index was requested, that does not exist\n * in the file.\n */\nclass GeoTIFFImageIndexError extends Error {\n  constructor(index) {\n    super(`No image at index ${index}`);\n    this.index = index;\n  }\n}\n\nclass GeoTIFFBase {\n  /**\n   * (experimental) Reads raster data from the best fitting image. This function uses\n   * the image with the lowest resolution that is still a higher resolution than the\n   * requested resolution.\n   * When specified, the `bbox` option is translated to the `window` option and the\n   * `resX` and `resY` to `width` and `height` respectively.\n   * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected\n   * image is called and the result returned.\n   * @see GeoTIFFImage.readRasters\n   * @param {import('./geotiffimage').ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded array(s), with `height` and `width`, as a promise\n   */\n  async readRasters(options = {}) {\n    const { window: imageWindow, width, height } = options;\n    let { resX, resY, bbox } = options;\n\n    const firstImage = await this.getImage();\n    let usedImage = firstImage;\n    const imageCount = await this.getImageCount();\n    const imgBBox = firstImage.getBoundingBox();\n\n    if (imageWindow && bbox) {\n      throw new Error('Both \"bbox\" and \"window\" passed.');\n    }\n\n    // if width/height is passed, transform it to resolution\n    if (width || height) {\n      // if we have an image window (pixel coordinates), transform it to a BBox\n      // using the origin/resolution of the first image.\n      if (imageWindow) {\n        const [oX, oY] = firstImage.getOrigin();\n        const [rX, rY] = firstImage.getResolution();\n\n        bbox = [\n          oX + (imageWindow[0] * rX),\n          oY + (imageWindow[1] * rY),\n          oX + (imageWindow[2] * rX),\n          oY + (imageWindow[3] * rY),\n        ];\n      }\n\n      // if we have a bbox (or calculated one)\n\n      const usedBBox = bbox || imgBBox;\n\n      if (width) {\n        if (resX) {\n          throw new Error('Both width and resX passed');\n        }\n        resX = (usedBBox[2] - usedBBox[0]) / width;\n      }\n      if (height) {\n        if (resY) {\n          throw new Error('Both width and resY passed');\n        }\n        resY = (usedBBox[3] - usedBBox[1]) / height;\n      }\n    }\n\n    // if resolution is set or calculated, try to get the image with the worst acceptable resolution\n    if (resX || resY) {\n      const allImages = [];\n      for (let i = 0; i < imageCount; ++i) {\n        const image = await this.getImage(i);\n        const { SubfileType: subfileType, NewSubfileType: newSubfileType } = image.fileDirectory;\n        if (i === 0 || subfileType === 2 || newSubfileType & 1) {\n          allImages.push(image);\n        }\n      }\n\n      allImages.sort((a, b) => a.getWidth() - b.getWidth());\n      for (let i = 0; i < allImages.length; ++i) {\n        const image = allImages[i];\n        const imgResX = (imgBBox[2] - imgBBox[0]) / image.getWidth();\n        const imgResY = (imgBBox[3] - imgBBox[1]) / image.getHeight();\n\n        usedImage = image;\n        if ((resX && resX > imgResX) || (resY && resY > imgResY)) {\n          break;\n        }\n      }\n    }\n\n    let wnd = imageWindow;\n    if (bbox) {\n      const [oX, oY] = firstImage.getOrigin();\n      const [imageResX, imageResY] = usedImage.getResolution(firstImage);\n\n      wnd = [\n        Math.round((bbox[0] - oX) / imageResX),\n        Math.round((bbox[1] - oY) / imageResY),\n        Math.round((bbox[2] - oX) / imageResX),\n        Math.round((bbox[3] - oY) / imageResY),\n      ];\n      wnd = [\n        Math.min(wnd[0], wnd[2]),\n        Math.min(wnd[1], wnd[3]),\n        Math.max(wnd[0], wnd[2]),\n        Math.max(wnd[1], wnd[3]),\n      ];\n    }\n\n    return usedImage.readRasters({ ...options, window: wnd });\n  }\n}\n\n/**\n * @typedef {Object} GeoTIFFOptions\n * @property {boolean} [cache=false] whether or not decoded tiles shall be cached.\n */\n\n/**\n * The abstraction for a whole GeoTIFF file.\n * @augments GeoTIFFBase\n */\nclass GeoTIFF extends GeoTIFFBase {\n  /**\n   * @constructor\n   * @param {*} source The datasource to read from.\n   * @param {boolean} littleEndian Whether the image uses little endian.\n   * @param {boolean} bigTiff Whether the image uses bigTIFF conventions.\n   * @param {number} firstIFDOffset The numeric byte-offset from the start of the image\n   *                                to the first IFD.\n   * @param {GeoTIFFOptions} [options] further options.\n   */\n  constructor(source, littleEndian, bigTiff, firstIFDOffset, options = {}) {\n    super();\n    this.source = source;\n    this.littleEndian = littleEndian;\n    this.bigTiff = bigTiff;\n    this.firstIFDOffset = firstIFDOffset;\n    this.cache = options.cache || false;\n    this.ifdRequests = [];\n    this.ghostValues = null;\n  }\n\n  async getSlice(offset, size) {\n    const fallbackSize = this.bigTiff ? 4048 : 1024;\n    return new _dataslice_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](\n      (await this.source.fetch([{\n        offset,\n        length: typeof size !== 'undefined' ? size : fallbackSize,\n      }]))[0],\n      offset,\n      this.littleEndian,\n      this.bigTiff,\n    );\n  }\n\n  /**\n   * Instructs to parse an image file directory at the given file offset.\n   * As there is no way to ensure that a location is indeed the start of an IFD,\n   * this function must be called with caution (e.g only using the IFD offsets from\n   * the headers or other IFDs).\n   * @param {number} offset the offset to parse the IFD at\n   * @returns {Promise<ImageFileDirectory>} the parsed IFD\n   */\n  async parseFileDirectoryAt(offset) {\n    const entrySize = this.bigTiff ? 20 : 12;\n    const offsetSize = this.bigTiff ? 8 : 2;\n\n    let dataSlice = await this.getSlice(offset);\n    const numDirEntries = this.bigTiff\n      ? dataSlice.readUint64(offset)\n      : dataSlice.readUint16(offset);\n\n    // if the slice does not cover the whole IFD, request a bigger slice, where the\n    // whole IFD fits: num of entries + n x tag length + offset to next IFD\n    const byteSize = (numDirEntries * entrySize) + (this.bigTiff ? 16 : 6);\n    if (!dataSlice.covers(offset, byteSize)) {\n      dataSlice = await this.getSlice(offset, byteSize);\n    }\n\n    const fileDirectory = {};\n\n    // loop over the IFD and create a file directory object\n    let i = offset + (this.bigTiff ? 8 : 2);\n    for (let entryCount = 0; entryCount < numDirEntries; i += entrySize, ++entryCount) {\n      const fieldTag = dataSlice.readUint16(i);\n      const fieldType = dataSlice.readUint16(i + 2);\n      const typeCount = this.bigTiff\n        ? dataSlice.readUint64(i + 4)\n        : dataSlice.readUint32(i + 4);\n\n      let fieldValues;\n      let value;\n      const fieldTypeLength = getFieldTypeLength(fieldType);\n      const valueOffset = i + (this.bigTiff ? 12 : 8);\n\n      // check whether the value is directly encoded in the tag or refers to a\n      // different external byte range\n      if (fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4)) {\n        fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);\n      } else {\n        // resolve the reference to the actual byte range\n        const actualOffset = dataSlice.readOffset(valueOffset);\n        const length = getFieldTypeLength(fieldType) * typeCount;\n\n        // check, whether we actually cover the referenced byte range; if not,\n        // request a new slice of bytes to read from it\n        if (dataSlice.covers(actualOffset, length)) {\n          fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);\n        } else {\n          const fieldDataSlice = await this.getSlice(actualOffset, length);\n          fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);\n        }\n      }\n\n      // unpack single values from the array\n      if (typeCount === 1 && _globals_js__WEBPACK_IMPORTED_MODULE_0__.arrayFields.indexOf(fieldTag) === -1\n        && !(fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.RATIONAL || fieldType === _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.SRATIONAL)) {\n        value = fieldValues[0];\n      } else {\n        value = fieldValues;\n      }\n\n      // write the tags value to the file directly\n      fileDirectory[_globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTagNames[fieldTag]] = value;\n    }\n    const geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);\n    const nextIFDByteOffset = dataSlice.readOffset(\n      offset + offsetSize + (entrySize * numDirEntries),\n    );\n\n    return new ImageFileDirectory(\n      fileDirectory,\n      geoKeyDirectory,\n      nextIFDByteOffset,\n    );\n  }\n\n  async requestIFD(index) {\n    // see if we already have that IFD index requested.\n    if (this.ifdRequests[index]) {\n      // attach to an already requested IFD\n      return this.ifdRequests[index];\n    } else if (index === 0) {\n      // special case for index 0\n      this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);\n      return this.ifdRequests[index];\n    } else if (!this.ifdRequests[index - 1]) {\n      // if the previous IFD was not yet loaded, load that one first\n      // this is the recursive call.\n      try {\n        this.ifdRequests[index - 1] = this.requestIFD(index - 1);\n      } catch (e) {\n        // if the previous one already was an index error, rethrow\n        // with the current index\n        if (e instanceof GeoTIFFImageIndexError) {\n          throw new GeoTIFFImageIndexError(index);\n        }\n        // rethrow anything else\n        throw e;\n      }\n    }\n    // if the previous IFD was loaded, we can finally fetch the one we are interested in.\n    // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed\n    this.ifdRequests[index] = (async () => {\n      const previousIfd = await this.ifdRequests[index - 1];\n      if (previousIfd.nextIFDByteOffset === 0) {\n        throw new GeoTIFFImageIndexError(index);\n      }\n      return this.parseFileDirectoryAt(previousIfd.nextIFDByteOffset);\n    })();\n    return this.ifdRequests[index];\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    const ifd = await this.requestIFD(index);\n    return new _geotiffimage_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](\n      ifd.fileDirectory, ifd.geoKeyDirectory,\n      this.dataView, this.littleEndian, this.cache, this.source,\n    );\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    let index = 0;\n    // loop until we run out of IFDs\n    let hasNext = true;\n    while (hasNext) {\n      try {\n        await this.requestIFD(index);\n        ++index;\n      } catch (e) {\n        if (e instanceof GeoTIFFImageIndexError) {\n          hasNext = false;\n        } else {\n          throw e;\n        }\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Get the values of the COG ghost area as a parsed map.\n   * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference\n   * @returns {Promise<Object>} the parsed ghost area or null, if no such area was found\n   */\n  async getGhostValues() {\n    const offset = this.bigTiff ? 16 : 8;\n    if (this.ghostValues) {\n      return this.ghostValues;\n    }\n    const detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';\n    const heuristicAreaSize = detectionString.length + 100;\n    let slice = await this.getSlice(offset, heuristicAreaSize);\n    if (detectionString === getValues(slice, _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII, detectionString.length, offset)) {\n      const valuesString = getValues(slice, _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII, heuristicAreaSize, offset);\n      const firstLine = valuesString.split('\\n')[0];\n      const metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;\n      if (metadataSize > heuristicAreaSize) {\n        slice = await this.getSlice(offset, metadataSize);\n      }\n      const fullString = getValues(slice, _globals_js__WEBPACK_IMPORTED_MODULE_0__.fieldTypes.ASCII, metadataSize, offset);\n      this.ghostValues = {};\n      fullString\n        .split('\\n')\n        .filter((line) => line.length > 0)\n        .map((line) => line.split('='))\n        .forEach(([key, value]) => {\n          this.ghostValues[key] = value;\n        });\n    }\n    return this.ghostValues;\n  }\n\n  /**\n   * Parse a (Geo)TIFF file from the given source.\n   *\n   * @param {*} source The source of data to parse from.\n   * @param {GeoTIFFOptions} [options] Additional options.\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   */\n  static async fromSource(source, options, signal) {\n    const headerData = (await source.fetch([{ offset: 0, length: 1024 }], signal))[0];\n    const dataView = new _dataview64_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](headerData);\n\n    const BOM = dataView.getUint16(0, 0);\n    let littleEndian;\n    if (BOM === 0x4949) {\n      littleEndian = true;\n    } else if (BOM === 0x4D4D) {\n      littleEndian = false;\n    } else {\n      throw new TypeError('Invalid byte order value.');\n    }\n\n    const magicNumber = dataView.getUint16(2, littleEndian);\n    let bigTiff;\n    if (magicNumber === 42) {\n      bigTiff = false;\n    } else if (magicNumber === 43) {\n      bigTiff = true;\n      const offsetByteSize = dataView.getUint16(4, littleEndian);\n      if (offsetByteSize !== 8) {\n        throw new Error('Unsupported offset byte-size.');\n      }\n    } else {\n      throw new TypeError('Invalid magic number.');\n    }\n\n    const firstIFDOffset = bigTiff\n      ? dataView.getUint64(8, littleEndian)\n      : dataView.getUint32(4, littleEndian);\n    return new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options);\n  }\n\n  /**\n   * Closes the underlying file buffer\n   * N.B. After the GeoTIFF has been completely processed it needs\n   * to be closed but only if it has been constructed from a file.\n   */\n  close() {\n    if (typeof this.source.close === 'function') {\n      return this.source.close();\n    }\n    return false;\n  }\n}\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GeoTIFF);\n\n/**\n * Wrapper for GeoTIFF files that have external overviews.\n * @augments GeoTIFFBase\n */\nclass MultiGeoTIFF extends GeoTIFFBase {\n  /**\n   * Construct a new MultiGeoTIFF from a main and several overview files.\n   * @param {GeoTIFF} mainFile The main GeoTIFF file.\n   * @param {GeoTIFF[]} overviewFiles An array of overview files.\n   */\n  constructor(mainFile, overviewFiles) {\n    super();\n    this.mainFile = mainFile;\n    this.overviewFiles = overviewFiles;\n    this.imageFiles = [mainFile].concat(overviewFiles);\n\n    this.fileDirectoriesPerFile = null;\n    this.fileDirectoriesPerFileParsing = null;\n    this.imageCount = null;\n  }\n\n  async parseFileDirectoriesPerFile() {\n    const requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)]\n      .concat(this.overviewFiles.map((file) => file.parseFileDirectoryAt(file.firstIFDOffset)));\n\n    this.fileDirectoriesPerFile = await Promise.all(requests);\n    return this.fileDirectoriesPerFile;\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    await this.getImageCount();\n    await this.parseFileDirectoriesPerFile();\n    let visited = 0;\n    let relativeIndex = 0;\n    for (let i = 0; i < this.imageFiles.length; i++) {\n      const imageFile = this.imageFiles[i];\n      for (let ii = 0; ii < this.imageCounts[i]; ii++) {\n        if (index === visited) {\n          const ifd = await imageFile.requestIFD(relativeIndex);\n          return new _geotiffimage_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](\n            ifd.fileDirectory, ifd.geoKeyDirectory,\n            imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source,\n          );\n        }\n        visited++;\n        relativeIndex++;\n      }\n      relativeIndex = 0;\n    }\n\n    throw new RangeError('Invalid image index');\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    if (this.imageCount !== null) {\n      return this.imageCount;\n    }\n    const requests = [this.mainFile.getImageCount()]\n      .concat(this.overviewFiles.map((file) => file.getImageCount()));\n    this.imageCounts = await Promise.all(requests);\n    this.imageCount = this.imageCounts.reduce((count, ifds) => count + ifds, 0);\n    return this.imageCount;\n  }\n}\n\n\n\n/**\n * Creates a new GeoTIFF from a remote URL.\n * @param {string} url The URL to access the image from\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nasync function fromUrl(url, options = {}, signal) {\n  return GeoTIFF.fromSource((0,_source_remote_js__WEBPACK_IMPORTED_MODULE_8__.makeRemoteSource)(url, options), signal);\n}\n\n/**\n * Creates a new GeoTIFF from a custom {@link BaseClient}.\n * @param {BaseClient} client The client.\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nasync function fromCustomClient(client, options = {}, signal) {\n  return GeoTIFF.fromSource((0,_source_remote_js__WEBPACK_IMPORTED_MODULE_8__.makeCustomSource)(client, options), signal);\n}\n\n/**\n * Construct a new GeoTIFF from an\n * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.\n * @param {ArrayBuffer} arrayBuffer The data to read the file from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nasync function fromArrayBuffer(arrayBuffer, signal) {\n  return GeoTIFF.fromSource((0,_source_arraybuffer_js__WEBPACK_IMPORTED_MODULE_9__.makeBufferSource)(arrayBuffer), signal);\n}\n\n/**\n * Construct a GeoTIFF from a local file path. This uses the node\n * [filesystem API]{@link https://nodejs.org/api/fs.html} and is\n * not available on browsers.\n *\n * N.B. After the GeoTIFF has been completely processed it needs\n * to be closed but only if it has been constructed from a file.\n * @param {string} path The file path to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nasync function fromFile(path, signal) {\n  return GeoTIFF.fromSource((0,_source_file_js__WEBPACK_IMPORTED_MODULE_10__.makeFileSource)(path), signal);\n}\n\n/**\n * Construct a GeoTIFF from an HTML\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or\n * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}\n * object.\n * @param {Blob|File} blob The Blob or File object to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nasync function fromBlob(blob, signal) {\n  return GeoTIFF.fromSource((0,_source_filereader_js__WEBPACK_IMPORTED_MODULE_11__.makeFileReaderSource)(blob), signal);\n}\n\n/**\n * Construct a MultiGeoTIFF from the given URLs.\n * @param {string} mainUrl The URL for the main file.\n * @param {string[]} overviewUrls An array of URLs for the overview images.\n * @param {Object} [options] Additional options to pass to the source.\n *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}\n *                           for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<MultiGeoTIFF>} The resulting MultiGeoTIFF file.\n */\nasync function fromUrls(mainUrl, overviewUrls = [], options = {}, signal) {\n  const mainFile = await GeoTIFF.fromSource((0,_source_remote_js__WEBPACK_IMPORTED_MODULE_8__.makeRemoteSource)(mainUrl, options), signal);\n  const overviewFiles = await Promise.all(\n    overviewUrls.map((url) => GeoTIFF.fromSource((0,_source_remote_js__WEBPACK_IMPORTED_MODULE_8__.makeRemoteSource)(url, options))),\n  );\n\n  return new MultiGeoTIFF(mainFile, overviewFiles);\n}\n\n/**\n * Main creating function for GeoTIFF files.\n * @param {(Array)} array of pixel values\n * @returns {metadata} metadata\n */\nfunction writeArrayBuffer(values, metadata) {\n  return (0,_geotiffwriter_js__WEBPACK_IMPORTED_MODULE_12__.writeGeotiff)(values, metadata);\n}\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9nZW90aWZmLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVycmlhanMtbWFwLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvZ2VvdGlmZi5qcz80N2JiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbW9kdWxlIGdlb3RpZmYgKi9cbmltcG9ydCBHZW9USUZGSW1hZ2UgZnJvbSAnLi9nZW90aWZmaW1hZ2UuanMnO1xuaW1wb3J0IERhdGFWaWV3NjQgZnJvbSAnLi9kYXRhdmlldzY0LmpzJztcbmltcG9ydCBEYXRhU2xpY2UgZnJvbSAnLi9kYXRhc2xpY2UuanMnO1xuaW1wb3J0IFBvb2wgZnJvbSAnLi9wb29sLmpzJztcblxuaW1wb3J0IHsgbWFrZVJlbW90ZVNvdXJjZSwgbWFrZUN1c3RvbVNvdXJjZSB9IGZyb20gJy4vc291cmNlL3JlbW90ZS5qcyc7XG5pbXBvcnQgeyBtYWtlQnVmZmVyU291cmNlIH0gZnJvbSAnLi9zb3VyY2UvYXJyYXlidWZmZXIuanMnO1xuaW1wb3J0IHsgbWFrZUZpbGVSZWFkZXJTb3VyY2UgfSBmcm9tICcuL3NvdXJjZS9maWxlcmVhZGVyLmpzJztcbmltcG9ydCB7IG1ha2VGaWxlU291cmNlIH0gZnJvbSAnLi9zb3VyY2UvZmlsZS5qcyc7XG5pbXBvcnQgeyBCYXNlQ2xpZW50LCBCYXNlUmVzcG9uc2UgfSBmcm9tICcuL3NvdXJjZS9jbGllbnQvYmFzZS5qcyc7XG5cbmltcG9ydCB7IGZpZWxkVHlwZXMsIGZpZWxkVGFnTmFtZXMsIGFycmF5RmllbGRzLCBnZW9LZXlOYW1lcyB9IGZyb20gJy4vZ2xvYmFscy5qcyc7XG5pbXBvcnQgeyB3cml0ZUdlb3RpZmYgfSBmcm9tICcuL2dlb3RpZmZ3cml0ZXIuanMnO1xuaW1wb3J0ICogYXMgZ2xvYmFscyBmcm9tICcuL2dsb2JhbHMuanMnO1xuaW1wb3J0ICogYXMgcmdiIGZyb20gJy4vcmdiLmpzJztcbmltcG9ydCB7IGdldERlY29kZXIsIGFkZERlY29kZXIgfSBmcm9tICcuL2NvbXByZXNzaW9uL2luZGV4LmpzJztcbmltcG9ydCB7IHNldExvZ2dlciB9IGZyb20gJy4vbG9nZ2luZy5qcyc7XG5cbmV4cG9ydCB7IGdsb2JhbHMgfTtcbmV4cG9ydCB7IHJnYiB9O1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBCYXNlRGVjb2RlciB9IGZyb20gJy4vY29tcHJlc3Npb24vYmFzZWRlY29kZXIuanMnO1xuZXhwb3J0IHsgZ2V0RGVjb2RlciwgYWRkRGVjb2RlciB9O1xuZXhwb3J0IHsgc2V0TG9nZ2VyIH07XG5cbi8qKlxuICogQHR5cGVkZWYge1VpbnQ4QXJyYXkgfCBJbnQ4QXJyYXkgfCBVaW50MTZBcnJheSB8IEludDE2QXJyYXkgfCBVaW50MzJBcnJheSB8IEludDMyQXJyYXkgfCBGbG9hdDMyQXJyYXkgfCBGbG9hdDY0QXJyYXl9XG4gKiBUeXBlZEFycmF5XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7eyBoZWlnaHQ6bnVtYmVyLCB3aWR0aDogbnVtYmVyIH19IERpbWVuc2lvbnNcbiAqL1xuXG4vKipcbiAqIFRoZSBhdXRvZ2VuZXJhdGVkIGRvY3MgYXJlIGEgbGl0dGxlIGNvbmZ1c2luZyBoZXJlLiBUaGUgZWZmZWN0aXZlIHR5cGUgaXM6XG4gKlxuICogYFR5cGVkQXJyYXkgJiB7IGhlaWdodDogbnVtYmVyOyB3aWR0aDogbnVtYmVyfWBcbiAqIEB0eXBlZGVmIHtUeXBlZEFycmF5ICYgRGltZW5zaW9uc30gVHlwZWRBcnJheVdpdGhEaW1lbnNpb25zXG4gKi9cblxuLyoqXG4gKiBUaGUgYXV0b2dlbmVyYXRlZCBkb2NzIGFyZSBhIGxpdHRsZSBjb25mdXNpbmcgaGVyZS4gVGhlIGVmZmVjdGl2ZSB0eXBlIGlzOlxuICpcbiAqIGBUeXBlZEFycmF5W10gJiB7IGhlaWdodDogbnVtYmVyOyB3aWR0aDogbnVtYmVyfWBcbiAqIEB0eXBlZGVmIHtUeXBlZEFycmF5W10gJiBEaW1lbnNpb25zfSBUeXBlZEFycmF5QXJyYXlXaXRoRGltZW5zaW9uc1xuICovXG5cbi8qKlxuICogIFRoZSBhdXRvZ2VuZXJhdGVkIGRvY3MgYXJlIGEgbGl0dGxlIGNvbmZ1c2luZyBoZXJlLiBUaGUgZWZmZWN0aXZlIHR5cGUgaXM6XG4gKlxuICogYChUeXBlZEFycmF5IHwgVHlwZWRBcnJheVtdKSAmIHsgaGVpZ2h0OiBudW1iZXI7IHdpZHRoOiBudW1iZXJ9YFxuICogQHR5cGVkZWYge1R5cGVkQXJyYXlXaXRoRGltZW5zaW9ucyB8IFR5cGVkQXJyYXlBcnJheVdpdGhEaW1lbnNpb25zfSBSZWFkUmFzdGVyUmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gZ2V0RmllbGRUeXBlTGVuZ3RoKGZpZWxkVHlwZSkge1xuICBzd2l0Y2ggKGZpZWxkVHlwZSkge1xuICAgIGNhc2UgZmllbGRUeXBlcy5CWVRFOiBjYXNlIGZpZWxkVHlwZXMuQVNDSUk6IGNhc2UgZmllbGRUeXBlcy5TQllURTogY2FzZSBmaWVsZFR5cGVzLlVOREVGSU5FRDpcbiAgICAgIHJldHVybiAxO1xuICAgIGNhc2UgZmllbGRUeXBlcy5TSE9SVDogY2FzZSBmaWVsZFR5cGVzLlNTSE9SVDpcbiAgICAgIHJldHVybiAyO1xuICAgIGNhc2UgZmllbGRUeXBlcy5MT05HOiBjYXNlIGZpZWxkVHlwZXMuU0xPTkc6IGNhc2UgZmllbGRUeXBlcy5GTE9BVDogY2FzZSBmaWVsZFR5cGVzLklGRDpcbiAgICAgIHJldHVybiA0O1xuICAgIGNhc2UgZmllbGRUeXBlcy5SQVRJT05BTDogY2FzZSBmaWVsZFR5cGVzLlNSQVRJT05BTDogY2FzZSBmaWVsZFR5cGVzLkRPVUJMRTpcbiAgICBjYXNlIGZpZWxkVHlwZXMuTE9ORzg6IGNhc2UgZmllbGRUeXBlcy5TTE9ORzg6IGNhc2UgZmllbGRUeXBlcy5JRkQ4OlxuICAgICAgcmV0dXJuIDg7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIGZpZWxkIHR5cGU6ICR7ZmllbGRUeXBlfWApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlR2VvS2V5RGlyZWN0b3J5KGZpbGVEaXJlY3RvcnkpIHtcbiAgY29uc3QgcmF3R2VvS2V5RGlyZWN0b3J5ID0gZmlsZURpcmVjdG9yeS5HZW9LZXlEaXJlY3Rvcnk7XG4gIGlmICghcmF3R2VvS2V5RGlyZWN0b3J5KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBnZW9LZXlEaXJlY3RvcnkgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDQ7IGkgPD0gcmF3R2VvS2V5RGlyZWN0b3J5WzNdICogNDsgaSArPSA0KSB7XG4gICAgY29uc3Qga2V5ID0gZ2VvS2V5TmFtZXNbcmF3R2VvS2V5RGlyZWN0b3J5W2ldXTtcbiAgICBjb25zdCBsb2NhdGlvbiA9IChyYXdHZW9LZXlEaXJlY3RvcnlbaSArIDFdKVxuICAgICAgPyAoZmllbGRUYWdOYW1lc1tyYXdHZW9LZXlEaXJlY3RvcnlbaSArIDFdXSkgOiBudWxsO1xuICAgIGNvbnN0IGNvdW50ID0gcmF3R2VvS2V5RGlyZWN0b3J5W2kgKyAyXTtcbiAgICBjb25zdCBvZmZzZXQgPSByYXdHZW9LZXlEaXJlY3RvcnlbaSArIDNdO1xuXG4gICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgICB2YWx1ZSA9IG9mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBmaWxlRGlyZWN0b3J5W2xvY2F0aW9uXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGdldCB2YWx1ZSBvZiBnZW9LZXkgJyR7a2V5fScuYCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcob2Zmc2V0LCBvZmZzZXQgKyBjb3VudCAtIDEpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZS5zdWJhcnJheSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgY291bnQpO1xuICAgICAgICBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGdlb0tleURpcmVjdG9yeVtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGdlb0tleURpcmVjdG9yeTtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVzKGRhdGFTbGljZSwgZmllbGRUeXBlLCBjb3VudCwgb2Zmc2V0KSB7XG4gIGxldCB2YWx1ZXMgPSBudWxsO1xuICBsZXQgcmVhZE1ldGhvZCA9IG51bGw7XG4gIGNvbnN0IGZpZWxkVHlwZUxlbmd0aCA9IGdldEZpZWxkVHlwZUxlbmd0aChmaWVsZFR5cGUpO1xuXG4gIHN3aXRjaCAoZmllbGRUeXBlKSB7XG4gICAgY2FzZSBmaWVsZFR5cGVzLkJZVEU6IGNhc2UgZmllbGRUeXBlcy5BU0NJSTogY2FzZSBmaWVsZFR5cGVzLlVOREVGSU5FRDpcbiAgICAgIHZhbHVlcyA9IG5ldyBVaW50OEFycmF5KGNvdW50KTsgcmVhZE1ldGhvZCA9IGRhdGFTbGljZS5yZWFkVWludDg7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGZpZWxkVHlwZXMuU0JZVEU6XG4gICAgICB2YWx1ZXMgPSBuZXcgSW50OEFycmF5KGNvdW50KTsgcmVhZE1ldGhvZCA9IGRhdGFTbGljZS5yZWFkSW50ODtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmllbGRUeXBlcy5TSE9SVDpcbiAgICAgIHZhbHVlcyA9IG5ldyBVaW50MTZBcnJheShjb3VudCk7IHJlYWRNZXRob2QgPSBkYXRhU2xpY2UucmVhZFVpbnQxNjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmllbGRUeXBlcy5TU0hPUlQ6XG4gICAgICB2YWx1ZXMgPSBuZXcgSW50MTZBcnJheShjb3VudCk7IHJlYWRNZXRob2QgPSBkYXRhU2xpY2UucmVhZEludDE2O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBmaWVsZFR5cGVzLkxPTkc6IGNhc2UgZmllbGRUeXBlcy5JRkQ6XG4gICAgICB2YWx1ZXMgPSBuZXcgVWludDMyQXJyYXkoY291bnQpOyByZWFkTWV0aG9kID0gZGF0YVNsaWNlLnJlYWRVaW50MzI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGZpZWxkVHlwZXMuU0xPTkc6XG4gICAgICB2YWx1ZXMgPSBuZXcgSW50MzJBcnJheShjb3VudCk7IHJlYWRNZXRob2QgPSBkYXRhU2xpY2UucmVhZEludDMyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBmaWVsZFR5cGVzLkxPTkc4OiBjYXNlIGZpZWxkVHlwZXMuSUZEODpcbiAgICAgIHZhbHVlcyA9IG5ldyBBcnJheShjb3VudCk7IHJlYWRNZXRob2QgPSBkYXRhU2xpY2UucmVhZFVpbnQ2NDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmllbGRUeXBlcy5TTE9ORzg6XG4gICAgICB2YWx1ZXMgPSBuZXcgQXJyYXkoY291bnQpOyByZWFkTWV0aG9kID0gZGF0YVNsaWNlLnJlYWRJbnQ2NDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmllbGRUeXBlcy5SQVRJT05BTDpcbiAgICAgIHZhbHVlcyA9IG5ldyBVaW50MzJBcnJheShjb3VudCAqIDIpOyByZWFkTWV0aG9kID0gZGF0YVNsaWNlLnJlYWRVaW50MzI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGZpZWxkVHlwZXMuU1JBVElPTkFMOlxuICAgICAgdmFsdWVzID0gbmV3IEludDMyQXJyYXkoY291bnQgKiAyKTsgcmVhZE1ldGhvZCA9IGRhdGFTbGljZS5yZWFkSW50MzI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGZpZWxkVHlwZXMuRkxPQVQ6XG4gICAgICB2YWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KGNvdW50KTsgcmVhZE1ldGhvZCA9IGRhdGFTbGljZS5yZWFkRmxvYXQzMjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmllbGRUeXBlcy5ET1VCTEU6XG4gICAgICB2YWx1ZXMgPSBuZXcgRmxvYXQ2NEFycmF5KGNvdW50KTsgcmVhZE1ldGhvZCA9IGRhdGFTbGljZS5yZWFkRmxvYXQ2NDtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBmaWVsZCB0eXBlOiAke2ZpZWxkVHlwZX1gKTtcbiAgfVxuXG4gIC8vIG5vcm1hbCBmaWVsZHNcbiAgaWYgKCEoZmllbGRUeXBlID09PSBmaWVsZFR5cGVzLlJBVElPTkFMIHx8IGZpZWxkVHlwZSA9PT0gZmllbGRUeXBlcy5TUkFUSU9OQUwpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICB2YWx1ZXNbaV0gPSByZWFkTWV0aG9kLmNhbGwoXG4gICAgICAgIGRhdGFTbGljZSwgb2Zmc2V0ICsgKGkgKiBmaWVsZFR5cGVMZW5ndGgpLFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7IC8vIFJBVElPTkFMIG9yIFNSQVRJT05BTFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMikge1xuICAgICAgdmFsdWVzW2ldID0gcmVhZE1ldGhvZC5jYWxsKFxuICAgICAgICBkYXRhU2xpY2UsIG9mZnNldCArIChpICogZmllbGRUeXBlTGVuZ3RoKSxcbiAgICAgICk7XG4gICAgICB2YWx1ZXNbaSArIDFdID0gcmVhZE1ldGhvZC5jYWxsKFxuICAgICAgICBkYXRhU2xpY2UsIG9mZnNldCArICgoaSAqIGZpZWxkVHlwZUxlbmd0aCkgKyA0KSxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGZpZWxkVHlwZSA9PT0gZmllbGRUeXBlcy5BU0NJSSkge1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoJ3V0Zi04JykuZGVjb2RlKHZhbHVlcyk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlcztcbn1cblxuLyoqXG4gKiBEYXRhIGNsYXNzIHRvIHN0b3JlIHRoZSBwYXJzZWQgZmlsZSBkaXJlY3RvcnksIGdlbyBrZXkgZGlyZWN0b3J5IGFuZFxuICogb2Zmc2V0IHRvIHRoZSBuZXh0IElGRFxuICovXG5jbGFzcyBJbWFnZUZpbGVEaXJlY3Rvcnkge1xuICBjb25zdHJ1Y3RvcihmaWxlRGlyZWN0b3J5LCBnZW9LZXlEaXJlY3RvcnksIG5leHRJRkRCeXRlT2Zmc2V0KSB7XG4gICAgdGhpcy5maWxlRGlyZWN0b3J5ID0gZmlsZURpcmVjdG9yeTtcbiAgICB0aGlzLmdlb0tleURpcmVjdG9yeSA9IGdlb0tleURpcmVjdG9yeTtcbiAgICB0aGlzLm5leHRJRkRCeXRlT2Zmc2V0ID0gbmV4dElGREJ5dGVPZmZzZXQ7XG4gIH1cbn1cblxuLyoqXG4gKiBFcnJvciBjbGFzcyBmb3IgY2FzZXMgd2hlbiBhbiBJRkQgaW5kZXggd2FzIHJlcXVlc3RlZCwgdGhhdCBkb2VzIG5vdCBleGlzdFxuICogaW4gdGhlIGZpbGUuXG4gKi9cbmNsYXNzIEdlb1RJRkZJbWFnZUluZGV4RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGluZGV4KSB7XG4gICAgc3VwZXIoYE5vIGltYWdlIGF0IGluZGV4ICR7aW5kZXh9YCk7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICB9XG59XG5cbmNsYXNzIEdlb1RJRkZCYXNlIHtcbiAgLyoqXG4gICAqIChleHBlcmltZW50YWwpIFJlYWRzIHJhc3RlciBkYXRhIGZyb20gdGhlIGJlc3QgZml0dGluZyBpbWFnZS4gVGhpcyBmdW5jdGlvbiB1c2VzXG4gICAqIHRoZSBpbWFnZSB3aXRoIHRoZSBsb3dlc3QgcmVzb2x1dGlvbiB0aGF0IGlzIHN0aWxsIGEgaGlnaGVyIHJlc29sdXRpb24gdGhhbiB0aGVcbiAgICogcmVxdWVzdGVkIHJlc29sdXRpb24uXG4gICAqIFdoZW4gc3BlY2lmaWVkLCB0aGUgYGJib3hgIG9wdGlvbiBpcyB0cmFuc2xhdGVkIHRvIHRoZSBgd2luZG93YCBvcHRpb24gYW5kIHRoZVxuICAgKiBgcmVzWGAgYW5kIGByZXNZYCB0byBgd2lkdGhgIGFuZCBgaGVpZ2h0YCByZXNwZWN0aXZlbHkuXG4gICAqIFRoZW4sIHRoZSBbcmVhZFJhc3RlcnNde0BsaW5rIEdlb1RJRkZJbWFnZSNyZWFkUmFzdGVyc30gbWV0aG9kIG9mIHRoZSBzZWxlY3RlZFxuICAgKiBpbWFnZSBpcyBjYWxsZWQgYW5kIHRoZSByZXN1bHQgcmV0dXJuZWQuXG4gICAqIEBzZWUgR2VvVElGRkltYWdlLnJlYWRSYXN0ZXJzXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuL2dlb3RpZmZpbWFnZScpLlJlYWRSYXN0ZXJPcHRpb25zfSBbb3B0aW9ucz17fV0gb3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZWFkUmFzdGVyUmVzdWx0Pn0gdGhlIGRlY29kZWQgYXJyYXkocyksIHdpdGggYGhlaWdodGAgYW5kIGB3aWR0aGAsIGFzIGEgcHJvbWlzZVxuICAgKi9cbiAgYXN5bmMgcmVhZFJhc3RlcnMob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyB3aW5kb3c6IGltYWdlV2luZG93LCB3aWR0aCwgaGVpZ2h0IH0gPSBvcHRpb25zO1xuICAgIGxldCB7IHJlc1gsIHJlc1ksIGJib3ggfSA9IG9wdGlvbnM7XG5cbiAgICBjb25zdCBmaXJzdEltYWdlID0gYXdhaXQgdGhpcy5nZXRJbWFnZSgpO1xuICAgIGxldCB1c2VkSW1hZ2UgPSBmaXJzdEltYWdlO1xuICAgIGNvbnN0IGltYWdlQ291bnQgPSBhd2FpdCB0aGlzLmdldEltYWdlQ291bnQoKTtcbiAgICBjb25zdCBpbWdCQm94ID0gZmlyc3RJbWFnZS5nZXRCb3VuZGluZ0JveCgpO1xuXG4gICAgaWYgKGltYWdlV2luZG93ICYmIGJib3gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQm90aCBcImJib3hcIiBhbmQgXCJ3aW5kb3dcIiBwYXNzZWQuJyk7XG4gICAgfVxuXG4gICAgLy8gaWYgd2lkdGgvaGVpZ2h0IGlzIHBhc3NlZCwgdHJhbnNmb3JtIGl0IHRvIHJlc29sdXRpb25cbiAgICBpZiAod2lkdGggfHwgaGVpZ2h0KSB7XG4gICAgICAvLyBpZiB3ZSBoYXZlIGFuIGltYWdlIHdpbmRvdyAocGl4ZWwgY29vcmRpbmF0ZXMpLCB0cmFuc2Zvcm0gaXQgdG8gYSBCQm94XG4gICAgICAvLyB1c2luZyB0aGUgb3JpZ2luL3Jlc29sdXRpb24gb2YgdGhlIGZpcnN0IGltYWdlLlxuICAgICAgaWYgKGltYWdlV2luZG93KSB7XG4gICAgICAgIGNvbnN0IFtvWCwgb1ldID0gZmlyc3RJbWFnZS5nZXRPcmlnaW4oKTtcbiAgICAgICAgY29uc3QgW3JYLCByWV0gPSBmaXJzdEltYWdlLmdldFJlc29sdXRpb24oKTtcblxuICAgICAgICBiYm94ID0gW1xuICAgICAgICAgIG9YICsgKGltYWdlV2luZG93WzBdICogclgpLFxuICAgICAgICAgIG9ZICsgKGltYWdlV2luZG93WzFdICogclkpLFxuICAgICAgICAgIG9YICsgKGltYWdlV2luZG93WzJdICogclgpLFxuICAgICAgICAgIG9ZICsgKGltYWdlV2luZG93WzNdICogclkpLFxuICAgICAgICBdO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiB3ZSBoYXZlIGEgYmJveCAob3IgY2FsY3VsYXRlZCBvbmUpXG5cbiAgICAgIGNvbnN0IHVzZWRCQm94ID0gYmJveCB8fCBpbWdCQm94O1xuXG4gICAgICBpZiAod2lkdGgpIHtcbiAgICAgICAgaWYgKHJlc1gpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JvdGggd2lkdGggYW5kIHJlc1ggcGFzc2VkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzWCA9ICh1c2VkQkJveFsyXSAtIHVzZWRCQm94WzBdKSAvIHdpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKGhlaWdodCkge1xuICAgICAgICBpZiAocmVzWSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQm90aCB3aWR0aCBhbmQgcmVzWSBwYXNzZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXNZID0gKHVzZWRCQm94WzNdIC0gdXNlZEJCb3hbMV0pIC8gaGVpZ2h0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHJlc29sdXRpb24gaXMgc2V0IG9yIGNhbGN1bGF0ZWQsIHRyeSB0byBnZXQgdGhlIGltYWdlIHdpdGggdGhlIHdvcnN0IGFjY2VwdGFibGUgcmVzb2x1dGlvblxuICAgIGlmIChyZXNYIHx8IHJlc1kpIHtcbiAgICAgIGNvbnN0IGFsbEltYWdlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbWFnZUNvdW50OyArK2kpIHtcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBhd2FpdCB0aGlzLmdldEltYWdlKGkpO1xuICAgICAgICBjb25zdCB7IFN1YmZpbGVUeXBlOiBzdWJmaWxlVHlwZSwgTmV3U3ViZmlsZVR5cGU6IG5ld1N1YmZpbGVUeXBlIH0gPSBpbWFnZS5maWxlRGlyZWN0b3J5O1xuICAgICAgICBpZiAoaSA9PT0gMCB8fCBzdWJmaWxlVHlwZSA9PT0gMiB8fCBuZXdTdWJmaWxlVHlwZSAmIDEpIHtcbiAgICAgICAgICBhbGxJbWFnZXMucHVzaChpbWFnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYWxsSW1hZ2VzLnNvcnQoKGEsIGIpID0+IGEuZ2V0V2lkdGgoKSAtIGIuZ2V0V2lkdGgoKSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbEltYWdlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBpbWFnZSA9IGFsbEltYWdlc1tpXTtcbiAgICAgICAgY29uc3QgaW1nUmVzWCA9IChpbWdCQm94WzJdIC0gaW1nQkJveFswXSkgLyBpbWFnZS5nZXRXaWR0aCgpO1xuICAgICAgICBjb25zdCBpbWdSZXNZID0gKGltZ0JCb3hbM10gLSBpbWdCQm94WzFdKSAvIGltYWdlLmdldEhlaWdodCgpO1xuXG4gICAgICAgIHVzZWRJbWFnZSA9IGltYWdlO1xuICAgICAgICBpZiAoKHJlc1ggJiYgcmVzWCA+IGltZ1Jlc1gpIHx8IChyZXNZICYmIHJlc1kgPiBpbWdSZXNZKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHduZCA9IGltYWdlV2luZG93O1xuICAgIGlmIChiYm94KSB7XG4gICAgICBjb25zdCBbb1gsIG9ZXSA9IGZpcnN0SW1hZ2UuZ2V0T3JpZ2luKCk7XG4gICAgICBjb25zdCBbaW1hZ2VSZXNYLCBpbWFnZVJlc1ldID0gdXNlZEltYWdlLmdldFJlc29sdXRpb24oZmlyc3RJbWFnZSk7XG5cbiAgICAgIHduZCA9IFtcbiAgICAgICAgTWF0aC5yb3VuZCgoYmJveFswXSAtIG9YKSAvIGltYWdlUmVzWCksXG4gICAgICAgIE1hdGgucm91bmQoKGJib3hbMV0gLSBvWSkgLyBpbWFnZVJlc1kpLFxuICAgICAgICBNYXRoLnJvdW5kKChiYm94WzJdIC0gb1gpIC8gaW1hZ2VSZXNYKSxcbiAgICAgICAgTWF0aC5yb3VuZCgoYmJveFszXSAtIG9ZKSAvIGltYWdlUmVzWSksXG4gICAgICBdO1xuICAgICAgd25kID0gW1xuICAgICAgICBNYXRoLm1pbih3bmRbMF0sIHduZFsyXSksXG4gICAgICAgIE1hdGgubWluKHduZFsxXSwgd25kWzNdKSxcbiAgICAgICAgTWF0aC5tYXgod25kWzBdLCB3bmRbMl0pLFxuICAgICAgICBNYXRoLm1heCh3bmRbMV0sIHduZFszXSksXG4gICAgICBdO1xuICAgIH1cblxuICAgIHJldHVybiB1c2VkSW1hZ2UucmVhZFJhc3RlcnMoeyAuLi5vcHRpb25zLCB3aW5kb3c6IHduZCB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEdlb1RJRkZPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjYWNoZT1mYWxzZV0gd2hldGhlciBvciBub3QgZGVjb2RlZCB0aWxlcyBzaGFsbCBiZSBjYWNoZWQuXG4gKi9cblxuLyoqXG4gKiBUaGUgYWJzdHJhY3Rpb24gZm9yIGEgd2hvbGUgR2VvVElGRiBmaWxlLlxuICogQGF1Z21lbnRzIEdlb1RJRkZCYXNlXG4gKi9cbmNsYXNzIEdlb1RJRkYgZXh0ZW5kcyBHZW9USUZGQmFzZSB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHsqfSBzb3VyY2UgVGhlIGRhdGFzb3VyY2UgdG8gcmVhZCBmcm9tLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxpdHRsZUVuZGlhbiBXaGV0aGVyIHRoZSBpbWFnZSB1c2VzIGxpdHRsZSBlbmRpYW4uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gYmlnVGlmZiBXaGV0aGVyIHRoZSBpbWFnZSB1c2VzIGJpZ1RJRkYgY29udmVudGlvbnMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmaXJzdElGRE9mZnNldCBUaGUgbnVtZXJpYyBieXRlLW9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgaW1hZ2VcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIHRoZSBmaXJzdCBJRkQuXG4gICAqIEBwYXJhbSB7R2VvVElGRk9wdGlvbnN9IFtvcHRpb25zXSBmdXJ0aGVyIG9wdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIGxpdHRsZUVuZGlhbiwgYmlnVGlmZiwgZmlyc3RJRkRPZmZzZXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5saXR0bGVFbmRpYW4gPSBsaXR0bGVFbmRpYW47XG4gICAgdGhpcy5iaWdUaWZmID0gYmlnVGlmZjtcbiAgICB0aGlzLmZpcnN0SUZET2Zmc2V0ID0gZmlyc3RJRkRPZmZzZXQ7XG4gICAgdGhpcy5jYWNoZSA9IG9wdGlvbnMuY2FjaGUgfHwgZmFsc2U7XG4gICAgdGhpcy5pZmRSZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuZ2hvc3RWYWx1ZXMgPSBudWxsO1xuICB9XG5cbiAgYXN5bmMgZ2V0U2xpY2Uob2Zmc2V0LCBzaXplKSB7XG4gICAgY29uc3QgZmFsbGJhY2tTaXplID0gdGhpcy5iaWdUaWZmID8gNDA0OCA6IDEwMjQ7XG4gICAgcmV0dXJuIG5ldyBEYXRhU2xpY2UoXG4gICAgICAoYXdhaXQgdGhpcy5zb3VyY2UuZmV0Y2goW3tcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBsZW5ndGg6IHR5cGVvZiBzaXplICE9PSAndW5kZWZpbmVkJyA/IHNpemUgOiBmYWxsYmFja1NpemUsXG4gICAgICB9XSkpWzBdLFxuICAgICAgb2Zmc2V0LFxuICAgICAgdGhpcy5saXR0bGVFbmRpYW4sXG4gICAgICB0aGlzLmJpZ1RpZmYsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnN0cnVjdHMgdG8gcGFyc2UgYW4gaW1hZ2UgZmlsZSBkaXJlY3RvcnkgYXQgdGhlIGdpdmVuIGZpbGUgb2Zmc2V0LlxuICAgKiBBcyB0aGVyZSBpcyBubyB3YXkgdG8gZW5zdXJlIHRoYXQgYSBsb2NhdGlvbiBpcyBpbmRlZWQgdGhlIHN0YXJ0IG9mIGFuIElGRCxcbiAgICogdGhpcyBmdW5jdGlvbiBtdXN0IGJlIGNhbGxlZCB3aXRoIGNhdXRpb24gKGUuZyBvbmx5IHVzaW5nIHRoZSBJRkQgb2Zmc2V0cyBmcm9tXG4gICAqIHRoZSBoZWFkZXJzIG9yIG90aGVyIElGRHMpLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IHRoZSBvZmZzZXQgdG8gcGFyc2UgdGhlIElGRCBhdFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxJbWFnZUZpbGVEaXJlY3Rvcnk+fSB0aGUgcGFyc2VkIElGRFxuICAgKi9cbiAgYXN5bmMgcGFyc2VGaWxlRGlyZWN0b3J5QXQob2Zmc2V0KSB7XG4gICAgY29uc3QgZW50cnlTaXplID0gdGhpcy5iaWdUaWZmID8gMjAgOiAxMjtcbiAgICBjb25zdCBvZmZzZXRTaXplID0gdGhpcy5iaWdUaWZmID8gOCA6IDI7XG5cbiAgICBsZXQgZGF0YVNsaWNlID0gYXdhaXQgdGhpcy5nZXRTbGljZShvZmZzZXQpO1xuICAgIGNvbnN0IG51bURpckVudHJpZXMgPSB0aGlzLmJpZ1RpZmZcbiAgICAgID8gZGF0YVNsaWNlLnJlYWRVaW50NjQob2Zmc2V0KVxuICAgICAgOiBkYXRhU2xpY2UucmVhZFVpbnQxNihvZmZzZXQpO1xuXG4gICAgLy8gaWYgdGhlIHNsaWNlIGRvZXMgbm90IGNvdmVyIHRoZSB3aG9sZSBJRkQsIHJlcXVlc3QgYSBiaWdnZXIgc2xpY2UsIHdoZXJlIHRoZVxuICAgIC8vIHdob2xlIElGRCBmaXRzOiBudW0gb2YgZW50cmllcyArIG4geCB0YWcgbGVuZ3RoICsgb2Zmc2V0IHRvIG5leHQgSUZEXG4gICAgY29uc3QgYnl0ZVNpemUgPSAobnVtRGlyRW50cmllcyAqIGVudHJ5U2l6ZSkgKyAodGhpcy5iaWdUaWZmID8gMTYgOiA2KTtcbiAgICBpZiAoIWRhdGFTbGljZS5jb3ZlcnMob2Zmc2V0LCBieXRlU2l6ZSkpIHtcbiAgICAgIGRhdGFTbGljZSA9IGF3YWl0IHRoaXMuZ2V0U2xpY2Uob2Zmc2V0LCBieXRlU2l6ZSk7XG4gICAgfVxuXG4gICAgY29uc3QgZmlsZURpcmVjdG9yeSA9IHt9O1xuXG4gICAgLy8gbG9vcCBvdmVyIHRoZSBJRkQgYW5kIGNyZWF0ZSBhIGZpbGUgZGlyZWN0b3J5IG9iamVjdFxuICAgIGxldCBpID0gb2Zmc2V0ICsgKHRoaXMuYmlnVGlmZiA/IDggOiAyKTtcbiAgICBmb3IgKGxldCBlbnRyeUNvdW50ID0gMDsgZW50cnlDb3VudCA8IG51bURpckVudHJpZXM7IGkgKz0gZW50cnlTaXplLCArK2VudHJ5Q291bnQpIHtcbiAgICAgIGNvbnN0IGZpZWxkVGFnID0gZGF0YVNsaWNlLnJlYWRVaW50MTYoaSk7XG4gICAgICBjb25zdCBmaWVsZFR5cGUgPSBkYXRhU2xpY2UucmVhZFVpbnQxNihpICsgMik7XG4gICAgICBjb25zdCB0eXBlQ291bnQgPSB0aGlzLmJpZ1RpZmZcbiAgICAgICAgPyBkYXRhU2xpY2UucmVhZFVpbnQ2NChpICsgNClcbiAgICAgICAgOiBkYXRhU2xpY2UucmVhZFVpbnQzMihpICsgNCk7XG5cbiAgICAgIGxldCBmaWVsZFZhbHVlcztcbiAgICAgIGxldCB2YWx1ZTtcbiAgICAgIGNvbnN0IGZpZWxkVHlwZUxlbmd0aCA9IGdldEZpZWxkVHlwZUxlbmd0aChmaWVsZFR5cGUpO1xuICAgICAgY29uc3QgdmFsdWVPZmZzZXQgPSBpICsgKHRoaXMuYmlnVGlmZiA/IDEyIDogOCk7XG5cbiAgICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhlIHZhbHVlIGlzIGRpcmVjdGx5IGVuY29kZWQgaW4gdGhlIHRhZyBvciByZWZlcnMgdG8gYVxuICAgICAgLy8gZGlmZmVyZW50IGV4dGVybmFsIGJ5dGUgcmFuZ2VcbiAgICAgIGlmIChmaWVsZFR5cGVMZW5ndGggKiB0eXBlQ291bnQgPD0gKHRoaXMuYmlnVGlmZiA/IDggOiA0KSkge1xuICAgICAgICBmaWVsZFZhbHVlcyA9IGdldFZhbHVlcyhkYXRhU2xpY2UsIGZpZWxkVHlwZSwgdHlwZUNvdW50LCB2YWx1ZU9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZXNvbHZlIHRoZSByZWZlcmVuY2UgdG8gdGhlIGFjdHVhbCBieXRlIHJhbmdlXG4gICAgICAgIGNvbnN0IGFjdHVhbE9mZnNldCA9IGRhdGFTbGljZS5yZWFkT2Zmc2V0KHZhbHVlT2Zmc2V0KTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZ2V0RmllbGRUeXBlTGVuZ3RoKGZpZWxkVHlwZSkgKiB0eXBlQ291bnQ7XG5cbiAgICAgICAgLy8gY2hlY2ssIHdoZXRoZXIgd2UgYWN0dWFsbHkgY292ZXIgdGhlIHJlZmVyZW5jZWQgYnl0ZSByYW5nZTsgaWYgbm90LFxuICAgICAgICAvLyByZXF1ZXN0IGEgbmV3IHNsaWNlIG9mIGJ5dGVzIHRvIHJlYWQgZnJvbSBpdFxuICAgICAgICBpZiAoZGF0YVNsaWNlLmNvdmVycyhhY3R1YWxPZmZzZXQsIGxlbmd0aCkpIHtcbiAgICAgICAgICBmaWVsZFZhbHVlcyA9IGdldFZhbHVlcyhkYXRhU2xpY2UsIGZpZWxkVHlwZSwgdHlwZUNvdW50LCBhY3R1YWxPZmZzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGZpZWxkRGF0YVNsaWNlID0gYXdhaXQgdGhpcy5nZXRTbGljZShhY3R1YWxPZmZzZXQsIGxlbmd0aCk7XG4gICAgICAgICAgZmllbGRWYWx1ZXMgPSBnZXRWYWx1ZXMoZmllbGREYXRhU2xpY2UsIGZpZWxkVHlwZSwgdHlwZUNvdW50LCBhY3R1YWxPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHVucGFjayBzaW5nbGUgdmFsdWVzIGZyb20gdGhlIGFycmF5XG4gICAgICBpZiAodHlwZUNvdW50ID09PSAxICYmIGFycmF5RmllbGRzLmluZGV4T2YoZmllbGRUYWcpID09PSAtMVxuICAgICAgICAmJiAhKGZpZWxkVHlwZSA9PT0gZmllbGRUeXBlcy5SQVRJT05BTCB8fCBmaWVsZFR5cGUgPT09IGZpZWxkVHlwZXMuU1JBVElPTkFMKSkge1xuICAgICAgICB2YWx1ZSA9IGZpZWxkVmFsdWVzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBmaWVsZFZhbHVlcztcbiAgICAgIH1cblxuICAgICAgLy8gd3JpdGUgdGhlIHRhZ3MgdmFsdWUgdG8gdGhlIGZpbGUgZGlyZWN0bHlcbiAgICAgIGZpbGVEaXJlY3RvcnlbZmllbGRUYWdOYW1lc1tmaWVsZFRhZ11dID0gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IGdlb0tleURpcmVjdG9yeSA9IHBhcnNlR2VvS2V5RGlyZWN0b3J5KGZpbGVEaXJlY3RvcnkpO1xuICAgIGNvbnN0IG5leHRJRkRCeXRlT2Zmc2V0ID0gZGF0YVNsaWNlLnJlYWRPZmZzZXQoXG4gICAgICBvZmZzZXQgKyBvZmZzZXRTaXplICsgKGVudHJ5U2l6ZSAqIG51bURpckVudHJpZXMpLFxuICAgICk7XG5cbiAgICByZXR1cm4gbmV3IEltYWdlRmlsZURpcmVjdG9yeShcbiAgICAgIGZpbGVEaXJlY3RvcnksXG4gICAgICBnZW9LZXlEaXJlY3RvcnksXG4gICAgICBuZXh0SUZEQnl0ZU9mZnNldCxcbiAgICApO1xuICB9XG5cbiAgYXN5bmMgcmVxdWVzdElGRChpbmRleCkge1xuICAgIC8vIHNlZSBpZiB3ZSBhbHJlYWR5IGhhdmUgdGhhdCBJRkQgaW5kZXggcmVxdWVzdGVkLlxuICAgIGlmICh0aGlzLmlmZFJlcXVlc3RzW2luZGV4XSkge1xuICAgICAgLy8gYXR0YWNoIHRvIGFuIGFscmVhZHkgcmVxdWVzdGVkIElGRFxuICAgICAgcmV0dXJuIHRoaXMuaWZkUmVxdWVzdHNbaW5kZXhdO1xuICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3IgaW5kZXggMFxuICAgICAgdGhpcy5pZmRSZXF1ZXN0c1tpbmRleF0gPSB0aGlzLnBhcnNlRmlsZURpcmVjdG9yeUF0KHRoaXMuZmlyc3RJRkRPZmZzZXQpO1xuICAgICAgcmV0dXJuIHRoaXMuaWZkUmVxdWVzdHNbaW5kZXhdO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuaWZkUmVxdWVzdHNbaW5kZXggLSAxXSkge1xuICAgICAgLy8gaWYgdGhlIHByZXZpb3VzIElGRCB3YXMgbm90IHlldCBsb2FkZWQsIGxvYWQgdGhhdCBvbmUgZmlyc3RcbiAgICAgIC8vIHRoaXMgaXMgdGhlIHJlY3Vyc2l2ZSBjYWxsLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5pZmRSZXF1ZXN0c1tpbmRleCAtIDFdID0gdGhpcy5yZXF1ZXN0SUZEKGluZGV4IC0gMSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGlmIHRoZSBwcmV2aW91cyBvbmUgYWxyZWFkeSB3YXMgYW4gaW5kZXggZXJyb3IsIHJldGhyb3dcbiAgICAgICAgLy8gd2l0aCB0aGUgY3VycmVudCBpbmRleFxuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEdlb1RJRkZJbWFnZUluZGV4RXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgR2VvVElGRkltYWdlSW5kZXhFcnJvcihpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0aHJvdyBhbnl0aGluZyBlbHNlXG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGlmIHRoZSBwcmV2aW91cyBJRkQgd2FzIGxvYWRlZCwgd2UgY2FuIGZpbmFsbHkgZmV0Y2ggdGhlIG9uZSB3ZSBhcmUgaW50ZXJlc3RlZCBpbi5cbiAgICAvLyB3ZSBuZWVkIHRvIHdyYXAgdGhpcyBpbiBhbiBJSUZFLCBvdGhlcndpc2UgdGhpcy5pZmRSZXF1ZXN0c1tpbmRleF0gd291bGQgYmUgZGVsYXllZFxuICAgIHRoaXMuaWZkUmVxdWVzdHNbaW5kZXhdID0gKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHByZXZpb3VzSWZkID0gYXdhaXQgdGhpcy5pZmRSZXF1ZXN0c1tpbmRleCAtIDFdO1xuICAgICAgaWYgKHByZXZpb3VzSWZkLm5leHRJRkRCeXRlT2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBHZW9USUZGSW1hZ2VJbmRleEVycm9yKGluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRmlsZURpcmVjdG9yeUF0KHByZXZpb3VzSWZkLm5leHRJRkRCeXRlT2Zmc2V0KTtcbiAgICB9KSgpO1xuICAgIHJldHVybiB0aGlzLmlmZFJlcXVlc3RzW2luZGV4XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG4tdGggaW50ZXJuYWwgc3ViZmlsZSBvZiBhbiBpbWFnZS4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGlzIHJldHVybmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4PTBdIHRoZSBpbmRleCBvZiB0aGUgaW1hZ2UgdG8gcmV0dXJuLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxHZW9USUZGSW1hZ2U+fSB0aGUgaW1hZ2UgYXQgdGhlIGdpdmVuIGluZGV4XG4gICAqL1xuICBhc3luYyBnZXRJbWFnZShpbmRleCA9IDApIHtcbiAgICBjb25zdCBpZmQgPSBhd2FpdCB0aGlzLnJlcXVlc3RJRkQoaW5kZXgpO1xuICAgIHJldHVybiBuZXcgR2VvVElGRkltYWdlKFxuICAgICAgaWZkLmZpbGVEaXJlY3RvcnksIGlmZC5nZW9LZXlEaXJlY3RvcnksXG4gICAgICB0aGlzLmRhdGFWaWV3LCB0aGlzLmxpdHRsZUVuZGlhbiwgdGhpcy5jYWNoZSwgdGhpcy5zb3VyY2UsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb3VudCBvZiB0aGUgaW50ZXJuYWwgc3ViZmlsZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59IHRoZSBudW1iZXIgb2YgaW50ZXJuYWwgc3ViZmlsZSBpbWFnZXNcbiAgICovXG4gIGFzeW5jIGdldEltYWdlQ291bnQoKSB7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICAvLyBsb29wIHVudGlsIHdlIHJ1biBvdXQgb2YgSUZEc1xuICAgIGxldCBoYXNOZXh0ID0gdHJ1ZTtcbiAgICB3aGlsZSAoaGFzTmV4dCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5yZXF1ZXN0SUZEKGluZGV4KTtcbiAgICAgICAgKytpbmRleDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBHZW9USUZGSW1hZ2VJbmRleEVycm9yKSB7XG4gICAgICAgICAgaGFzTmV4dCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmFsdWVzIG9mIHRoZSBDT0cgZ2hvc3QgYXJlYSBhcyBhIHBhcnNlZCBtYXAuXG4gICAqIFNlZSBodHRwczovL2dkYWwub3JnL2RyaXZlcnMvcmFzdGVyL2NvZy5odG1sI2hlYWRlci1naG9zdC1hcmVhIGZvciByZWZlcmVuY2VcbiAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gdGhlIHBhcnNlZCBnaG9zdCBhcmVhIG9yIG51bGwsIGlmIG5vIHN1Y2ggYXJlYSB3YXMgZm91bmRcbiAgICovXG4gIGFzeW5jIGdldEdob3N0VmFsdWVzKCkge1xuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuYmlnVGlmZiA/IDE2IDogODtcbiAgICBpZiAodGhpcy5naG9zdFZhbHVlcykge1xuICAgICAgcmV0dXJuIHRoaXMuZ2hvc3RWYWx1ZXM7XG4gICAgfVxuICAgIGNvbnN0IGRldGVjdGlvblN0cmluZyA9ICdHREFMX1NUUlVDVFVSQUxfTUVUQURBVEFfU0laRT0nO1xuICAgIGNvbnN0IGhldXJpc3RpY0FyZWFTaXplID0gZGV0ZWN0aW9uU3RyaW5nLmxlbmd0aCArIDEwMDtcbiAgICBsZXQgc2xpY2UgPSBhd2FpdCB0aGlzLmdldFNsaWNlKG9mZnNldCwgaGV1cmlzdGljQXJlYVNpemUpO1xuICAgIGlmIChkZXRlY3Rpb25TdHJpbmcgPT09IGdldFZhbHVlcyhzbGljZSwgZmllbGRUeXBlcy5BU0NJSSwgZGV0ZWN0aW9uU3RyaW5nLmxlbmd0aCwgb2Zmc2V0KSkge1xuICAgICAgY29uc3QgdmFsdWVzU3RyaW5nID0gZ2V0VmFsdWVzKHNsaWNlLCBmaWVsZFR5cGVzLkFTQ0lJLCBoZXVyaXN0aWNBcmVhU2l6ZSwgb2Zmc2V0KTtcbiAgICAgIGNvbnN0IGZpcnN0TGluZSA9IHZhbHVlc1N0cmluZy5zcGxpdCgnXFxuJylbMF07XG4gICAgICBjb25zdCBtZXRhZGF0YVNpemUgPSBOdW1iZXIoZmlyc3RMaW5lLnNwbGl0KCc9JylbMV0uc3BsaXQoJyAnKVswXSkgKyBmaXJzdExpbmUubGVuZ3RoO1xuICAgICAgaWYgKG1ldGFkYXRhU2l6ZSA+IGhldXJpc3RpY0FyZWFTaXplKSB7XG4gICAgICAgIHNsaWNlID0gYXdhaXQgdGhpcy5nZXRTbGljZShvZmZzZXQsIG1ldGFkYXRhU2l6ZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBmdWxsU3RyaW5nID0gZ2V0VmFsdWVzKHNsaWNlLCBmaWVsZFR5cGVzLkFTQ0lJLCBtZXRhZGF0YVNpemUsIG9mZnNldCk7XG4gICAgICB0aGlzLmdob3N0VmFsdWVzID0ge307XG4gICAgICBmdWxsU3RyaW5nXG4gICAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgICAgLmZpbHRlcigobGluZSkgPT4gbGluZS5sZW5ndGggPiAwKVxuICAgICAgICAubWFwKChsaW5lKSA9PiBsaW5lLnNwbGl0KCc9JykpXG4gICAgICAgIC5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICB0aGlzLmdob3N0VmFsdWVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdob3N0VmFsdWVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgKEdlbylUSUZGIGZpbGUgZnJvbSB0aGUgZ2l2ZW4gc291cmNlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHNvdXJjZSBUaGUgc291cmNlIG9mIGRhdGEgdG8gcGFyc2UgZnJvbS5cbiAgICogQHBhcmFtIHtHZW9USUZGT3B0aW9uc30gW29wdGlvbnNdIEFkZGl0aW9uYWwgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW3NpZ25hbF0gQW4gQWJvcnRTaWduYWwgdGhhdCBtYXkgYmUgc2lnbmFsbGVkIGlmIHRoZSByZXF1ZXN0IGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGJlIGFib3J0ZWRcbiAgICovXG4gIHN0YXRpYyBhc3luYyBmcm9tU291cmNlKHNvdXJjZSwgb3B0aW9ucywgc2lnbmFsKSB7XG4gICAgY29uc3QgaGVhZGVyRGF0YSA9IChhd2FpdCBzb3VyY2UuZmV0Y2goW3sgb2Zmc2V0OiAwLCBsZW5ndGg6IDEwMjQgfV0sIHNpZ25hbCkpWzBdO1xuICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3NjQoaGVhZGVyRGF0YSk7XG5cbiAgICBjb25zdCBCT00gPSBkYXRhVmlldy5nZXRVaW50MTYoMCwgMCk7XG4gICAgbGV0IGxpdHRsZUVuZGlhbjtcbiAgICBpZiAoQk9NID09PSAweDQ5NDkpIHtcbiAgICAgIGxpdHRsZUVuZGlhbiA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChCT00gPT09IDB4NEQ0RCkge1xuICAgICAgbGl0dGxlRW5kaWFuID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYnl0ZSBvcmRlciB2YWx1ZS4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBtYWdpY051bWJlciA9IGRhdGFWaWV3LmdldFVpbnQxNigyLCBsaXR0bGVFbmRpYW4pO1xuICAgIGxldCBiaWdUaWZmO1xuICAgIGlmIChtYWdpY051bWJlciA9PT0gNDIpIHtcbiAgICAgIGJpZ1RpZmYgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKG1hZ2ljTnVtYmVyID09PSA0Mykge1xuICAgICAgYmlnVGlmZiA9IHRydWU7XG4gICAgICBjb25zdCBvZmZzZXRCeXRlU2l6ZSA9IGRhdGFWaWV3LmdldFVpbnQxNig0LCBsaXR0bGVFbmRpYW4pO1xuICAgICAgaWYgKG9mZnNldEJ5dGVTaXplICE9PSA4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgb2Zmc2V0IGJ5dGUtc2l6ZS4nKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtYWdpYyBudW1iZXIuJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZmlyc3RJRkRPZmZzZXQgPSBiaWdUaWZmXG4gICAgICA/IGRhdGFWaWV3LmdldFVpbnQ2NCg4LCBsaXR0bGVFbmRpYW4pXG4gICAgICA6IGRhdGFWaWV3LmdldFVpbnQzMig0LCBsaXR0bGVFbmRpYW4pO1xuICAgIHJldHVybiBuZXcgR2VvVElGRihzb3VyY2UsIGxpdHRsZUVuZGlhbiwgYmlnVGlmZiwgZmlyc3RJRkRPZmZzZXQsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyB0aGUgdW5kZXJseWluZyBmaWxlIGJ1ZmZlclxuICAgKiBOLkIuIEFmdGVyIHRoZSBHZW9USUZGIGhhcyBiZWVuIGNvbXBsZXRlbHkgcHJvY2Vzc2VkIGl0IG5lZWRzXG4gICAqIHRvIGJlIGNsb3NlZCBidXQgb25seSBpZiBpdCBoYXMgYmVlbiBjb25zdHJ1Y3RlZCBmcm9tIGEgZmlsZS5cbiAgICovXG4gIGNsb3NlKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5zb3VyY2UuY2xvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5jbG9zZSgpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IHsgR2VvVElGRiB9O1xuZXhwb3J0IGRlZmF1bHQgR2VvVElGRjtcblxuLyoqXG4gKiBXcmFwcGVyIGZvciBHZW9USUZGIGZpbGVzIHRoYXQgaGF2ZSBleHRlcm5hbCBvdmVydmlld3MuXG4gKiBAYXVnbWVudHMgR2VvVElGRkJhc2VcbiAqL1xuY2xhc3MgTXVsdGlHZW9USUZGIGV4dGVuZHMgR2VvVElGRkJhc2Uge1xuICAvKipcbiAgICogQ29uc3RydWN0IGEgbmV3IE11bHRpR2VvVElGRiBmcm9tIGEgbWFpbiBhbmQgc2V2ZXJhbCBvdmVydmlldyBmaWxlcy5cbiAgICogQHBhcmFtIHtHZW9USUZGfSBtYWluRmlsZSBUaGUgbWFpbiBHZW9USUZGIGZpbGUuXG4gICAqIEBwYXJhbSB7R2VvVElGRltdfSBvdmVydmlld0ZpbGVzIEFuIGFycmF5IG9mIG92ZXJ2aWV3IGZpbGVzLlxuICAgKi9cbiAgY29uc3RydWN0b3IobWFpbkZpbGUsIG92ZXJ2aWV3RmlsZXMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubWFpbkZpbGUgPSBtYWluRmlsZTtcbiAgICB0aGlzLm92ZXJ2aWV3RmlsZXMgPSBvdmVydmlld0ZpbGVzO1xuICAgIHRoaXMuaW1hZ2VGaWxlcyA9IFttYWluRmlsZV0uY29uY2F0KG92ZXJ2aWV3RmlsZXMpO1xuXG4gICAgdGhpcy5maWxlRGlyZWN0b3JpZXNQZXJGaWxlID0gbnVsbDtcbiAgICB0aGlzLmZpbGVEaXJlY3Rvcmllc1BlckZpbGVQYXJzaW5nID0gbnVsbDtcbiAgICB0aGlzLmltYWdlQ291bnQgPSBudWxsO1xuICB9XG5cbiAgYXN5bmMgcGFyc2VGaWxlRGlyZWN0b3JpZXNQZXJGaWxlKCkge1xuICAgIGNvbnN0IHJlcXVlc3RzID0gW3RoaXMubWFpbkZpbGUucGFyc2VGaWxlRGlyZWN0b3J5QXQodGhpcy5tYWluRmlsZS5maXJzdElGRE9mZnNldCldXG4gICAgICAuY29uY2F0KHRoaXMub3ZlcnZpZXdGaWxlcy5tYXAoKGZpbGUpID0+IGZpbGUucGFyc2VGaWxlRGlyZWN0b3J5QXQoZmlsZS5maXJzdElGRE9mZnNldCkpKTtcblxuICAgIHRoaXMuZmlsZURpcmVjdG9yaWVzUGVyRmlsZSA9IGF3YWl0IFByb21pc2UuYWxsKHJlcXVlc3RzKTtcbiAgICByZXR1cm4gdGhpcy5maWxlRGlyZWN0b3JpZXNQZXJGaWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbi10aCBpbnRlcm5hbCBzdWJmaWxlIG9mIGFuIGltYWdlLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgaXMgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXg9MF0gdGhlIGluZGV4IG9mIHRoZSBpbWFnZSB0byByZXR1cm4uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEdlb1RJRkZJbWFnZT59IHRoZSBpbWFnZSBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICovXG4gIGFzeW5jIGdldEltYWdlKGluZGV4ID0gMCkge1xuICAgIGF3YWl0IHRoaXMuZ2V0SW1hZ2VDb3VudCgpO1xuICAgIGF3YWl0IHRoaXMucGFyc2VGaWxlRGlyZWN0b3JpZXNQZXJGaWxlKCk7XG4gICAgbGV0IHZpc2l0ZWQgPSAwO1xuICAgIGxldCByZWxhdGl2ZUluZGV4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW1hZ2VGaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaW1hZ2VGaWxlID0gdGhpcy5pbWFnZUZpbGVzW2ldO1xuICAgICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IHRoaXMuaW1hZ2VDb3VudHNbaV07IGlpKyspIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSB2aXNpdGVkKSB7XG4gICAgICAgICAgY29uc3QgaWZkID0gYXdhaXQgaW1hZ2VGaWxlLnJlcXVlc3RJRkQocmVsYXRpdmVJbmRleCk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBHZW9USUZGSW1hZ2UoXG4gICAgICAgICAgICBpZmQuZmlsZURpcmVjdG9yeSwgaWZkLmdlb0tleURpcmVjdG9yeSxcbiAgICAgICAgICAgIGltYWdlRmlsZS5kYXRhVmlldywgaW1hZ2VGaWxlLmxpdHRsZUVuZGlhbiwgaW1hZ2VGaWxlLmNhY2hlLCBpbWFnZUZpbGUuc291cmNlLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmlzaXRlZCsrO1xuICAgICAgICByZWxhdGl2ZUluZGV4Kys7XG4gICAgICB9XG4gICAgICByZWxhdGl2ZUluZGV4ID0gMDtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBpbWFnZSBpbmRleCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvdW50IG9mIHRoZSBpbnRlcm5hbCBzdWJmaWxlcy5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyPn0gdGhlIG51bWJlciBvZiBpbnRlcm5hbCBzdWJmaWxlIGltYWdlc1xuICAgKi9cbiAgYXN5bmMgZ2V0SW1hZ2VDb3VudCgpIHtcbiAgICBpZiAodGhpcy5pbWFnZUNvdW50ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbWFnZUNvdW50O1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0cyA9IFt0aGlzLm1haW5GaWxlLmdldEltYWdlQ291bnQoKV1cbiAgICAgIC5jb25jYXQodGhpcy5vdmVydmlld0ZpbGVzLm1hcCgoZmlsZSkgPT4gZmlsZS5nZXRJbWFnZUNvdW50KCkpKTtcbiAgICB0aGlzLmltYWdlQ291bnRzID0gYXdhaXQgUHJvbWlzZS5hbGwocmVxdWVzdHMpO1xuICAgIHRoaXMuaW1hZ2VDb3VudCA9IHRoaXMuaW1hZ2VDb3VudHMucmVkdWNlKChjb3VudCwgaWZkcykgPT4gY291bnQgKyBpZmRzLCAwKTtcbiAgICByZXR1cm4gdGhpcy5pbWFnZUNvdW50O1xuICB9XG59XG5cbmV4cG9ydCB7IE11bHRpR2VvVElGRiB9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgR2VvVElGRiBmcm9tIGEgcmVtb3RlIFVSTC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byBhY2Nlc3MgdGhlIGltYWdlIGZyb21cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIHNvdXJjZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIHtAbGluayBtYWtlUmVtb3RlU291cmNlfSBmb3IgZGV0YWlscy5cbiAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IFtzaWduYWxdIEFuIEFib3J0U2lnbmFsIHRoYXQgbWF5IGJlIHNpZ25hbGxlZCBpZiB0aGUgcmVxdWVzdCBpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYmUgYWJvcnRlZFxuICogQHJldHVybnMge1Byb21pc2U8R2VvVElGRj59IFRoZSByZXN1bHRpbmcgR2VvVElGRiBmaWxlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZnJvbVVybCh1cmwsIG9wdGlvbnMgPSB7fSwgc2lnbmFsKSB7XG4gIHJldHVybiBHZW9USUZGLmZyb21Tb3VyY2UobWFrZVJlbW90ZVNvdXJjZSh1cmwsIG9wdGlvbnMpLCBzaWduYWwpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgR2VvVElGRiBmcm9tIGEgY3VzdG9tIHtAbGluayBCYXNlQ2xpZW50fS5cbiAqIEBwYXJhbSB7QmFzZUNsaWVudH0gY2xpZW50IFRoZSBjbGllbnQuXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBzb3VyY2UuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSB7QGxpbmsgbWFrZVJlbW90ZVNvdXJjZX0gZm9yIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Fib3J0U2lnbmFsfSBbc2lnbmFsXSBBbiBBYm9ydFNpZ25hbCB0aGF0IG1heSBiZSBzaWduYWxsZWQgaWYgdGhlIHJlcXVlc3QgaXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGJlIGFib3J0ZWRcbiAqIEByZXR1cm5zIHtQcm9taXNlPEdlb1RJRkY+fSBUaGUgcmVzdWx0aW5nIEdlb1RJRkYgZmlsZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZyb21DdXN0b21DbGllbnQoY2xpZW50LCBvcHRpb25zID0ge30sIHNpZ25hbCkge1xuICByZXR1cm4gR2VvVElGRi5mcm9tU291cmNlKG1ha2VDdXN0b21Tb3VyY2UoY2xpZW50LCBvcHRpb25zKSwgc2lnbmFsKTtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3QgYSBuZXcgR2VvVElGRiBmcm9tIGFuXG4gKiBbQXJyYXlCdWZmZXJde0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5QnVmZmVyfS5cbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBkYXRhIHRvIHJlYWQgdGhlIGZpbGUgZnJvbS5cbiAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IFtzaWduYWxdIEFuIEFib3J0U2lnbmFsIHRoYXQgbWF5IGJlIHNpZ25hbGxlZCBpZiB0aGUgcmVxdWVzdCBpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYmUgYWJvcnRlZFxuICogQHJldHVybnMge1Byb21pc2U8R2VvVElGRj59IFRoZSByZXN1bHRpbmcgR2VvVElGRiBmaWxlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyKGFycmF5QnVmZmVyLCBzaWduYWwpIHtcbiAgcmV0dXJuIEdlb1RJRkYuZnJvbVNvdXJjZShtYWtlQnVmZmVyU291cmNlKGFycmF5QnVmZmVyKSwgc2lnbmFsKTtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3QgYSBHZW9USUZGIGZyb20gYSBsb2NhbCBmaWxlIHBhdGguIFRoaXMgdXNlcyB0aGUgbm9kZVxuICogW2ZpbGVzeXN0ZW0gQVBJXXtAbGluayBodHRwczovL25vZGVqcy5vcmcvYXBpL2ZzLmh0bWx9IGFuZCBpc1xuICogbm90IGF2YWlsYWJsZSBvbiBicm93c2Vycy5cbiAqXG4gKiBOLkIuIEFmdGVyIHRoZSBHZW9USUZGIGhhcyBiZWVuIGNvbXBsZXRlbHkgcHJvY2Vzc2VkIGl0IG5lZWRzXG4gKiB0byBiZSBjbG9zZWQgYnV0IG9ubHkgaWYgaXQgaGFzIGJlZW4gY29uc3RydWN0ZWQgZnJvbSBhIGZpbGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgZmlsZSBwYXRoIHRvIHJlYWQgZnJvbS5cbiAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IFtzaWduYWxdIEFuIEFib3J0U2lnbmFsIHRoYXQgbWF5IGJlIHNpZ25hbGxlZCBpZiB0aGUgcmVxdWVzdCBpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYmUgYWJvcnRlZFxuICogQHJldHVybnMge1Byb21pc2U8R2VvVElGRj59IFRoZSByZXN1bHRpbmcgR2VvVElGRiBmaWxlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZnJvbUZpbGUocGF0aCwgc2lnbmFsKSB7XG4gIHJldHVybiBHZW9USUZGLmZyb21Tb3VyY2UobWFrZUZpbGVTb3VyY2UocGF0aCksIHNpZ25hbCk7XG59XG5cbi8qKlxuICogQ29uc3RydWN0IGEgR2VvVElGRiBmcm9tIGFuIEhUTUxcbiAqIFtCbG9iXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQmxvYn0gb3JcbiAqIFtGaWxlXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmlsZX1cbiAqIG9iamVjdC5cbiAqIEBwYXJhbSB7QmxvYnxGaWxlfSBibG9iIFRoZSBCbG9iIG9yIEZpbGUgb2JqZWN0IHRvIHJlYWQgZnJvbS5cbiAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IFtzaWduYWxdIEFuIEFib3J0U2lnbmFsIHRoYXQgbWF5IGJlIHNpZ25hbGxlZCBpZiB0aGUgcmVxdWVzdCBpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYmUgYWJvcnRlZFxuICogQHJldHVybnMge1Byb21pc2U8R2VvVElGRj59IFRoZSByZXN1bHRpbmcgR2VvVElGRiBmaWxlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZnJvbUJsb2IoYmxvYiwgc2lnbmFsKSB7XG4gIHJldHVybiBHZW9USUZGLmZyb21Tb3VyY2UobWFrZUZpbGVSZWFkZXJTb3VyY2UoYmxvYiksIHNpZ25hbCk7XG59XG5cbi8qKlxuICogQ29uc3RydWN0IGEgTXVsdGlHZW9USUZGIGZyb20gdGhlIGdpdmVuIFVSTHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFpblVybCBUaGUgVVJMIGZvciB0aGUgbWFpbiBmaWxlLlxuICogQHBhcmFtIHtzdHJpbmdbXX0gb3ZlcnZpZXdVcmxzIEFuIGFycmF5IG9mIFVSTHMgZm9yIHRoZSBvdmVydmlldyBpbWFnZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFkZGl0aW9uYWwgb3B0aW9ucyB0byBwYXNzIHRvIHRoZSBzb3VyY2UuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSBbbWFrZVJlbW90ZVNvdXJjZV17QGxpbmsgbW9kdWxlOnNvdXJjZS5tYWtlUmVtb3RlU291cmNlfVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgZGV0YWlscy5cbiAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IFtzaWduYWxdIEFuIEFib3J0U2lnbmFsIHRoYXQgbWF5IGJlIHNpZ25hbGxlZCBpZiB0aGUgcmVxdWVzdCBpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYmUgYWJvcnRlZFxuICogQHJldHVybnMge1Byb21pc2U8TXVsdGlHZW9USUZGPn0gVGhlIHJlc3VsdGluZyBNdWx0aUdlb1RJRkYgZmlsZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZyb21VcmxzKG1haW5VcmwsIG92ZXJ2aWV3VXJscyA9IFtdLCBvcHRpb25zID0ge30sIHNpZ25hbCkge1xuICBjb25zdCBtYWluRmlsZSA9IGF3YWl0IEdlb1RJRkYuZnJvbVNvdXJjZShtYWtlUmVtb3RlU291cmNlKG1haW5VcmwsIG9wdGlvbnMpLCBzaWduYWwpO1xuICBjb25zdCBvdmVydmlld0ZpbGVzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgb3ZlcnZpZXdVcmxzLm1hcCgodXJsKSA9PiBHZW9USUZGLmZyb21Tb3VyY2UobWFrZVJlbW90ZVNvdXJjZSh1cmwsIG9wdGlvbnMpKSksXG4gICk7XG5cbiAgcmV0dXJuIG5ldyBNdWx0aUdlb1RJRkYobWFpbkZpbGUsIG92ZXJ2aWV3RmlsZXMpO1xufVxuXG4vKipcbiAqIE1haW4gY3JlYXRpbmcgZnVuY3Rpb24gZm9yIEdlb1RJRkYgZmlsZXMuXG4gKiBAcGFyYW0geyhBcnJheSl9IGFycmF5IG9mIHBpeGVsIHZhbHVlc1xuICogQHJldHVybnMge21ldGFkYXRhfSBtZXRhZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JpdGVBcnJheUJ1ZmZlcih2YWx1ZXMsIG1ldGFkYXRhKSB7XG4gIHJldHVybiB3cml0ZUdlb3RpZmYodmFsdWVzLCBtZXRhZGF0YSk7XG59XG5cbmV4cG9ydCB7IFBvb2wgfTtcbmV4cG9ydCB7IEdlb1RJRkZJbWFnZSB9O1xuZXhwb3J0IHsgQmFzZUNsaWVudCwgQmFzZVJlc3BvbnNlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/geotiff.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/geotiffimage.js":
/*!**********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/geotiffimage.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _petamoriken_float16__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @petamoriken/float16 */ \"./node_modules/@petamoriken/float16/src/DataView.mjs\");\n/* harmony import */ var xml_utils_get_attribute_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xml-utils/get-attribute.js */ \"./node_modules/xml-utils/get-attribute.js\");\n/* harmony import */ var xml_utils_find_tags_by_name_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! xml-utils/find-tags-by-name.js */ \"./node_modules/xml-utils/find-tags-by-name.js\");\n/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./globals.js */ \"./node_modules/geotiff/dist-module/globals.js\");\n/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rgb.js */ \"./node_modules/geotiff/dist-module/rgb.js\");\n/* harmony import */ var _compression_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./compression/index.js */ \"./node_modules/geotiff/dist-module/compression/index.js\");\n/* harmony import */ var _resample_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resample.js */ \"./node_modules/geotiff/dist-module/resample.js\");\n/** @module geotiffimage */\n\n\n\n\n\n\n\n\n\n/**\n * @typedef {Object} ReadRasterOptions\n * @property {Array<number>} [window=whole window] the subset to read data from in pixels.\n * @property {Array<number>} [bbox=whole image] the subset to read data from in\n *                                           geographical coordinates.\n * @property {Array<number>} [samples=all samples] the selection of samples to read from. Default is all samples.\n * @property {boolean} [interleave=false] whether the data shall be read\n *                                             in one single array or separate\n *                                             arrays.\n * @property {Pool} [pool=null] The optional decoder pool to use.\n * @property {number} [width] The desired width of the output. When the width is not the\n *                                 same as the images, resampling will be performed.\n * @property {number} [height] The desired height of the output. When the width is not the\n *                                  same as the images, resampling will be performed.\n * @property {string} [resampleMethod='nearest'] The desired resampling method.\n * @property {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                                       to be aborted\n * @property {number|number[]} [fillValue] The value to use for parts of the image\n *                                              outside of the images extent. When multiple\n *                                              samples are requested, an array of fill values\n *                                              can be passed.\n */\n\n/** @typedef {import(\"./geotiff.js\").TypedArray} TypedArray */\n/** @typedef {import(\"./geotiff.js\").ReadRasterResult} ReadRasterResult */\n\nfunction sum(array, start, end) {\n  let s = 0;\n  for (let i = start; i < end; ++i) {\n    s += array[i];\n  }\n  return s;\n}\n\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1: // unsigned integer data\n      if (bitsPerSample <= 8) {\n        return new Uint8Array(size);\n      } else if (bitsPerSample <= 16) {\n        return new Uint16Array(size);\n      } else if (bitsPerSample <= 32) {\n        return new Uint32Array(size);\n      }\n      break;\n    case 2: // twos complement signed integer data\n      if (bitsPerSample === 8) {\n        return new Int8Array(size);\n      } else if (bitsPerSample === 16) {\n        return new Int16Array(size);\n      } else if (bitsPerSample === 32) {\n        return new Int32Array(size);\n      }\n      break;\n    case 3: // floating point data\n      switch (bitsPerSample) {\n        case 16:\n        case 32:\n          return new Float32Array(size);\n        case 64:\n          return new Float64Array(size);\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n  throw Error('Unsupported data format/bitsPerSample');\n}\n\nfunction needsNormalization(format, bitsPerSample) {\n  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {\n    return false;\n  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {\n    return false;\n  }\n  return true;\n}\n\nfunction normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {\n  // const inByteArray = new Uint8Array(inBuffer);\n  const view = new DataView(inBuffer);\n  const outSize = planarConfiguration === 2\n    ? tileHeight * tileWidth\n    : tileHeight * tileWidth * samplesPerPixel;\n  const samplesToTransfer = planarConfiguration === 2\n    ? 1 : samplesPerPixel;\n  const outArray = arrayForType(format, bitsPerSample, outSize);\n  // let pixel = 0;\n\n  const bitMask = parseInt('1'.repeat(bitsPerSample), 2);\n\n  if (format === 1) { // unsigned integer\n    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337\n    let pixelBitSkip;\n    // let sampleBitOffset = 0;\n    if (planarConfiguration === 1) {\n      pixelBitSkip = samplesPerPixel * bitsPerSample;\n      // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;\n    } else {\n      pixelBitSkip = bitsPerSample;\n    }\n\n    // Bits per line rounds up to next byte boundary.\n    let bitsPerLine = tileWidth * pixelBitSkip;\n    if ((bitsPerLine & 7) !== 0) {\n      bitsPerLine = (bitsPerLine + 7) & (~7);\n    }\n\n    for (let y = 0; y < tileHeight; ++y) {\n      const lineBitOffset = y * bitsPerLine;\n      for (let x = 0; x < tileWidth; ++x) {\n        const pixelBitOffset = lineBitOffset + (x * samplesToTransfer * bitsPerSample);\n        for (let i = 0; i < samplesToTransfer; ++i) {\n          const bitOffset = pixelBitOffset + (i * bitsPerSample);\n          const outIndex = (((y * tileWidth) + x) * samplesToTransfer) + i;\n\n          const byteOffset = Math.floor(bitOffset / 8);\n          const innerBitOffset = bitOffset % 8;\n          if (innerBitOffset + bitsPerSample <= 8) {\n            outArray[outIndex] = (view.getUint8(byteOffset) >> (8 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 16) {\n            outArray[outIndex] = (view.getUint16(byteOffset) >> (16 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 24) {\n            const raw = (view.getUint16(byteOffset) << 8) | (view.getUint8(byteOffset + 2));\n            outArray[outIndex] = (raw >> (24 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else {\n            outArray[outIndex] = (view.getUint32(byteOffset) >> (32 - bitsPerSample) - innerBitOffset) & bitMask;\n          }\n\n          // let outWord = 0;\n          // for (let bit = 0; bit < bitsPerSample; ++bit) {\n          //   if (inByteArray[bitOffset >> 3]\n          //     & (0x80 >> (bitOffset & 7))) {\n          //     outWord |= (1 << (bitsPerSample - 1 - bit));\n          //   }\n          //   ++bitOffset;\n          // }\n\n          // outArray[outIndex] = outWord;\n          // outArray[pixel] = outWord;\n          // pixel += 1;\n        }\n        // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;\n      }\n    }\n  } else if (format === 3) { // floating point\n    // Float16 is handled elsewhere\n    // normalize 16/24 bit floats to 32 bit floats in the array\n    // console.time();\n    // if (bitsPerSample === 16) {\n    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {\n    //     outArray[outIndex] = getFloat16(view, byte);\n    //   }\n    // }\n    // console.timeEnd()\n  }\n\n  return outArray.buffer;\n}\n\n/**\n * GeoTIFF sub-file image.\n */\nclass GeoTIFFImage {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {import('./source/basesource').BaseSource} source The datasource to read from\n   */\n  constructor(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    const planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration = (typeof planarConfiguration === 'undefined') ? 1 : planarConfiguration;\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error('Invalid planar configuration.');\n    }\n\n    this.source = source;\n  }\n\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n  getFileDirectory() {\n    return this.fileDirectory;\n  }\n\n  /**\n   * Returns the associated parsed geo keys.\n   * @returns {Object} the parsed geo keys\n   */\n  getGeoKeys() {\n    return this.geoKeys;\n  }\n\n  /**\n   * Returns the width of the image.\n   * @returns {Number} the width of the image\n   */\n  getWidth() {\n    return this.fileDirectory.ImageWidth;\n  }\n\n  /**\n   * Returns the height of the image.\n   * @returns {Number} the height of the image\n   */\n  getHeight() {\n    return this.fileDirectory.ImageLength;\n  }\n\n  /**\n   * Returns the number of samples per pixel.\n   * @returns {Number} the number of samples per pixel\n   */\n  getSamplesPerPixel() {\n    return typeof this.fileDirectory.SamplesPerPixel !== 'undefined'\n      ? this.fileDirectory.SamplesPerPixel : 1;\n  }\n\n  /**\n   * Returns the width of each tile.\n   * @returns {Number} the width of each tile\n   */\n  getTileWidth() {\n    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n  }\n\n  /**\n   * Returns the height of each tile.\n   * @returns {Number} the height of each tile\n   */\n  getTileHeight() {\n    if (this.isTiled) {\n      return this.fileDirectory.TileLength;\n    }\n    if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {\n      return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n    }\n    return this.getHeight();\n  }\n\n  getBlockWidth() {\n    return this.getTileWidth();\n  }\n\n  getBlockHeight(y) {\n    if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {\n      return this.getTileHeight();\n    } else {\n      return this.getHeight() - (y * this.getTileHeight());\n    }\n  }\n\n  /**\n   * Calculates the number of bytes for each pixel across all samples. Only full\n   * bytes are supported, an exception is thrown when this is not the case.\n   * @returns {Number} the bytes per pixel\n   */\n  getBytesPerPixel() {\n    let bytes = 0;\n    for (let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n      bytes += this.getSampleByteSize(i);\n    }\n    return bytes;\n  }\n\n  getSampleByteSize(i) {\n    if (i >= this.fileDirectory.BitsPerSample.length) {\n      throw new RangeError(`Sample index ${i} is out of range.`);\n    }\n    return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);\n  }\n\n  getReaderForSample(sampleIndex) {\n    const format = this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n    switch (format) {\n      case 1: // unsigned integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getUint8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getUint16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getUint32;\n        }\n        break;\n      case 2: // twos complement signed integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getInt8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getInt16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getInt32;\n        }\n        break;\n      case 3:\n        switch (bitsPerSample) {\n          case 16:\n            return function (offset, littleEndian) {\n              return (0,_petamoriken_float16__WEBPACK_IMPORTED_MODULE_2__.getFloat16)(this, offset, littleEndian);\n            };\n          case 32:\n            return DataView.prototype.getFloat32;\n          case 64:\n            return DataView.prototype.getFloat64;\n          default:\n            break;\n        }\n        break;\n      default:\n        break;\n    }\n    throw Error('Unsupported data format/bitsPerSample');\n  }\n\n  getSampleFormat(sampleIndex = 0) {\n    return this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n  }\n\n  getBitsPerSample(sampleIndex = 0) {\n    return this.fileDirectory.BitsPerSample[sampleIndex];\n  }\n\n  getArrayForSample(sampleIndex, size) {\n    const format = this.getSampleFormat(sampleIndex);\n    const bitsPerSample = this.getBitsPerSample(sampleIndex);\n    return arrayForType(format, bitsPerSample, size);\n  }\n\n  /**\n   * Returns the decoded strip or tile.\n   * @param {Number} x the strip or tile x-offset\n   * @param {Number} y the tile y-offset (0 for stripped images)\n   * @param {Number} sample the sample to get for separated samples\n   * @param {import(\"./geotiff\").Pool|import(\"./geotiff\").BaseDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise.<ArrayBuffer>}\n   */\n  async getTileOrStrip(x, y, sample, poolOrDecoder, signal) {\n    const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());\n    const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());\n    let index;\n    const { tiles } = this;\n    if (this.planarConfiguration === 1) {\n      index = (y * numTilesPerRow) + x;\n    } else if (this.planarConfiguration === 2) {\n      index = (sample * numTilesPerRow * numTilesPerCol) + (y * numTilesPerRow) + x;\n    }\n\n    let offset;\n    let byteCount;\n    if (this.isTiled) {\n      offset = this.fileDirectory.TileOffsets[index];\n      byteCount = this.fileDirectory.TileByteCounts[index];\n    } else {\n      offset = this.fileDirectory.StripOffsets[index];\n      byteCount = this.fileDirectory.StripByteCounts[index];\n    }\n    const slice = (await this.source.fetch([{ offset, length: byteCount }], signal))[0];\n\n    let request;\n    if (tiles === null || !tiles[index]) {\n    // resolve each request by potentially applying array normalization\n      request = (async () => {\n        let data = await poolOrDecoder.decode(this.fileDirectory, slice);\n        const sampleFormat = this.getSampleFormat();\n        const bitsPerSample = this.getBitsPerSample();\n        if (needsNormalization(sampleFormat, bitsPerSample)) {\n          data = normalizeArray(\n            data,\n            sampleFormat,\n            this.planarConfiguration,\n            this.getSamplesPerPixel(),\n            bitsPerSample,\n            this.getTileWidth(),\n            this.getBlockHeight(y),\n          );\n        }\n        return data;\n      })();\n\n      // set the cache\n      if (tiles !== null) {\n        tiles[index] = request;\n      }\n    } else {\n      // get from the cache\n      request = tiles[index];\n    }\n\n    // cache the tile request\n    return { x, y, sample, data: await request };\n  }\n\n  /**\n   * Internal read function.\n   * @private\n   * @param {Array} imageWindow The image window in pixel coordinates\n   * @param {Array} samples The selected samples (0-based indices)\n   * @param {TypedArray|TypedArray[]} valueArrays The array(s) to write into\n   * @param {Boolean} interleave Whether or not to write in an interleaved manner\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {number} width the width of window to be read into\n   * @param {number} height the height of window to be read into\n   * @param {number} resampleMethod the resampling method to be used when interpolating\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise<ReadRasterResult>}\n   */\n  async _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width,\n    height, resampleMethod, signal) {\n    const tileWidth = this.getTileWidth();\n    const tileHeight = this.getTileHeight();\n    const imageWidth = this.getWidth();\n    const imageHeight = this.getHeight();\n\n    const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n    const maxXTile = Math.min(\n      Math.ceil(imageWindow[2] / tileWidth),\n      Math.ceil(imageWidth / tileWidth),\n    );\n    const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n    const maxYTile = Math.min(\n      Math.ceil(imageWindow[3] / tileHeight),\n      Math.ceil(imageHeight / tileHeight),\n    );\n    const windowWidth = imageWindow[2] - imageWindow[0];\n\n    let bytesPerPixel = this.getBytesPerPixel();\n\n    const srcSampleOffsets = [];\n    const sampleReaders = [];\n    for (let i = 0; i < samples.length; ++i) {\n      if (this.planarConfiguration === 1) {\n        srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);\n      } else {\n        srcSampleOffsets.push(0);\n      }\n      sampleReaders.push(this.getReaderForSample(samples[i]));\n    }\n\n    const promises = [];\n    const { littleEndian } = this;\n\n    for (let yTile = minYTile; yTile < maxYTile; ++yTile) {\n      for (let xTile = minXTile; xTile < maxXTile; ++xTile) {\n        let getPromise;\n        if (this.planarConfiguration === 1) {\n          getPromise = this.getTileOrStrip(xTile, yTile, 0, poolOrDecoder, signal);\n        }\n        for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {\n          const si = sampleIndex;\n          const sample = samples[sampleIndex];\n          if (this.planarConfiguration === 2) {\n            bytesPerPixel = this.getSampleByteSize(sample);\n            getPromise = this.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal);\n          }\n          const promise = getPromise.then((tile) => {\n            const buffer = tile.data;\n            const dataView = new DataView(buffer);\n            const blockHeight = this.getBlockHeight(tile.y);\n            const firstLine = tile.y * tileHeight;\n            const firstCol = tile.x * tileWidth;\n            const lastLine = firstLine + blockHeight;\n            const lastCol = (tile.x + 1) * tileWidth;\n            const reader = sampleReaders[si];\n\n            const ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);\n            const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);\n\n            for (let y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {\n              for (let x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {\n                const pixelOffset = ((y * tileWidth) + x) * bytesPerPixel;\n                const value = reader.call(\n                  dataView, pixelOffset + srcSampleOffsets[si], littleEndian,\n                );\n                let windowCoordinate;\n                if (interleave) {\n                  windowCoordinate = ((y + firstLine - imageWindow[1]) * windowWidth * samples.length)\n                    + ((x + firstCol - imageWindow[0]) * samples.length)\n                    + si;\n                  valueArrays[windowCoordinate] = value;\n                } else {\n                  windowCoordinate = (\n                    (y + firstLine - imageWindow[1]) * windowWidth\n                  ) + x + firstCol - imageWindow[0];\n                  valueArrays[si][windowCoordinate] = value;\n                }\n              }\n            }\n          });\n          promises.push(promise);\n        }\n      }\n    }\n    await Promise.all(promises);\n\n    if ((width && (imageWindow[2] - imageWindow[0]) !== width)\n        || (height && (imageWindow[3] - imageWindow[1]) !== height)) {\n      let resampled;\n      if (interleave) {\n        resampled = (0,_resample_js__WEBPACK_IMPORTED_MODULE_3__.resampleInterleaved)(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          samples.length,\n          resampleMethod,\n        );\n      } else {\n        resampled = (0,_resample_js__WEBPACK_IMPORTED_MODULE_3__.resample)(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          resampleMethod,\n        );\n      }\n      resampled.width = width;\n      resampled.height = height;\n      return resampled;\n    }\n\n    valueArrays.width = width || imageWindow[2] - imageWindow[0];\n    valueArrays.height = height || imageWindow[3] - imageWindow[1];\n\n    return valueArrays;\n  }\n\n  /**\n   * Reads raster data from the image. This function reads all selected samples\n   * into separate arrays of the correct type for that sample or into a single\n   * combined array when `interleave` is set. When provided, only a subset\n   * of the raster is read for each sample.\n   *\n   * @param {ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded arrays as a promise\n   */\n  async readRasters({\n    window: wnd, samples = [], interleave, pool = null,\n    width, height, resampleMethod, fillValue, signal,\n  } = {}) {\n    const imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const imageWindowWidth = imageWindow[2] - imageWindow[0];\n    const imageWindowHeight = imageWindow[3] - imageWindow[1];\n    const numPixels = imageWindowWidth * imageWindowHeight;\n    const samplesPerPixel = this.getSamplesPerPixel();\n\n    if (!samples || !samples.length) {\n      for (let i = 0; i < samplesPerPixel; ++i) {\n        samples.push(i);\n      }\n    } else {\n      for (let i = 0; i < samples.length; ++i) {\n        if (samples[i] >= samplesPerPixel) {\n          return Promise.reject(new RangeError(`Invalid sample index '${samples[i]}'.`));\n        }\n      }\n    }\n    let valueArrays;\n    if (interleave) {\n      const format = this.fileDirectory.SampleFormat\n        ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;\n      const bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);\n      valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);\n      if (fillValue) {\n        valueArrays.fill(fillValue);\n      }\n    } else {\n      valueArrays = [];\n      for (let i = 0; i < samples.length; ++i) {\n        const valueArray = this.getArrayForSample(samples[i], numPixels);\n        if (Array.isArray(fillValue) && i < fillValue.length) {\n          valueArray.fill(fillValue[i]);\n        } else if (fillValue && !Array.isArray(fillValue)) {\n          valueArray.fill(fillValue);\n        }\n        valueArrays.push(valueArray);\n      }\n    }\n\n    const poolOrDecoder = pool || await (0,_compression_index_js__WEBPACK_IMPORTED_MODULE_4__.getDecoder)(this.fileDirectory);\n\n    const result = await this._readRaster(\n      imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal,\n    );\n    return result;\n  }\n\n  /**\n   * Reads raster data from the image as RGB. The result is always an\n   * interleaved typed array.\n   * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n   * When no other method is applicable, the first sample is used to produce a\n   * grayscale image.\n   * When provided, only a subset of the raster is read for each sample.\n   *\n   * @param {Object} [options] optional parameters\n   * @param {Array<number>} [options.window] the subset to read data from in pixels.\n   * @param {boolean} [options.interleave=true] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {import(\"./geotiff\").Pool} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is no the\n   *                                 same as the images, resampling will be performed.\n   * @param {number} [options.height] The desired height of the output. When the width is no the\n   *                                  same as the images, resampling will be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {boolean} [options.enableAlpha=false] Enable reading alpha channel if present.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @returns {Promise<ReadRasterResult>} the RGB array as a Promise\n   */\n  async readRGB({ window, interleave = true, pool = null, width, height,\n    resampleMethod, enableAlpha = false, signal } = {}) {\n    const imageWindow = window || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const pi = this.fileDirectory.PhotometricInterpretation;\n\n    if (pi === _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.RGB) {\n      let s = [0, 1, 2];\n      if ((!(this.fileDirectory.ExtraSamples === _globals_js__WEBPACK_IMPORTED_MODULE_5__.ExtraSamplesValues.Unspecified)) && enableAlpha) {\n        s = [];\n        for (let i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {\n          s.push(i);\n        }\n      }\n      return this.readRasters({\n        window,\n        interleave,\n        samples: s,\n        pool,\n        width,\n        height,\n        resampleMethod,\n        signal,\n      });\n    }\n\n    let samples;\n    switch (pi) {\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.WhiteIsZero:\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.BlackIsZero:\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.Palette:\n        samples = [0];\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.CMYK:\n        samples = [0, 1, 2, 3];\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.YCbCr:\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.CIELab:\n        samples = [0, 1, 2];\n        break;\n      default:\n        throw new Error('Invalid or unsupported photometric interpretation.');\n    }\n\n    const subOptions = {\n      window: imageWindow,\n      interleave: true,\n      samples,\n      pool,\n      width,\n      height,\n      resampleMethod,\n      signal,\n    };\n    const { fileDirectory } = this;\n    const raster = await this.readRasters(subOptions);\n\n    const max = 2 ** this.fileDirectory.BitsPerSample[0];\n    let data;\n    switch (pi) {\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.WhiteIsZero:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromWhiteIsZero)(raster, max);\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.BlackIsZero:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromBlackIsZero)(raster, max);\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.Palette:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromPalette)(raster, fileDirectory.ColorMap);\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.CMYK:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromCMYK)(raster);\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.YCbCr:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromYCbCr)(raster);\n        break;\n      case _globals_js__WEBPACK_IMPORTED_MODULE_5__.photometricInterpretations.CIELab:\n        data = (0,_rgb_js__WEBPACK_IMPORTED_MODULE_6__.fromCIELab)(raster);\n        break;\n      default:\n        throw new Error('Unsupported photometric interpretation.');\n    }\n\n    // if non-interleaved data is requested, we must split the channels\n    // into their respective arrays\n    if (!interleave) {\n      const red = new Uint8Array(data.length / 3);\n      const green = new Uint8Array(data.length / 3);\n      const blue = new Uint8Array(data.length / 3);\n      for (let i = 0, j = 0; i < data.length; i += 3, ++j) {\n        red[j] = data[i];\n        green[j] = data[i + 1];\n        blue[j] = data[i + 2];\n      }\n      data = [red, green, blue];\n    }\n\n    data.width = raster.width;\n    data.height = raster.height;\n    return data;\n  }\n\n  /**\n   * Returns an array of tiepoints.\n   * @returns {Object[]}\n   */\n  getTiePoints() {\n    if (!this.fileDirectory.ModelTiepoint) {\n      return [];\n    }\n\n    const tiePoints = [];\n    for (let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n      tiePoints.push({\n        i: this.fileDirectory.ModelTiepoint[i],\n        j: this.fileDirectory.ModelTiepoint[i + 1],\n        k: this.fileDirectory.ModelTiepoint[i + 2],\n        x: this.fileDirectory.ModelTiepoint[i + 3],\n        y: this.fileDirectory.ModelTiepoint[i + 4],\n        z: this.fileDirectory.ModelTiepoint[i + 5],\n      });\n    }\n    return tiePoints;\n  }\n\n  /**\n   * Returns the parsed GDAL metadata items.\n   *\n   * If sample is passed to null, dataset-level metadata will be returned.\n   * Otherwise only metadata specific to the provided sample will be returned.\n   *\n   * @param {number} [sample=null] The sample index.\n   * @returns {Object}\n   */\n  getGDALMetadata(sample = null) {\n    const metadata = {};\n    if (!this.fileDirectory.GDAL_METADATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_METADATA;\n\n    let items = xml_utils_find_tags_by_name_js__WEBPACK_IMPORTED_MODULE_1__(string, 'Item');\n\n    if (sample === null) {\n      items = items.filter((item) => xml_utils_get_attribute_js__WEBPACK_IMPORTED_MODULE_0__(item, 'sample') === undefined);\n    } else {\n      items = items.filter((item) => Number(xml_utils_get_attribute_js__WEBPACK_IMPORTED_MODULE_0__(item, 'sample')) === sample);\n    }\n\n    for (let i = 0; i < items.length; ++i) {\n      const item = items[i];\n      metadata[xml_utils_get_attribute_js__WEBPACK_IMPORTED_MODULE_0__(item, 'name')] = item.inner;\n    }\n    return metadata;\n  }\n\n  /**\n   * Returns the GDAL nodata value\n   * @returns {number|null}\n   */\n  getGDALNoData() {\n    if (!this.fileDirectory.GDAL_NODATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_NODATA;\n    return Number(string.substring(0, string.length - 1));\n  }\n\n  /**\n   * Returns the image origin as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @returns {Array<number>} The origin as a vector\n   */\n  getOrigin() {\n    const tiePoints = this.fileDirectory.ModelTiepoint;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n    if (tiePoints && tiePoints.length === 6) {\n      return [\n        tiePoints[3],\n        tiePoints[4],\n        tiePoints[5],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[3],\n        modelTransformation[7],\n        modelTransformation[11],\n      ];\n    }\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns the image resolution as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n   *                                             in cases when the current image does not have the\n   *                                             required tags on its own.\n   * @returns {Array<number>} The resolution as a vector\n   */\n  getResolution(referenceImage = null) {\n    const modelPixelScale = this.fileDirectory.ModelPixelScale;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n\n    if (modelPixelScale) {\n      return [\n        modelPixelScale[0],\n        -modelPixelScale[1],\n        modelPixelScale[2],\n      ];\n    }\n    if (modelTransformation) {\n      if (modelTransformation[1] === 0 && modelTransformation[4] === 0) {\n        return [\n          modelTransformation[0],\n          -modelTransformation[5],\n          modelTransformation[10],\n        ];\n      }\n      return [\n        Math.sqrt((modelTransformation[0] * modelTransformation[0])\n          + (modelTransformation[4] * modelTransformation[4])),\n        -Math.sqrt((modelTransformation[1] * modelTransformation[1])\n          + (modelTransformation[5] * modelTransformation[5])),\n        modelTransformation[10]];\n    }\n\n    if (referenceImage) {\n      const [refResX, refResY, refResZ] = referenceImage.getResolution();\n      return [\n        refResX * referenceImage.getWidth() / this.getWidth(),\n        refResY * referenceImage.getHeight() / this.getHeight(),\n        refResZ * referenceImage.getWidth() / this.getWidth(),\n      ];\n    }\n\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns whether or not the pixels of the image depict an area (or point).\n   * @returns {Boolean} Whether the pixels are a point\n   */\n  pixelIsArea() {\n    return this.geoKeys.GTRasterTypeGeoKey === 1;\n  }\n\n  /**\n   * Returns the image bounding box as an array of 4 values: min-x, min-y,\n   * max-x and max-y. When the image has no affine transformation, then an\n   * exception is thrown.\n   * @param {boolean} [tilegrid=false] If true return extent for a tilegrid\n   *                                   without adjustment for ModelTransformation.\n   * @returns {Array<number>} The bounding box\n   */\n  getBoundingBox(tilegrid = false) {\n    const height = this.getHeight();\n    const width = this.getWidth();\n\n    if (this.fileDirectory.ModelTransformation && !tilegrid) {\n      // eslint-disable-next-line no-unused-vars\n      const [a, b, c, d, e, f, g, h] = this.fileDirectory.ModelTransformation;\n\n      const corners = [\n        [0, 0],\n        [0, height],\n        [width, 0],\n        [width, height],\n      ];\n\n      const projected = corners.map(([I, J]) => [\n        d + (a * I) + (b * J),\n        h + (e * I) + (f * J),\n      ]);\n\n      const xs = projected.map((pt) => pt[0]);\n      const ys = projected.map((pt) => pt[1]);\n\n      return [\n        Math.min(...xs),\n        Math.min(...ys),\n        Math.max(...xs),\n        Math.max(...ys),\n      ];\n    } else {\n      const origin = this.getOrigin();\n      const resolution = this.getResolution();\n\n      const x1 = origin[0];\n      const y1 = origin[1];\n\n      const x2 = x1 + (resolution[0] * width);\n      const y2 = y1 + (resolution[1] * height);\n\n      return [\n        Math.min(x1, x2),\n        Math.min(y1, y2),\n        Math.max(x1, x2),\n        Math.max(y1, y2),\n      ];\n    }\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GeoTIFFImage);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9nZW90aWZmaW1hZ2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlcnJpYWpzLW1hcC8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2dlb3RpZmZpbWFnZS5qcz80MDliIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbW9kdWxlIGdlb3RpZmZpbWFnZSAqL1xuaW1wb3J0IHsgZ2V0RmxvYXQxNiB9IGZyb20gJ0BwZXRhbW9yaWtlbi9mbG9hdDE2JztcbmltcG9ydCBnZXRBdHRyaWJ1dGUgZnJvbSAneG1sLXV0aWxzL2dldC1hdHRyaWJ1dGUuanMnO1xuaW1wb3J0IGZpbmRUYWdzQnlOYW1lIGZyb20gJ3htbC11dGlscy9maW5kLXRhZ3MtYnktbmFtZS5qcyc7XG5cbmltcG9ydCB7IHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb25zLCBFeHRyYVNhbXBsZXNWYWx1ZXMgfSBmcm9tICcuL2dsb2JhbHMuanMnO1xuaW1wb3J0IHsgZnJvbVdoaXRlSXNaZXJvLCBmcm9tQmxhY2tJc1plcm8sIGZyb21QYWxldHRlLCBmcm9tQ01ZSywgZnJvbVlDYkNyLCBmcm9tQ0lFTGFiIH0gZnJvbSAnLi9yZ2IuanMnO1xuaW1wb3J0IHsgZ2V0RGVjb2RlciB9IGZyb20gJy4vY29tcHJlc3Npb24vaW5kZXguanMnO1xuaW1wb3J0IHsgcmVzYW1wbGUsIHJlc2FtcGxlSW50ZXJsZWF2ZWQgfSBmcm9tICcuL3Jlc2FtcGxlLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBSZWFkUmFzdGVyT3B0aW9uc1xuICogQHByb3BlcnR5IHtBcnJheTxudW1iZXI+fSBbd2luZG93PXdob2xlIHdpbmRvd10gdGhlIHN1YnNldCB0byByZWFkIGRhdGEgZnJvbSBpbiBwaXhlbHMuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IFtiYm94PXdob2xlIGltYWdlXSB0aGUgc3Vic2V0IHRvIHJlYWQgZGF0YSBmcm9tIGluXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW9ncmFwaGljYWwgY29vcmRpbmF0ZXMuXG4gKiBAcHJvcGVydHkge0FycmF5PG51bWJlcj59IFtzYW1wbGVzPWFsbCBzYW1wbGVzXSB0aGUgc2VsZWN0aW9uIG9mIHNhbXBsZXMgdG8gcmVhZCBmcm9tLiBEZWZhdWx0IGlzIGFsbCBzYW1wbGVzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbaW50ZXJsZWF2ZT1mYWxzZV0gd2hldGhlciB0aGUgZGF0YSBzaGFsbCBiZSByZWFkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIG9uZSBzaW5nbGUgYXJyYXkgb3Igc2VwYXJhdGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlzLlxuICogQHByb3BlcnR5IHtQb29sfSBbcG9vbD1udWxsXSBUaGUgb3B0aW9uYWwgZGVjb2RlciBwb29sIHRvIHVzZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbd2lkdGhdIFRoZSBkZXNpcmVkIHdpZHRoIG9mIHRoZSBvdXRwdXQuIFdoZW4gdGhlIHdpZHRoIGlzIG5vdCB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2FtZSBhcyB0aGUgaW1hZ2VzLCByZXNhbXBsaW5nIHdpbGwgYmUgcGVyZm9ybWVkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtoZWlnaHRdIFRoZSBkZXNpcmVkIGhlaWdodCBvZiB0aGUgb3V0cHV0LiBXaGVuIHRoZSB3aWR0aCBpcyBub3QgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYW1lIGFzIHRoZSBpbWFnZXMsIHJlc2FtcGxpbmcgd2lsbCBiZSBwZXJmb3JtZWQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3Jlc2FtcGxlTWV0aG9kPSduZWFyZXN0J10gVGhlIGRlc2lyZWQgcmVzYW1wbGluZyBtZXRob2QuXG4gKiBAcHJvcGVydHkge0Fib3J0U2lnbmFsfSBbc2lnbmFsXSBBbiBBYm9ydFNpZ25hbCB0aGF0IG1heSBiZSBzaWduYWxsZWQgaWYgdGhlIHJlcXVlc3QgaXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYmUgYWJvcnRlZFxuICogQHByb3BlcnR5IHtudW1iZXJ8bnVtYmVyW119IFtmaWxsVmFsdWVdIFRoZSB2YWx1ZSB0byB1c2UgZm9yIHBhcnRzIG9mIHRoZSBpbWFnZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0c2lkZSBvZiB0aGUgaW1hZ2VzIGV4dGVudC4gV2hlbiBtdWx0aXBsZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2FtcGxlcyBhcmUgcmVxdWVzdGVkLCBhbiBhcnJheSBvZiBmaWxsIHZhbHVlc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuIGJlIHBhc3NlZC5cbiAqL1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydChcIi4vZ2VvdGlmZi5qc1wiKS5UeXBlZEFycmF5fSBUeXBlZEFycmF5ICovXG4vKiogQHR5cGVkZWYge2ltcG9ydChcIi4vZ2VvdGlmZi5qc1wiKS5SZWFkUmFzdGVyUmVzdWx0fSBSZWFkUmFzdGVyUmVzdWx0ICovXG5cbmZ1bmN0aW9uIHN1bShhcnJheSwgc3RhcnQsIGVuZCkge1xuICBsZXQgcyA9IDA7XG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcyArPSBhcnJheVtpXTtcbiAgfVxuICByZXR1cm4gcztcbn1cblxuZnVuY3Rpb24gYXJyYXlGb3JUeXBlKGZvcm1hdCwgYml0c1BlclNhbXBsZSwgc2l6ZSkge1xuICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgIGNhc2UgMTogLy8gdW5zaWduZWQgaW50ZWdlciBkYXRhXG4gICAgICBpZiAoYml0c1BlclNhbXBsZSA8PSA4KSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICAgIH0gZWxzZSBpZiAoYml0c1BlclNhbXBsZSA8PSAxNikge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQxNkFycmF5KHNpemUpO1xuICAgICAgfSBlbHNlIGlmIChiaXRzUGVyU2FtcGxlIDw9IDMyKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoc2l6ZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6IC8vIHR3b3MgY29tcGxlbWVudCBzaWduZWQgaW50ZWdlciBkYXRhXG4gICAgICBpZiAoYml0c1BlclNhbXBsZSA9PT0gOCkge1xuICAgICAgICByZXR1cm4gbmV3IEludDhBcnJheShzaXplKTtcbiAgICAgIH0gZWxzZSBpZiAoYml0c1BlclNhbXBsZSA9PT0gMTYpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnQxNkFycmF5KHNpemUpO1xuICAgICAgfSBlbHNlIGlmIChiaXRzUGVyU2FtcGxlID09PSAzMikge1xuICAgICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoc2l6ZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6IC8vIGZsb2F0aW5nIHBvaW50IGRhdGFcbiAgICAgIHN3aXRjaCAoYml0c1BlclNhbXBsZSkge1xuICAgICAgICBjYXNlIDE2OlxuICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHNpemUpO1xuICAgICAgICBjYXNlIDY0OlxuICAgICAgICAgIHJldHVybiBuZXcgRmxvYXQ2NEFycmF5KHNpemUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICB9XG4gIHRocm93IEVycm9yKCdVbnN1cHBvcnRlZCBkYXRhIGZvcm1hdC9iaXRzUGVyU2FtcGxlJyk7XG59XG5cbmZ1bmN0aW9uIG5lZWRzTm9ybWFsaXphdGlvbihmb3JtYXQsIGJpdHNQZXJTYW1wbGUpIHtcbiAgaWYgKChmb3JtYXQgPT09IDEgfHwgZm9ybWF0ID09PSAyKSAmJiBiaXRzUGVyU2FtcGxlIDw9IDMyICYmIGJpdHNQZXJTYW1wbGUgJSA4ID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMyAmJiAoYml0c1BlclNhbXBsZSA9PT0gMTYgfHwgYml0c1BlclNhbXBsZSA9PT0gMzIgfHwgYml0c1BlclNhbXBsZSA9PT0gNjQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShpbkJ1ZmZlciwgZm9ybWF0LCBwbGFuYXJDb25maWd1cmF0aW9uLCBzYW1wbGVzUGVyUGl4ZWwsIGJpdHNQZXJTYW1wbGUsIHRpbGVXaWR0aCwgdGlsZUhlaWdodCkge1xuICAvLyBjb25zdCBpbkJ5dGVBcnJheSA9IG5ldyBVaW50OEFycmF5KGluQnVmZmVyKTtcbiAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhpbkJ1ZmZlcik7XG4gIGNvbnN0IG91dFNpemUgPSBwbGFuYXJDb25maWd1cmF0aW9uID09PSAyXG4gICAgPyB0aWxlSGVpZ2h0ICogdGlsZVdpZHRoXG4gICAgOiB0aWxlSGVpZ2h0ICogdGlsZVdpZHRoICogc2FtcGxlc1BlclBpeGVsO1xuICBjb25zdCBzYW1wbGVzVG9UcmFuc2ZlciA9IHBsYW5hckNvbmZpZ3VyYXRpb24gPT09IDJcbiAgICA/IDEgOiBzYW1wbGVzUGVyUGl4ZWw7XG4gIGNvbnN0IG91dEFycmF5ID0gYXJyYXlGb3JUeXBlKGZvcm1hdCwgYml0c1BlclNhbXBsZSwgb3V0U2l6ZSk7XG4gIC8vIGxldCBwaXhlbCA9IDA7XG5cbiAgY29uc3QgYml0TWFzayA9IHBhcnNlSW50KCcxJy5yZXBlYXQoYml0c1BlclNhbXBsZSksIDIpO1xuXG4gIGlmIChmb3JtYXQgPT09IDEpIHsgLy8gdW5zaWduZWQgaW50ZWdlclxuICAgIC8vIHRyYW5zbGF0aW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9PU0dlby9nZGFsL2Jsb2IvbWFzdGVyL2dkYWwvZnJtdHMvZ3RpZmYvZ2VvdGlmZi5jcHAjTDczMzdcbiAgICBsZXQgcGl4ZWxCaXRTa2lwO1xuICAgIC8vIGxldCBzYW1wbGVCaXRPZmZzZXQgPSAwO1xuICAgIGlmIChwbGFuYXJDb25maWd1cmF0aW9uID09PSAxKSB7XG4gICAgICBwaXhlbEJpdFNraXAgPSBzYW1wbGVzUGVyUGl4ZWwgKiBiaXRzUGVyU2FtcGxlO1xuICAgICAgLy8gc2FtcGxlQml0T2Zmc2V0ID0gKHNhbXBsZXNQZXJQaXhlbCAtIDEpICogYml0c1BlclNhbXBsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGl4ZWxCaXRTa2lwID0gYml0c1BlclNhbXBsZTtcbiAgICB9XG5cbiAgICAvLyBCaXRzIHBlciBsaW5lIHJvdW5kcyB1cCB0byBuZXh0IGJ5dGUgYm91bmRhcnkuXG4gICAgbGV0IGJpdHNQZXJMaW5lID0gdGlsZVdpZHRoICogcGl4ZWxCaXRTa2lwO1xuICAgIGlmICgoYml0c1BlckxpbmUgJiA3KSAhPT0gMCkge1xuICAgICAgYml0c1BlckxpbmUgPSAoYml0c1BlckxpbmUgKyA3KSAmICh+Nyk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aWxlSGVpZ2h0OyArK3kpIHtcbiAgICAgIGNvbnN0IGxpbmVCaXRPZmZzZXQgPSB5ICogYml0c1BlckxpbmU7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRpbGVXaWR0aDsgKyt4KSB7XG4gICAgICAgIGNvbnN0IHBpeGVsQml0T2Zmc2V0ID0gbGluZUJpdE9mZnNldCArICh4ICogc2FtcGxlc1RvVHJhbnNmZXIgKiBiaXRzUGVyU2FtcGxlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzVG9UcmFuc2ZlcjsgKytpKSB7XG4gICAgICAgICAgY29uc3QgYml0T2Zmc2V0ID0gcGl4ZWxCaXRPZmZzZXQgKyAoaSAqIGJpdHNQZXJTYW1wbGUpO1xuICAgICAgICAgIGNvbnN0IG91dEluZGV4ID0gKCgoeSAqIHRpbGVXaWR0aCkgKyB4KSAqIHNhbXBsZXNUb1RyYW5zZmVyKSArIGk7XG5cbiAgICAgICAgICBjb25zdCBieXRlT2Zmc2V0ID0gTWF0aC5mbG9vcihiaXRPZmZzZXQgLyA4KTtcbiAgICAgICAgICBjb25zdCBpbm5lckJpdE9mZnNldCA9IGJpdE9mZnNldCAlIDg7XG4gICAgICAgICAgaWYgKGlubmVyQml0T2Zmc2V0ICsgYml0c1BlclNhbXBsZSA8PSA4KSB7XG4gICAgICAgICAgICBvdXRBcnJheVtvdXRJbmRleF0gPSAodmlldy5nZXRVaW50OChieXRlT2Zmc2V0KSA+PiAoOCAtIGJpdHNQZXJTYW1wbGUpIC0gaW5uZXJCaXRPZmZzZXQpICYgYml0TWFzaztcbiAgICAgICAgICB9IGVsc2UgaWYgKGlubmVyQml0T2Zmc2V0ICsgYml0c1BlclNhbXBsZSA8PSAxNikge1xuICAgICAgICAgICAgb3V0QXJyYXlbb3V0SW5kZXhdID0gKHZpZXcuZ2V0VWludDE2KGJ5dGVPZmZzZXQpID4+ICgxNiAtIGJpdHNQZXJTYW1wbGUpIC0gaW5uZXJCaXRPZmZzZXQpICYgYml0TWFzaztcbiAgICAgICAgICB9IGVsc2UgaWYgKGlubmVyQml0T2Zmc2V0ICsgYml0c1BlclNhbXBsZSA8PSAyNCkge1xuICAgICAgICAgICAgY29uc3QgcmF3ID0gKHZpZXcuZ2V0VWludDE2KGJ5dGVPZmZzZXQpIDw8IDgpIHwgKHZpZXcuZ2V0VWludDgoYnl0ZU9mZnNldCArIDIpKTtcbiAgICAgICAgICAgIG91dEFycmF5W291dEluZGV4XSA9IChyYXcgPj4gKDI0IC0gYml0c1BlclNhbXBsZSkgLSBpbm5lckJpdE9mZnNldCkgJiBiaXRNYXNrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXRBcnJheVtvdXRJbmRleF0gPSAodmlldy5nZXRVaW50MzIoYnl0ZU9mZnNldCkgPj4gKDMyIC0gYml0c1BlclNhbXBsZSkgLSBpbm5lckJpdE9mZnNldCkgJiBiaXRNYXNrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGxldCBvdXRXb3JkID0gMDtcbiAgICAgICAgICAvLyBmb3IgKGxldCBiaXQgPSAwOyBiaXQgPCBiaXRzUGVyU2FtcGxlOyArK2JpdCkge1xuICAgICAgICAgIC8vICAgaWYgKGluQnl0ZUFycmF5W2JpdE9mZnNldCA+PiAzXVxuICAgICAgICAgIC8vICAgICAmICgweDgwID4+IChiaXRPZmZzZXQgJiA3KSkpIHtcbiAgICAgICAgICAvLyAgICAgb3V0V29yZCB8PSAoMSA8PCAoYml0c1BlclNhbXBsZSAtIDEgLSBiaXQpKTtcbiAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAvLyAgICsrYml0T2Zmc2V0O1xuICAgICAgICAgIC8vIH1cblxuICAgICAgICAgIC8vIG91dEFycmF5W291dEluZGV4XSA9IG91dFdvcmQ7XG4gICAgICAgICAgLy8gb3V0QXJyYXlbcGl4ZWxdID0gb3V0V29yZDtcbiAgICAgICAgICAvLyBwaXhlbCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJpdE9mZnNldCA9IGJpdE9mZnNldCArIHBpeGVsQml0U2tpcCAtIGJpdHNQZXJTYW1wbGU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMykgeyAvLyBmbG9hdGluZyBwb2ludFxuICAgIC8vIEZsb2F0MTYgaXMgaGFuZGxlZCBlbHNld2hlcmVcbiAgICAvLyBub3JtYWxpemUgMTYvMjQgYml0IGZsb2F0cyB0byAzMiBiaXQgZmxvYXRzIGluIHRoZSBhcnJheVxuICAgIC8vIGNvbnNvbGUudGltZSgpO1xuICAgIC8vIGlmIChiaXRzUGVyU2FtcGxlID09PSAxNikge1xuICAgIC8vICAgZm9yIChsZXQgYnl0ZSA9IDAsIG91dEluZGV4ID0gMDsgYnl0ZSA8IGluQnVmZmVyLmJ5dGVMZW5ndGg7IGJ5dGUgKz0gMiwgKytvdXRJbmRleCkge1xuICAgIC8vICAgICBvdXRBcnJheVtvdXRJbmRleF0gPSBnZXRGbG9hdDE2KHZpZXcsIGJ5dGUpO1xuICAgIC8vICAgfVxuICAgIC8vIH1cbiAgICAvLyBjb25zb2xlLnRpbWVFbmQoKVxuICB9XG5cbiAgcmV0dXJuIG91dEFycmF5LmJ1ZmZlcjtcbn1cblxuLyoqXG4gKiBHZW9USUZGIHN1Yi1maWxlIGltYWdlLlxuICovXG5jbGFzcyBHZW9USUZGSW1hZ2Uge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmaWxlRGlyZWN0b3J5IFRoZSBwYXJzZWQgZmlsZSBkaXJlY3RvcnlcbiAgICogQHBhcmFtIHtPYmplY3R9IGdlb0tleXMgVGhlIHBhcnNlZCBnZW8ta2V5c1xuICAgKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhVmlldyBUaGUgRGF0YVZpZXcgZm9yIHRoZSB1bmRlcmx5aW5nIGZpbGUuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbGl0dGxlRW5kaWFuIFdoZXRoZXIgdGhlIGZpbGUgaXMgZW5jb2RlZCBpbiBsaXR0bGUgb3IgYmlnIGVuZGlhblxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNhY2hlIFdoZXRoZXIgb3Igbm90IGRlY29kZWQgdGlsZXMgc2hhbGwgYmUgY2FjaGVkXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuL3NvdXJjZS9iYXNlc291cmNlJykuQmFzZVNvdXJjZX0gc291cmNlIFRoZSBkYXRhc291cmNlIHRvIHJlYWQgZnJvbVxuICAgKi9cbiAgY29uc3RydWN0b3IoZmlsZURpcmVjdG9yeSwgZ2VvS2V5cywgZGF0YVZpZXcsIGxpdHRsZUVuZGlhbiwgY2FjaGUsIHNvdXJjZSkge1xuICAgIHRoaXMuZmlsZURpcmVjdG9yeSA9IGZpbGVEaXJlY3Rvcnk7XG4gICAgdGhpcy5nZW9LZXlzID0gZ2VvS2V5cztcbiAgICB0aGlzLmRhdGFWaWV3ID0gZGF0YVZpZXc7XG4gICAgdGhpcy5saXR0bGVFbmRpYW4gPSBsaXR0bGVFbmRpYW47XG4gICAgdGhpcy50aWxlcyA9IGNhY2hlID8ge30gOiBudWxsO1xuICAgIHRoaXMuaXNUaWxlZCA9ICFmaWxlRGlyZWN0b3J5LlN0cmlwT2Zmc2V0cztcbiAgICBjb25zdCBwbGFuYXJDb25maWd1cmF0aW9uID0gZmlsZURpcmVjdG9yeS5QbGFuYXJDb25maWd1cmF0aW9uO1xuICAgIHRoaXMucGxhbmFyQ29uZmlndXJhdGlvbiA9ICh0eXBlb2YgcGxhbmFyQ29uZmlndXJhdGlvbiA9PT0gJ3VuZGVmaW5lZCcpID8gMSA6IHBsYW5hckNvbmZpZ3VyYXRpb247XG4gICAgaWYgKHRoaXMucGxhbmFyQ29uZmlndXJhdGlvbiAhPT0gMSAmJiB0aGlzLnBsYW5hckNvbmZpZ3VyYXRpb24gIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwbGFuYXIgY29uZmlndXJhdGlvbi4nKTtcbiAgICB9XG5cbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhc3NvY2lhdGVkIHBhcnNlZCBmaWxlIGRpcmVjdG9yeS5cbiAgICogQHJldHVybnMge09iamVjdH0gdGhlIHBhcnNlZCBmaWxlIGRpcmVjdG9yeVxuICAgKi9cbiAgZ2V0RmlsZURpcmVjdG9yeSgpIHtcbiAgICByZXR1cm4gdGhpcy5maWxlRGlyZWN0b3J5O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFzc29jaWF0ZWQgcGFyc2VkIGdlbyBrZXlzLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgcGFyc2VkIGdlbyBrZXlzXG4gICAqL1xuICBnZXRHZW9LZXlzKCkge1xuICAgIHJldHVybiB0aGlzLmdlb0tleXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIGltYWdlLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgd2lkdGggb2YgdGhlIGltYWdlXG4gICAqL1xuICBnZXRXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5maWxlRGlyZWN0b3J5LkltYWdlV2lkdGg7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaGVpZ2h0IG9mIHRoZSBpbWFnZS5cbiAgICogQHJldHVybnMge051bWJlcn0gdGhlIGhlaWdodCBvZiB0aGUgaW1hZ2VcbiAgICovXG4gIGdldEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5maWxlRGlyZWN0b3J5LkltYWdlTGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBzYW1wbGVzIHBlciBwaXhlbC5cbiAgICogQHJldHVybnMge051bWJlcn0gdGhlIG51bWJlciBvZiBzYW1wbGVzIHBlciBwaXhlbFxuICAgKi9cbiAgZ2V0U2FtcGxlc1BlclBpeGVsKCkge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5maWxlRGlyZWN0b3J5LlNhbXBsZXNQZXJQaXhlbCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgID8gdGhpcy5maWxlRGlyZWN0b3J5LlNhbXBsZXNQZXJQaXhlbCA6IDE7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgZWFjaCB0aWxlLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgd2lkdGggb2YgZWFjaCB0aWxlXG4gICAqL1xuICBnZXRUaWxlV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNUaWxlZCA/IHRoaXMuZmlsZURpcmVjdG9yeS5UaWxlV2lkdGggOiB0aGlzLmdldFdpZHRoKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaGVpZ2h0IG9mIGVhY2ggdGlsZS5cbiAgICogQHJldHVybnMge051bWJlcn0gdGhlIGhlaWdodCBvZiBlYWNoIHRpbGVcbiAgICovXG4gIGdldFRpbGVIZWlnaHQoKSB7XG4gICAgaWYgKHRoaXMuaXNUaWxlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsZURpcmVjdG9yeS5UaWxlTGVuZ3RoO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXMuZmlsZURpcmVjdG9yeS5Sb3dzUGVyU3RyaXAgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gTWF0aC5taW4odGhpcy5maWxlRGlyZWN0b3J5LlJvd3NQZXJTdHJpcCwgdGhpcy5nZXRIZWlnaHQoKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldEhlaWdodCgpO1xuICB9XG5cbiAgZ2V0QmxvY2tXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUaWxlV2lkdGgoKTtcbiAgfVxuXG4gIGdldEJsb2NrSGVpZ2h0KHkpIHtcbiAgICBpZiAodGhpcy5pc1RpbGVkIHx8ICh5ICsgMSkgKiB0aGlzLmdldFRpbGVIZWlnaHQoKSA8PSB0aGlzLmdldEhlaWdodCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUaWxlSGVpZ2h0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEhlaWdodCgpIC0gKHkgKiB0aGlzLmdldFRpbGVIZWlnaHQoKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBieXRlcyBmb3IgZWFjaCBwaXhlbCBhY3Jvc3MgYWxsIHNhbXBsZXMuIE9ubHkgZnVsbFxuICAgKiBieXRlcyBhcmUgc3VwcG9ydGVkLCBhbiBleGNlcHRpb24gaXMgdGhyb3duIHdoZW4gdGhpcyBpcyBub3QgdGhlIGNhc2UuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBieXRlcyBwZXIgcGl4ZWxcbiAgICovXG4gIGdldEJ5dGVzUGVyUGl4ZWwoKSB7XG4gICAgbGV0IGJ5dGVzID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmlsZURpcmVjdG9yeS5CaXRzUGVyU2FtcGxlLmxlbmd0aDsgKytpKSB7XG4gICAgICBieXRlcyArPSB0aGlzLmdldFNhbXBsZUJ5dGVTaXplKGkpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG4gIH1cblxuICBnZXRTYW1wbGVCeXRlU2l6ZShpKSB7XG4gICAgaWYgKGkgPj0gdGhpcy5maWxlRGlyZWN0b3J5LkJpdHNQZXJTYW1wbGUubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgU2FtcGxlIGluZGV4ICR7aX0gaXMgb3V0IG9mIHJhbmdlLmApO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuZmlsZURpcmVjdG9yeS5CaXRzUGVyU2FtcGxlW2ldIC8gOCk7XG4gIH1cblxuICBnZXRSZWFkZXJGb3JTYW1wbGUoc2FtcGxlSW5kZXgpIHtcbiAgICBjb25zdCBmb3JtYXQgPSB0aGlzLmZpbGVEaXJlY3RvcnkuU2FtcGxlRm9ybWF0XG4gICAgICA/IHRoaXMuZmlsZURpcmVjdG9yeS5TYW1wbGVGb3JtYXRbc2FtcGxlSW5kZXhdIDogMTtcbiAgICBjb25zdCBiaXRzUGVyU2FtcGxlID0gdGhpcy5maWxlRGlyZWN0b3J5LkJpdHNQZXJTYW1wbGVbc2FtcGxlSW5kZXhdO1xuICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICBjYXNlIDE6IC8vIHVuc2lnbmVkIGludGVnZXIgZGF0YVxuICAgICAgICBpZiAoYml0c1BlclNhbXBsZSA8PSA4KSB7XG4gICAgICAgICAgcmV0dXJuIERhdGFWaWV3LnByb3RvdHlwZS5nZXRVaW50ODtcbiAgICAgICAgfSBlbHNlIGlmIChiaXRzUGVyU2FtcGxlIDw9IDE2KSB7XG4gICAgICAgICAgcmV0dXJuIERhdGFWaWV3LnByb3RvdHlwZS5nZXRVaW50MTY7XG4gICAgICAgIH0gZWxzZSBpZiAoYml0c1BlclNhbXBsZSA8PSAzMikge1xuICAgICAgICAgIHJldHVybiBEYXRhVmlldy5wcm90b3R5cGUuZ2V0VWludDMyO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOiAvLyB0d29zIGNvbXBsZW1lbnQgc2lnbmVkIGludGVnZXIgZGF0YVxuICAgICAgICBpZiAoYml0c1BlclNhbXBsZSA8PSA4KSB7XG4gICAgICAgICAgcmV0dXJuIERhdGFWaWV3LnByb3RvdHlwZS5nZXRJbnQ4O1xuICAgICAgICB9IGVsc2UgaWYgKGJpdHNQZXJTYW1wbGUgPD0gMTYpIHtcbiAgICAgICAgICByZXR1cm4gRGF0YVZpZXcucHJvdG90eXBlLmdldEludDE2O1xuICAgICAgICB9IGVsc2UgaWYgKGJpdHNQZXJTYW1wbGUgPD0gMzIpIHtcbiAgICAgICAgICByZXR1cm4gRGF0YVZpZXcucHJvdG90eXBlLmdldEludDMyO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBzd2l0Y2ggKGJpdHNQZXJTYW1wbGUpIHtcbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0RmxvYXQxNih0aGlzLCBvZmZzZXQsIGxpdHRsZUVuZGlhbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICByZXR1cm4gRGF0YVZpZXcucHJvdG90eXBlLmdldEZsb2F0MzI7XG4gICAgICAgICAgY2FzZSA2NDpcbiAgICAgICAgICAgIHJldHVybiBEYXRhVmlldy5wcm90b3R5cGUuZ2V0RmxvYXQ2NDtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoJ1Vuc3VwcG9ydGVkIGRhdGEgZm9ybWF0L2JpdHNQZXJTYW1wbGUnKTtcbiAgfVxuXG4gIGdldFNhbXBsZUZvcm1hdChzYW1wbGVJbmRleCA9IDApIHtcbiAgICByZXR1cm4gdGhpcy5maWxlRGlyZWN0b3J5LlNhbXBsZUZvcm1hdFxuICAgICAgPyB0aGlzLmZpbGVEaXJlY3RvcnkuU2FtcGxlRm9ybWF0W3NhbXBsZUluZGV4XSA6IDE7XG4gIH1cblxuICBnZXRCaXRzUGVyU2FtcGxlKHNhbXBsZUluZGV4ID0gMCkge1xuICAgIHJldHVybiB0aGlzLmZpbGVEaXJlY3RvcnkuQml0c1BlclNhbXBsZVtzYW1wbGVJbmRleF07XG4gIH1cblxuICBnZXRBcnJheUZvclNhbXBsZShzYW1wbGVJbmRleCwgc2l6ZSkge1xuICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuZ2V0U2FtcGxlRm9ybWF0KHNhbXBsZUluZGV4KTtcbiAgICBjb25zdCBiaXRzUGVyU2FtcGxlID0gdGhpcy5nZXRCaXRzUGVyU2FtcGxlKHNhbXBsZUluZGV4KTtcbiAgICByZXR1cm4gYXJyYXlGb3JUeXBlKGZvcm1hdCwgYml0c1BlclNhbXBsZSwgc2l6ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGVjb2RlZCBzdHJpcCBvciB0aWxlLlxuICAgKiBAcGFyYW0ge051bWJlcn0geCB0aGUgc3RyaXAgb3IgdGlsZSB4LW9mZnNldFxuICAgKiBAcGFyYW0ge051bWJlcn0geSB0aGUgdGlsZSB5LW9mZnNldCAoMCBmb3Igc3RyaXBwZWQgaW1hZ2VzKVxuICAgKiBAcGFyYW0ge051bWJlcn0gc2FtcGxlIHRoZSBzYW1wbGUgdG8gZ2V0IGZvciBzZXBhcmF0ZWQgc2FtcGxlc1xuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vZ2VvdGlmZlwiKS5Qb29sfGltcG9ydChcIi4vZ2VvdGlmZlwiKS5CYXNlRGVjb2Rlcn0gcG9vbE9yRGVjb2RlciB0aGUgZGVjb2RlciBvciBkZWNvZGVyIHBvb2xcbiAgICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gW3NpZ25hbF0gQW4gQWJvcnRTaWduYWwgdGhhdCBtYXkgYmUgc2lnbmFsbGVkIGlmIHRoZSByZXF1ZXN0IGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGJlIGFib3J0ZWRcbiAgICogQHJldHVybnMge1Byb21pc2UuPEFycmF5QnVmZmVyPn1cbiAgICovXG4gIGFzeW5jIGdldFRpbGVPclN0cmlwKHgsIHksIHNhbXBsZSwgcG9vbE9yRGVjb2Rlciwgc2lnbmFsKSB7XG4gICAgY29uc3QgbnVtVGlsZXNQZXJSb3cgPSBNYXRoLmNlaWwodGhpcy5nZXRXaWR0aCgpIC8gdGhpcy5nZXRUaWxlV2lkdGgoKSk7XG4gICAgY29uc3QgbnVtVGlsZXNQZXJDb2wgPSBNYXRoLmNlaWwodGhpcy5nZXRIZWlnaHQoKSAvIHRoaXMuZ2V0VGlsZUhlaWdodCgpKTtcbiAgICBsZXQgaW5kZXg7XG4gICAgY29uc3QgeyB0aWxlcyB9ID0gdGhpcztcbiAgICBpZiAodGhpcy5wbGFuYXJDb25maWd1cmF0aW9uID09PSAxKSB7XG4gICAgICBpbmRleCA9ICh5ICogbnVtVGlsZXNQZXJSb3cpICsgeDtcbiAgICB9IGVsc2UgaWYgKHRoaXMucGxhbmFyQ29uZmlndXJhdGlvbiA9PT0gMikge1xuICAgICAgaW5kZXggPSAoc2FtcGxlICogbnVtVGlsZXNQZXJSb3cgKiBudW1UaWxlc1BlckNvbCkgKyAoeSAqIG51bVRpbGVzUGVyUm93KSArIHg7XG4gICAgfVxuXG4gICAgbGV0IG9mZnNldDtcbiAgICBsZXQgYnl0ZUNvdW50O1xuICAgIGlmICh0aGlzLmlzVGlsZWQpIHtcbiAgICAgIG9mZnNldCA9IHRoaXMuZmlsZURpcmVjdG9yeS5UaWxlT2Zmc2V0c1tpbmRleF07XG4gICAgICBieXRlQ291bnQgPSB0aGlzLmZpbGVEaXJlY3RvcnkuVGlsZUJ5dGVDb3VudHNbaW5kZXhdO1xuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXQgPSB0aGlzLmZpbGVEaXJlY3RvcnkuU3RyaXBPZmZzZXRzW2luZGV4XTtcbiAgICAgIGJ5dGVDb3VudCA9IHRoaXMuZmlsZURpcmVjdG9yeS5TdHJpcEJ5dGVDb3VudHNbaW5kZXhdO1xuICAgIH1cbiAgICBjb25zdCBzbGljZSA9IChhd2FpdCB0aGlzLnNvdXJjZS5mZXRjaChbeyBvZmZzZXQsIGxlbmd0aDogYnl0ZUNvdW50IH1dLCBzaWduYWwpKVswXTtcblxuICAgIGxldCByZXF1ZXN0O1xuICAgIGlmICh0aWxlcyA9PT0gbnVsbCB8fCAhdGlsZXNbaW5kZXhdKSB7XG4gICAgLy8gcmVzb2x2ZSBlYWNoIHJlcXVlc3QgYnkgcG90ZW50aWFsbHkgYXBwbHlpbmcgYXJyYXkgbm9ybWFsaXphdGlvblxuICAgICAgcmVxdWVzdCA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgIGxldCBkYXRhID0gYXdhaXQgcG9vbE9yRGVjb2Rlci5kZWNvZGUodGhpcy5maWxlRGlyZWN0b3J5LCBzbGljZSk7XG4gICAgICAgIGNvbnN0IHNhbXBsZUZvcm1hdCA9IHRoaXMuZ2V0U2FtcGxlRm9ybWF0KCk7XG4gICAgICAgIGNvbnN0IGJpdHNQZXJTYW1wbGUgPSB0aGlzLmdldEJpdHNQZXJTYW1wbGUoKTtcbiAgICAgICAgaWYgKG5lZWRzTm9ybWFsaXphdGlvbihzYW1wbGVGb3JtYXQsIGJpdHNQZXJTYW1wbGUpKSB7XG4gICAgICAgICAgZGF0YSA9IG5vcm1hbGl6ZUFycmF5KFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHNhbXBsZUZvcm1hdCxcbiAgICAgICAgICAgIHRoaXMucGxhbmFyQ29uZmlndXJhdGlvbixcbiAgICAgICAgICAgIHRoaXMuZ2V0U2FtcGxlc1BlclBpeGVsKCksXG4gICAgICAgICAgICBiaXRzUGVyU2FtcGxlLFxuICAgICAgICAgICAgdGhpcy5nZXRUaWxlV2lkdGgoKSxcbiAgICAgICAgICAgIHRoaXMuZ2V0QmxvY2tIZWlnaHQoeSksXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH0pKCk7XG5cbiAgICAgIC8vIHNldCB0aGUgY2FjaGVcbiAgICAgIGlmICh0aWxlcyAhPT0gbnVsbCkge1xuICAgICAgICB0aWxlc1tpbmRleF0gPSByZXF1ZXN0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBnZXQgZnJvbSB0aGUgY2FjaGVcbiAgICAgIHJlcXVlc3QgPSB0aWxlc1tpbmRleF07XG4gICAgfVxuXG4gICAgLy8gY2FjaGUgdGhlIHRpbGUgcmVxdWVzdFxuICAgIHJldHVybiB7IHgsIHksIHNhbXBsZSwgZGF0YTogYXdhaXQgcmVxdWVzdCB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVybmFsIHJlYWQgZnVuY3Rpb24uXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGltYWdlV2luZG93IFRoZSBpbWFnZSB3aW5kb3cgaW4gcGl4ZWwgY29vcmRpbmF0ZXNcbiAgICogQHBhcmFtIHtBcnJheX0gc2FtcGxlcyBUaGUgc2VsZWN0ZWQgc2FtcGxlcyAoMC1iYXNlZCBpbmRpY2VzKVxuICAgKiBAcGFyYW0ge1R5cGVkQXJyYXl8VHlwZWRBcnJheVtdfSB2YWx1ZUFycmF5cyBUaGUgYXJyYXkocykgdG8gd3JpdGUgaW50b1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGludGVybGVhdmUgV2hldGhlciBvciBub3QgdG8gd3JpdGUgaW4gYW4gaW50ZXJsZWF2ZWQgbWFubmVyXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9nZW90aWZmXCIpLlBvb2x8QWJzdHJhY3REZWNvZGVyfSBwb29sT3JEZWNvZGVyIHRoZSBkZWNvZGVyIG9yIGRlY29kZXIgcG9vbFxuICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggdGhlIHdpZHRoIG9mIHdpbmRvdyB0byBiZSByZWFkIGludG9cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCB0aGUgaGVpZ2h0IG9mIHdpbmRvdyB0byBiZSByZWFkIGludG9cbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlc2FtcGxlTWV0aG9kIHRoZSByZXNhbXBsaW5nIG1ldGhvZCB0byBiZSB1c2VkIHdoZW4gaW50ZXJwb2xhdGluZ1xuICAgKiBAcGFyYW0ge0Fib3J0U2lnbmFsfSBbc2lnbmFsXSBBbiBBYm9ydFNpZ25hbCB0aGF0IG1heSBiZSBzaWduYWxsZWQgaWYgdGhlIHJlcXVlc3QgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYmUgYWJvcnRlZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZWFkUmFzdGVyUmVzdWx0Pn1cbiAgICovXG4gIGFzeW5jIF9yZWFkUmFzdGVyKGltYWdlV2luZG93LCBzYW1wbGVzLCB2YWx1ZUFycmF5cywgaW50ZXJsZWF2ZSwgcG9vbE9yRGVjb2Rlciwgd2lkdGgsXG4gICAgaGVpZ2h0LCByZXNhbXBsZU1ldGhvZCwgc2lnbmFsKSB7XG4gICAgY29uc3QgdGlsZVdpZHRoID0gdGhpcy5nZXRUaWxlV2lkdGgoKTtcbiAgICBjb25zdCB0aWxlSGVpZ2h0ID0gdGhpcy5nZXRUaWxlSGVpZ2h0KCk7XG4gICAgY29uc3QgaW1hZ2VXaWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICBjb25zdCBpbWFnZUhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KCk7XG5cbiAgICBjb25zdCBtaW5YVGlsZSA9IE1hdGgubWF4KE1hdGguZmxvb3IoaW1hZ2VXaW5kb3dbMF0gLyB0aWxlV2lkdGgpLCAwKTtcbiAgICBjb25zdCBtYXhYVGlsZSA9IE1hdGgubWluKFxuICAgICAgTWF0aC5jZWlsKGltYWdlV2luZG93WzJdIC8gdGlsZVdpZHRoKSxcbiAgICAgIE1hdGguY2VpbChpbWFnZVdpZHRoIC8gdGlsZVdpZHRoKSxcbiAgICApO1xuICAgIGNvbnN0IG1pbllUaWxlID0gTWF0aC5tYXgoTWF0aC5mbG9vcihpbWFnZVdpbmRvd1sxXSAvIHRpbGVIZWlnaHQpLCAwKTtcbiAgICBjb25zdCBtYXhZVGlsZSA9IE1hdGgubWluKFxuICAgICAgTWF0aC5jZWlsKGltYWdlV2luZG93WzNdIC8gdGlsZUhlaWdodCksXG4gICAgICBNYXRoLmNlaWwoaW1hZ2VIZWlnaHQgLyB0aWxlSGVpZ2h0KSxcbiAgICApO1xuICAgIGNvbnN0IHdpbmRvd1dpZHRoID0gaW1hZ2VXaW5kb3dbMl0gLSBpbWFnZVdpbmRvd1swXTtcblxuICAgIGxldCBieXRlc1BlclBpeGVsID0gdGhpcy5nZXRCeXRlc1BlclBpeGVsKCk7XG5cbiAgICBjb25zdCBzcmNTYW1wbGVPZmZzZXRzID0gW107XG4gICAgY29uc3Qgc2FtcGxlUmVhZGVycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHRoaXMucGxhbmFyQ29uZmlndXJhdGlvbiA9PT0gMSkge1xuICAgICAgICBzcmNTYW1wbGVPZmZzZXRzLnB1c2goc3VtKHRoaXMuZmlsZURpcmVjdG9yeS5CaXRzUGVyU2FtcGxlLCAwLCBzYW1wbGVzW2ldKSAvIDgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3JjU2FtcGxlT2Zmc2V0cy5wdXNoKDApO1xuICAgICAgfVxuICAgICAgc2FtcGxlUmVhZGVycy5wdXNoKHRoaXMuZ2V0UmVhZGVyRm9yU2FtcGxlKHNhbXBsZXNbaV0pKTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgIGNvbnN0IHsgbGl0dGxlRW5kaWFuIH0gPSB0aGlzO1xuXG4gICAgZm9yIChsZXQgeVRpbGUgPSBtaW5ZVGlsZTsgeVRpbGUgPCBtYXhZVGlsZTsgKyt5VGlsZSkge1xuICAgICAgZm9yIChsZXQgeFRpbGUgPSBtaW5YVGlsZTsgeFRpbGUgPCBtYXhYVGlsZTsgKyt4VGlsZSkge1xuICAgICAgICBsZXQgZ2V0UHJvbWlzZTtcbiAgICAgICAgaWYgKHRoaXMucGxhbmFyQ29uZmlndXJhdGlvbiA9PT0gMSkge1xuICAgICAgICAgIGdldFByb21pc2UgPSB0aGlzLmdldFRpbGVPclN0cmlwKHhUaWxlLCB5VGlsZSwgMCwgcG9vbE9yRGVjb2Rlciwgc2lnbmFsKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBzYW1wbGVJbmRleCA9IDA7IHNhbXBsZUluZGV4IDwgc2FtcGxlcy5sZW5ndGg7ICsrc2FtcGxlSW5kZXgpIHtcbiAgICAgICAgICBjb25zdCBzaSA9IHNhbXBsZUluZGV4O1xuICAgICAgICAgIGNvbnN0IHNhbXBsZSA9IHNhbXBsZXNbc2FtcGxlSW5kZXhdO1xuICAgICAgICAgIGlmICh0aGlzLnBsYW5hckNvbmZpZ3VyYXRpb24gPT09IDIpIHtcbiAgICAgICAgICAgIGJ5dGVzUGVyUGl4ZWwgPSB0aGlzLmdldFNhbXBsZUJ5dGVTaXplKHNhbXBsZSk7XG4gICAgICAgICAgICBnZXRQcm9taXNlID0gdGhpcy5nZXRUaWxlT3JTdHJpcCh4VGlsZSwgeVRpbGUsIHNhbXBsZSwgcG9vbE9yRGVjb2Rlciwgc2lnbmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcHJvbWlzZSA9IGdldFByb21pc2UudGhlbigodGlsZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gdGlsZS5kYXRhO1xuICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrSGVpZ2h0ID0gdGhpcy5nZXRCbG9ja0hlaWdodCh0aWxlLnkpO1xuICAgICAgICAgICAgY29uc3QgZmlyc3RMaW5lID0gdGlsZS55ICogdGlsZUhlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0Q29sID0gdGlsZS54ICogdGlsZVdpZHRoO1xuICAgICAgICAgICAgY29uc3QgbGFzdExpbmUgPSBmaXJzdExpbmUgKyBibG9ja0hlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RDb2wgPSAodGlsZS54ICsgMSkgKiB0aWxlV2lkdGg7XG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSBzYW1wbGVSZWFkZXJzW3NpXTtcblxuICAgICAgICAgICAgY29uc3QgeW1heCA9IE1hdGgubWluKGJsb2NrSGVpZ2h0LCBibG9ja0hlaWdodCAtIChsYXN0TGluZSAtIGltYWdlV2luZG93WzNdKSwgaW1hZ2VIZWlnaHQgLSBmaXJzdExpbmUpO1xuICAgICAgICAgICAgY29uc3QgeG1heCA9IE1hdGgubWluKHRpbGVXaWR0aCwgdGlsZVdpZHRoIC0gKGxhc3RDb2wgLSBpbWFnZVdpbmRvd1syXSksIGltYWdlV2lkdGggLSBmaXJzdENvbCk7XG5cbiAgICAgICAgICAgIGZvciAobGV0IHkgPSBNYXRoLm1heCgwLCBpbWFnZVdpbmRvd1sxXSAtIGZpcnN0TGluZSk7IHkgPCB5bWF4OyArK3kpIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IE1hdGgubWF4KDAsIGltYWdlV2luZG93WzBdIC0gZmlyc3RDb2wpOyB4IDwgeG1heDsgKyt4KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGl4ZWxPZmZzZXQgPSAoKHkgKiB0aWxlV2lkdGgpICsgeCkgKiBieXRlc1BlclBpeGVsO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmVhZGVyLmNhbGwoXG4gICAgICAgICAgICAgICAgICBkYXRhVmlldywgcGl4ZWxPZmZzZXQgKyBzcmNTYW1wbGVPZmZzZXRzW3NpXSwgbGl0dGxlRW5kaWFuLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbGV0IHdpbmRvd0Nvb3JkaW5hdGU7XG4gICAgICAgICAgICAgICAgaWYgKGludGVybGVhdmUpIHtcbiAgICAgICAgICAgICAgICAgIHdpbmRvd0Nvb3JkaW5hdGUgPSAoKHkgKyBmaXJzdExpbmUgLSBpbWFnZVdpbmRvd1sxXSkgKiB3aW5kb3dXaWR0aCAqIHNhbXBsZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICArICgoeCArIGZpcnN0Q29sIC0gaW1hZ2VXaW5kb3dbMF0pICogc2FtcGxlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICsgc2k7XG4gICAgICAgICAgICAgICAgICB2YWx1ZUFycmF5c1t3aW5kb3dDb29yZGluYXRlXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB3aW5kb3dDb29yZGluYXRlID0gKFxuICAgICAgICAgICAgICAgICAgICAoeSArIGZpcnN0TGluZSAtIGltYWdlV2luZG93WzFdKSAqIHdpbmRvd1dpZHRoXG4gICAgICAgICAgICAgICAgICApICsgeCArIGZpcnN0Q29sIC0gaW1hZ2VXaW5kb3dbMF07XG4gICAgICAgICAgICAgICAgICB2YWx1ZUFycmF5c1tzaV1bd2luZG93Q29vcmRpbmF0ZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICAgIGlmICgod2lkdGggJiYgKGltYWdlV2luZG93WzJdIC0gaW1hZ2VXaW5kb3dbMF0pICE9PSB3aWR0aClcbiAgICAgICAgfHwgKGhlaWdodCAmJiAoaW1hZ2VXaW5kb3dbM10gLSBpbWFnZVdpbmRvd1sxXSkgIT09IGhlaWdodCkpIHtcbiAgICAgIGxldCByZXNhbXBsZWQ7XG4gICAgICBpZiAoaW50ZXJsZWF2ZSkge1xuICAgICAgICByZXNhbXBsZWQgPSByZXNhbXBsZUludGVybGVhdmVkKFxuICAgICAgICAgIHZhbHVlQXJyYXlzLFxuICAgICAgICAgIGltYWdlV2luZG93WzJdIC0gaW1hZ2VXaW5kb3dbMF0sXG4gICAgICAgICAgaW1hZ2VXaW5kb3dbM10gLSBpbWFnZVdpbmRvd1sxXSxcbiAgICAgICAgICB3aWR0aCwgaGVpZ2h0LFxuICAgICAgICAgIHNhbXBsZXMubGVuZ3RoLFxuICAgICAgICAgIHJlc2FtcGxlTWV0aG9kLFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzYW1wbGVkID0gcmVzYW1wbGUoXG4gICAgICAgICAgdmFsdWVBcnJheXMsXG4gICAgICAgICAgaW1hZ2VXaW5kb3dbMl0gLSBpbWFnZVdpbmRvd1swXSxcbiAgICAgICAgICBpbWFnZVdpbmRvd1szXSAtIGltYWdlV2luZG93WzFdLFxuICAgICAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgICAgcmVzYW1wbGVNZXRob2QsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXNhbXBsZWQud2lkdGggPSB3aWR0aDtcbiAgICAgIHJlc2FtcGxlZC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICByZXR1cm4gcmVzYW1wbGVkO1xuICAgIH1cblxuICAgIHZhbHVlQXJyYXlzLndpZHRoID0gd2lkdGggfHwgaW1hZ2VXaW5kb3dbMl0gLSBpbWFnZVdpbmRvd1swXTtcbiAgICB2YWx1ZUFycmF5cy5oZWlnaHQgPSBoZWlnaHQgfHwgaW1hZ2VXaW5kb3dbM10gLSBpbWFnZVdpbmRvd1sxXTtcblxuICAgIHJldHVybiB2YWx1ZUFycmF5cztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyByYXN0ZXIgZGF0YSBmcm9tIHRoZSBpbWFnZS4gVGhpcyBmdW5jdGlvbiByZWFkcyBhbGwgc2VsZWN0ZWQgc2FtcGxlc1xuICAgKiBpbnRvIHNlcGFyYXRlIGFycmF5cyBvZiB0aGUgY29ycmVjdCB0eXBlIGZvciB0aGF0IHNhbXBsZSBvciBpbnRvIGEgc2luZ2xlXG4gICAqIGNvbWJpbmVkIGFycmF5IHdoZW4gYGludGVybGVhdmVgIGlzIHNldC4gV2hlbiBwcm92aWRlZCwgb25seSBhIHN1YnNldFxuICAgKiBvZiB0aGUgcmFzdGVyIGlzIHJlYWQgZm9yIGVhY2ggc2FtcGxlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWRSYXN0ZXJPcHRpb25zfSBbb3B0aW9ucz17fV0gb3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZWFkUmFzdGVyUmVzdWx0Pn0gdGhlIGRlY29kZWQgYXJyYXlzIGFzIGEgcHJvbWlzZVxuICAgKi9cbiAgYXN5bmMgcmVhZFJhc3RlcnMoe1xuICAgIHdpbmRvdzogd25kLCBzYW1wbGVzID0gW10sIGludGVybGVhdmUsIHBvb2wgPSBudWxsLFxuICAgIHdpZHRoLCBoZWlnaHQsIHJlc2FtcGxlTWV0aG9kLCBmaWxsVmFsdWUsIHNpZ25hbCxcbiAgfSA9IHt9KSB7XG4gICAgY29uc3QgaW1hZ2VXaW5kb3cgPSB3bmQgfHwgWzAsIDAsIHRoaXMuZ2V0V2lkdGgoKSwgdGhpcy5nZXRIZWlnaHQoKV07XG5cbiAgICAvLyBjaGVjayBwYXJhbWV0ZXJzXG4gICAgaWYgKGltYWdlV2luZG93WzBdID4gaW1hZ2VXaW5kb3dbMl0gfHwgaW1hZ2VXaW5kb3dbMV0gPiBpbWFnZVdpbmRvd1szXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN1YnNldHMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbWFnZVdpbmRvd1dpZHRoID0gaW1hZ2VXaW5kb3dbMl0gLSBpbWFnZVdpbmRvd1swXTtcbiAgICBjb25zdCBpbWFnZVdpbmRvd0hlaWdodCA9IGltYWdlV2luZG93WzNdIC0gaW1hZ2VXaW5kb3dbMV07XG4gICAgY29uc3QgbnVtUGl4ZWxzID0gaW1hZ2VXaW5kb3dXaWR0aCAqIGltYWdlV2luZG93SGVpZ2h0O1xuICAgIGNvbnN0IHNhbXBsZXNQZXJQaXhlbCA9IHRoaXMuZ2V0U2FtcGxlc1BlclBpeGVsKCk7XG5cbiAgICBpZiAoIXNhbXBsZXMgfHwgIXNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZXNQZXJQaXhlbDsgKytpKSB7XG4gICAgICAgIHNhbXBsZXMucHVzaChpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChzYW1wbGVzW2ldID49IHNhbXBsZXNQZXJQaXhlbCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBzYW1wbGUgaW5kZXggJyR7c2FtcGxlc1tpXX0nLmApKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsZXQgdmFsdWVBcnJheXM7XG4gICAgaWYgKGludGVybGVhdmUpIHtcbiAgICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuZmlsZURpcmVjdG9yeS5TYW1wbGVGb3JtYXRcbiAgICAgICAgPyBNYXRoLm1heC5hcHBseShudWxsLCB0aGlzLmZpbGVEaXJlY3RvcnkuU2FtcGxlRm9ybWF0KSA6IDE7XG4gICAgICBjb25zdCBiaXRzUGVyU2FtcGxlID0gTWF0aC5tYXguYXBwbHkobnVsbCwgdGhpcy5maWxlRGlyZWN0b3J5LkJpdHNQZXJTYW1wbGUpO1xuICAgICAgdmFsdWVBcnJheXMgPSBhcnJheUZvclR5cGUoZm9ybWF0LCBiaXRzUGVyU2FtcGxlLCBudW1QaXhlbHMgKiBzYW1wbGVzLmxlbmd0aCk7XG4gICAgICBpZiAoZmlsbFZhbHVlKSB7XG4gICAgICAgIHZhbHVlQXJyYXlzLmZpbGwoZmlsbFZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVBcnJheXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2FtcGxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCB2YWx1ZUFycmF5ID0gdGhpcy5nZXRBcnJheUZvclNhbXBsZShzYW1wbGVzW2ldLCBudW1QaXhlbHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmaWxsVmFsdWUpICYmIGkgPCBmaWxsVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsdWVBcnJheS5maWxsKGZpbGxWYWx1ZVtpXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsbFZhbHVlICYmICFBcnJheS5pc0FycmF5KGZpbGxWYWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZUFycmF5LmZpbGwoZmlsbFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZUFycmF5cy5wdXNoKHZhbHVlQXJyYXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHBvb2xPckRlY29kZXIgPSBwb29sIHx8IGF3YWl0IGdldERlY29kZXIodGhpcy5maWxlRGlyZWN0b3J5KTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX3JlYWRSYXN0ZXIoXG4gICAgICBpbWFnZVdpbmRvdywgc2FtcGxlcywgdmFsdWVBcnJheXMsIGludGVybGVhdmUsIHBvb2xPckRlY29kZXIsIHdpZHRoLCBoZWlnaHQsIHJlc2FtcGxlTWV0aG9kLCBzaWduYWwsXG4gICAgKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIHJhc3RlciBkYXRhIGZyb20gdGhlIGltYWdlIGFzIFJHQi4gVGhlIHJlc3VsdCBpcyBhbHdheXMgYW5cbiAgICogaW50ZXJsZWF2ZWQgdHlwZWQgYXJyYXkuXG4gICAqIENvbG9yc3BhY2VzIG90aGVyIHRoYW4gUkdCIHdpbGwgYmUgdHJhbnNmb3JtZWQgdG8gUkdCLCBjb2xvciBtYXBzIGV4cGFuZGVkLlxuICAgKiBXaGVuIG5vIG90aGVyIG1ldGhvZCBpcyBhcHBsaWNhYmxlLCB0aGUgZmlyc3Qgc2FtcGxlIGlzIHVzZWQgdG8gcHJvZHVjZSBhXG4gICAqIGdyYXlzY2FsZSBpbWFnZS5cbiAgICogV2hlbiBwcm92aWRlZCwgb25seSBhIHN1YnNldCBvZiB0aGUgcmFzdGVyIGlzIHJlYWQgZm9yIGVhY2ggc2FtcGxlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3B0aW9ucy53aW5kb3ddIHRoZSBzdWJzZXQgdG8gcmVhZCBkYXRhIGZyb20gaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmludGVybGVhdmU9dHJ1ZV0gd2hldGhlciB0aGUgZGF0YSBzaGFsbCBiZSByZWFkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gb25lIHNpbmdsZSBhcnJheSBvciBzZXBhcmF0ZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5cy5cbiAgICogQHBhcmFtIHtpbXBvcnQoXCIuL2dlb3RpZmZcIikuUG9vbH0gW29wdGlvbnMucG9vbD1udWxsXSBUaGUgb3B0aW9uYWwgZGVjb2RlciBwb29sIHRvIHVzZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLndpZHRoXSBUaGUgZGVzaXJlZCB3aWR0aCBvZiB0aGUgb3V0cHV0LiBXaGVuIHRoZSB3aWR0aCBpcyBubyB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYW1lIGFzIHRoZSBpbWFnZXMsIHJlc2FtcGxpbmcgd2lsbCBiZSBwZXJmb3JtZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5oZWlnaHRdIFRoZSBkZXNpcmVkIGhlaWdodCBvZiB0aGUgb3V0cHV0LiBXaGVuIHRoZSB3aWR0aCBpcyBubyB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2FtZSBhcyB0aGUgaW1hZ2VzLCByZXNhbXBsaW5nIHdpbGwgYmUgcGVyZm9ybWVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucmVzYW1wbGVNZXRob2Q9J25lYXJlc3QnXSBUaGUgZGVzaXJlZCByZXNhbXBsaW5nIG1ldGhvZC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5lbmFibGVBbHBoYT1mYWxzZV0gRW5hYmxlIHJlYWRpbmcgYWxwaGEgY2hhbm5lbCBpZiBwcmVzZW50LlxuICAgKiBAcGFyYW0ge0Fib3J0U2lnbmFsfSBbb3B0aW9ucy5zaWduYWxdIEFuIEFib3J0U2lnbmFsIHRoYXQgbWF5IGJlIHNpZ25hbGxlZCBpZiB0aGUgcmVxdWVzdCBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGJlIGFib3J0ZWRcbiAgICogQHJldHVybnMge1Byb21pc2U8UmVhZFJhc3RlclJlc3VsdD59IHRoZSBSR0IgYXJyYXkgYXMgYSBQcm9taXNlXG4gICAqL1xuICBhc3luYyByZWFkUkdCKHsgd2luZG93LCBpbnRlcmxlYXZlID0gdHJ1ZSwgcG9vbCA9IG51bGwsIHdpZHRoLCBoZWlnaHQsXG4gICAgcmVzYW1wbGVNZXRob2QsIGVuYWJsZUFscGhhID0gZmFsc2UsIHNpZ25hbCB9ID0ge30pIHtcbiAgICBjb25zdCBpbWFnZVdpbmRvdyA9IHdpbmRvdyB8fCBbMCwgMCwgdGhpcy5nZXRXaWR0aCgpLCB0aGlzLmdldEhlaWdodCgpXTtcblxuICAgIC8vIGNoZWNrIHBhcmFtZXRlcnNcbiAgICBpZiAoaW1hZ2VXaW5kb3dbMF0gPiBpbWFnZVdpbmRvd1syXSB8fCBpbWFnZVdpbmRvd1sxXSA+IGltYWdlV2luZG93WzNdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3Vic2V0cycpO1xuICAgIH1cblxuICAgIGNvbnN0IHBpID0gdGhpcy5maWxlRGlyZWN0b3J5LlBob3RvbWV0cmljSW50ZXJwcmV0YXRpb247XG5cbiAgICBpZiAocGkgPT09IHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb25zLlJHQikge1xuICAgICAgbGV0IHMgPSBbMCwgMSwgMl07XG4gICAgICBpZiAoKCEodGhpcy5maWxlRGlyZWN0b3J5LkV4dHJhU2FtcGxlcyA9PT0gRXh0cmFTYW1wbGVzVmFsdWVzLlVuc3BlY2lmaWVkKSkgJiYgZW5hYmxlQWxwaGEpIHtcbiAgICAgICAgcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmlsZURpcmVjdG9yeS5CaXRzUGVyU2FtcGxlLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgcy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5yZWFkUmFzdGVycyh7XG4gICAgICAgIHdpbmRvdyxcbiAgICAgICAgaW50ZXJsZWF2ZSxcbiAgICAgICAgc2FtcGxlczogcyxcbiAgICAgICAgcG9vbCxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgcmVzYW1wbGVNZXRob2QsXG4gICAgICAgIHNpZ25hbCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGxldCBzYW1wbGVzO1xuICAgIHN3aXRjaCAocGkpIHtcbiAgICAgIGNhc2UgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMuV2hpdGVJc1plcm86XG4gICAgICBjYXNlIHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb25zLkJsYWNrSXNaZXJvOlxuICAgICAgY2FzZSBwaG90b21ldHJpY0ludGVycHJldGF0aW9ucy5QYWxldHRlOlxuICAgICAgICBzYW1wbGVzID0gWzBdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMuQ01ZSzpcbiAgICAgICAgc2FtcGxlcyA9IFswLCAxLCAyLCAzXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb25zLllDYkNyOlxuICAgICAgY2FzZSBwaG90b21ldHJpY0ludGVycHJldGF0aW9ucy5DSUVMYWI6XG4gICAgICAgIHNhbXBsZXMgPSBbMCwgMSwgMl07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG9yIHVuc3VwcG9ydGVkIHBob3RvbWV0cmljIGludGVycHJldGF0aW9uLicpO1xuICAgIH1cblxuICAgIGNvbnN0IHN1Yk9wdGlvbnMgPSB7XG4gICAgICB3aW5kb3c6IGltYWdlV2luZG93LFxuICAgICAgaW50ZXJsZWF2ZTogdHJ1ZSxcbiAgICAgIHNhbXBsZXMsXG4gICAgICBwb29sLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICByZXNhbXBsZU1ldGhvZCxcbiAgICAgIHNpZ25hbCxcbiAgICB9O1xuICAgIGNvbnN0IHsgZmlsZURpcmVjdG9yeSB9ID0gdGhpcztcbiAgICBjb25zdCByYXN0ZXIgPSBhd2FpdCB0aGlzLnJlYWRSYXN0ZXJzKHN1Yk9wdGlvbnMpO1xuXG4gICAgY29uc3QgbWF4ID0gMiAqKiB0aGlzLmZpbGVEaXJlY3RvcnkuQml0c1BlclNhbXBsZVswXTtcbiAgICBsZXQgZGF0YTtcbiAgICBzd2l0Y2ggKHBpKSB7XG4gICAgICBjYXNlIHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb25zLldoaXRlSXNaZXJvOlxuICAgICAgICBkYXRhID0gZnJvbVdoaXRlSXNaZXJvKHJhc3RlciwgbWF4KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb25zLkJsYWNrSXNaZXJvOlxuICAgICAgICBkYXRhID0gZnJvbUJsYWNrSXNaZXJvKHJhc3RlciwgbWF4KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHBob3RvbWV0cmljSW50ZXJwcmV0YXRpb25zLlBhbGV0dGU6XG4gICAgICAgIGRhdGEgPSBmcm9tUGFsZXR0ZShyYXN0ZXIsIGZpbGVEaXJlY3RvcnkuQ29sb3JNYXApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMuQ01ZSzpcbiAgICAgICAgZGF0YSA9IGZyb21DTVlLKHJhc3Rlcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBwaG90b21ldHJpY0ludGVycHJldGF0aW9ucy5ZQ2JDcjpcbiAgICAgICAgZGF0YSA9IGZyb21ZQ2JDcihyYXN0ZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMuQ0lFTGFiOlxuICAgICAgICBkYXRhID0gZnJvbUNJRUxhYihyYXN0ZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgcGhvdG9tZXRyaWMgaW50ZXJwcmV0YXRpb24uJyk7XG4gICAgfVxuXG4gICAgLy8gaWYgbm9uLWludGVybGVhdmVkIGRhdGEgaXMgcmVxdWVzdGVkLCB3ZSBtdXN0IHNwbGl0IHRoZSBjaGFubmVsc1xuICAgIC8vIGludG8gdGhlaXIgcmVzcGVjdGl2ZSBhcnJheXNcbiAgICBpZiAoIWludGVybGVhdmUpIHtcbiAgICAgIGNvbnN0IHJlZCA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoIC8gMyk7XG4gICAgICBjb25zdCBncmVlbiA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoIC8gMyk7XG4gICAgICBjb25zdCBibHVlID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggLyAzKTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDMsICsraikge1xuICAgICAgICByZWRbal0gPSBkYXRhW2ldO1xuICAgICAgICBncmVlbltqXSA9IGRhdGFbaSArIDFdO1xuICAgICAgICBibHVlW2pdID0gZGF0YVtpICsgMl07XG4gICAgICB9XG4gICAgICBkYXRhID0gW3JlZCwgZ3JlZW4sIGJsdWVdO1xuICAgIH1cblxuICAgIGRhdGEud2lkdGggPSByYXN0ZXIud2lkdGg7XG4gICAgZGF0YS5oZWlnaHQgPSByYXN0ZXIuaGVpZ2h0O1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgdGllcG9pbnRzLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0W119XG4gICAqL1xuICBnZXRUaWVQb2ludHMoKSB7XG4gICAgaWYgKCF0aGlzLmZpbGVEaXJlY3RvcnkuTW9kZWxUaWVwb2ludCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IHRpZVBvaW50cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maWxlRGlyZWN0b3J5Lk1vZGVsVGllcG9pbnQubGVuZ3RoOyBpICs9IDYpIHtcbiAgICAgIHRpZVBvaW50cy5wdXNoKHtcbiAgICAgICAgaTogdGhpcy5maWxlRGlyZWN0b3J5Lk1vZGVsVGllcG9pbnRbaV0sXG4gICAgICAgIGo6IHRoaXMuZmlsZURpcmVjdG9yeS5Nb2RlbFRpZXBvaW50W2kgKyAxXSxcbiAgICAgICAgazogdGhpcy5maWxlRGlyZWN0b3J5Lk1vZGVsVGllcG9pbnRbaSArIDJdLFxuICAgICAgICB4OiB0aGlzLmZpbGVEaXJlY3RvcnkuTW9kZWxUaWVwb2ludFtpICsgM10sXG4gICAgICAgIHk6IHRoaXMuZmlsZURpcmVjdG9yeS5Nb2RlbFRpZXBvaW50W2kgKyA0XSxcbiAgICAgICAgejogdGhpcy5maWxlRGlyZWN0b3J5Lk1vZGVsVGllcG9pbnRbaSArIDVdLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aWVQb2ludHM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGFyc2VkIEdEQUwgbWV0YWRhdGEgaXRlbXMuXG4gICAqXG4gICAqIElmIHNhbXBsZSBpcyBwYXNzZWQgdG8gbnVsbCwgZGF0YXNldC1sZXZlbCBtZXRhZGF0YSB3aWxsIGJlIHJldHVybmVkLlxuICAgKiBPdGhlcndpc2Ugb25seSBtZXRhZGF0YSBzcGVjaWZpYyB0byB0aGUgcHJvdmlkZWQgc2FtcGxlIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2FtcGxlPW51bGxdIFRoZSBzYW1wbGUgaW5kZXguXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuICBnZXRHREFMTWV0YWRhdGEoc2FtcGxlID0gbnVsbCkge1xuICAgIGNvbnN0IG1ldGFkYXRhID0ge307XG4gICAgaWYgKCF0aGlzLmZpbGVEaXJlY3RvcnkuR0RBTF9NRVRBREFUQSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHN0cmluZyA9IHRoaXMuZmlsZURpcmVjdG9yeS5HREFMX01FVEFEQVRBO1xuXG4gICAgbGV0IGl0ZW1zID0gZmluZFRhZ3NCeU5hbWUoc3RyaW5nLCAnSXRlbScpO1xuXG4gICAgaWYgKHNhbXBsZSA9PT0gbnVsbCkge1xuICAgICAgaXRlbXMgPSBpdGVtcy5maWx0ZXIoKGl0ZW0pID0+IGdldEF0dHJpYnV0ZShpdGVtLCAnc2FtcGxlJykgPT09IHVuZGVmaW5lZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZW1zID0gaXRlbXMuZmlsdGVyKChpdGVtKSA9PiBOdW1iZXIoZ2V0QXR0cmlidXRlKGl0ZW0sICdzYW1wbGUnKSkgPT09IHNhbXBsZSk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgbWV0YWRhdGFbZ2V0QXR0cmlidXRlKGl0ZW0sICduYW1lJyldID0gaXRlbS5pbm5lcjtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIEdEQUwgbm9kYXRhIHZhbHVlXG4gICAqIEByZXR1cm5zIHtudW1iZXJ8bnVsbH1cbiAgICovXG4gIGdldEdEQUxOb0RhdGEoKSB7XG4gICAgaWYgKCF0aGlzLmZpbGVEaXJlY3RvcnkuR0RBTF9OT0RBVEEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzdHJpbmcgPSB0aGlzLmZpbGVEaXJlY3RvcnkuR0RBTF9OT0RBVEE7XG4gICAgcmV0dXJuIE51bWJlcihzdHJpbmcuc3Vic3RyaW5nKDAsIHN0cmluZy5sZW5ndGggLSAxKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW1hZ2Ugb3JpZ2luIGFzIGEgWFlaLXZlY3Rvci4gV2hlbiB0aGUgaW1hZ2UgaGFzIG5vIGFmZmluZVxuICAgKiB0cmFuc2Zvcm1hdGlvbiwgdGhlbiBhbiBleGNlcHRpb24gaXMgdGhyb3duLlxuICAgKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn0gVGhlIG9yaWdpbiBhcyBhIHZlY3RvclxuICAgKi9cbiAgZ2V0T3JpZ2luKCkge1xuICAgIGNvbnN0IHRpZVBvaW50cyA9IHRoaXMuZmlsZURpcmVjdG9yeS5Nb2RlbFRpZXBvaW50O1xuICAgIGNvbnN0IG1vZGVsVHJhbnNmb3JtYXRpb24gPSB0aGlzLmZpbGVEaXJlY3RvcnkuTW9kZWxUcmFuc2Zvcm1hdGlvbjtcbiAgICBpZiAodGllUG9pbnRzICYmIHRpZVBvaW50cy5sZW5ndGggPT09IDYpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHRpZVBvaW50c1szXSxcbiAgICAgICAgdGllUG9pbnRzWzRdLFxuICAgICAgICB0aWVQb2ludHNbNV0sXG4gICAgICBdO1xuICAgIH1cbiAgICBpZiAobW9kZWxUcmFuc2Zvcm1hdGlvbikge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgbW9kZWxUcmFuc2Zvcm1hdGlvblszXSxcbiAgICAgICAgbW9kZWxUcmFuc2Zvcm1hdGlvbls3XSxcbiAgICAgICAgbW9kZWxUcmFuc2Zvcm1hdGlvblsxMV0sXG4gICAgICBdO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbWFnZSBkb2VzIG5vdCBoYXZlIGFuIGFmZmluZSB0cmFuc2Zvcm1hdGlvbi4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbWFnZSByZXNvbHV0aW9uIGFzIGEgWFlaLXZlY3Rvci4gV2hlbiB0aGUgaW1hZ2UgaGFzIG5vIGFmZmluZVxuICAgKiB0cmFuc2Zvcm1hdGlvbiwgdGhlbiBhbiBleGNlcHRpb24gaXMgdGhyb3duLlxuICAgKiBAcGFyYW0ge0dlb1RJRkZJbWFnZX0gW3JlZmVyZW5jZUltYWdlPW51bGxdIEEgcmVmZXJlbmNlIGltYWdlIHRvIGNhbGN1bGF0ZSB0aGUgcmVzb2x1dGlvbiBmcm9tXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gY2FzZXMgd2hlbiB0aGUgY3VycmVudCBpbWFnZSBkb2VzIG5vdCBoYXZlIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkIHRhZ3Mgb24gaXRzIG93bi5cbiAgICogQHJldHVybnMge0FycmF5PG51bWJlcj59IFRoZSByZXNvbHV0aW9uIGFzIGEgdmVjdG9yXG4gICAqL1xuICBnZXRSZXNvbHV0aW9uKHJlZmVyZW5jZUltYWdlID0gbnVsbCkge1xuICAgIGNvbnN0IG1vZGVsUGl4ZWxTY2FsZSA9IHRoaXMuZmlsZURpcmVjdG9yeS5Nb2RlbFBpeGVsU2NhbGU7XG4gICAgY29uc3QgbW9kZWxUcmFuc2Zvcm1hdGlvbiA9IHRoaXMuZmlsZURpcmVjdG9yeS5Nb2RlbFRyYW5zZm9ybWF0aW9uO1xuXG4gICAgaWYgKG1vZGVsUGl4ZWxTY2FsZSkge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgbW9kZWxQaXhlbFNjYWxlWzBdLFxuICAgICAgICAtbW9kZWxQaXhlbFNjYWxlWzFdLFxuICAgICAgICBtb2RlbFBpeGVsU2NhbGVbMl0sXG4gICAgICBdO1xuICAgIH1cbiAgICBpZiAobW9kZWxUcmFuc2Zvcm1hdGlvbikge1xuICAgICAgaWYgKG1vZGVsVHJhbnNmb3JtYXRpb25bMV0gPT09IDAgJiYgbW9kZWxUcmFuc2Zvcm1hdGlvbls0XSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIG1vZGVsVHJhbnNmb3JtYXRpb25bMF0sXG4gICAgICAgICAgLW1vZGVsVHJhbnNmb3JtYXRpb25bNV0sXG4gICAgICAgICAgbW9kZWxUcmFuc2Zvcm1hdGlvblsxMF0sXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICByZXR1cm4gW1xuICAgICAgICBNYXRoLnNxcnQoKG1vZGVsVHJhbnNmb3JtYXRpb25bMF0gKiBtb2RlbFRyYW5zZm9ybWF0aW9uWzBdKVxuICAgICAgICAgICsgKG1vZGVsVHJhbnNmb3JtYXRpb25bNF0gKiBtb2RlbFRyYW5zZm9ybWF0aW9uWzRdKSksXG4gICAgICAgIC1NYXRoLnNxcnQoKG1vZGVsVHJhbnNmb3JtYXRpb25bMV0gKiBtb2RlbFRyYW5zZm9ybWF0aW9uWzFdKVxuICAgICAgICAgICsgKG1vZGVsVHJhbnNmb3JtYXRpb25bNV0gKiBtb2RlbFRyYW5zZm9ybWF0aW9uWzVdKSksXG4gICAgICAgIG1vZGVsVHJhbnNmb3JtYXRpb25bMTBdXTtcbiAgICB9XG5cbiAgICBpZiAocmVmZXJlbmNlSW1hZ2UpIHtcbiAgICAgIGNvbnN0IFtyZWZSZXNYLCByZWZSZXNZLCByZWZSZXNaXSA9IHJlZmVyZW5jZUltYWdlLmdldFJlc29sdXRpb24oKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHJlZlJlc1ggKiByZWZlcmVuY2VJbWFnZS5nZXRXaWR0aCgpIC8gdGhpcy5nZXRXaWR0aCgpLFxuICAgICAgICByZWZSZXNZICogcmVmZXJlbmNlSW1hZ2UuZ2V0SGVpZ2h0KCkgLyB0aGlzLmdldEhlaWdodCgpLFxuICAgICAgICByZWZSZXNaICogcmVmZXJlbmNlSW1hZ2UuZ2V0V2lkdGgoKSAvIHRoaXMuZ2V0V2lkdGgoKSxcbiAgICAgIF07XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgaW1hZ2UgZG9lcyBub3QgaGF2ZSBhbiBhZmZpbmUgdHJhbnNmb3JtYXRpb24uJyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcGl4ZWxzIG9mIHRoZSBpbWFnZSBkZXBpY3QgYW4gYXJlYSAob3IgcG9pbnQpLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gV2hldGhlciB0aGUgcGl4ZWxzIGFyZSBhIHBvaW50XG4gICAqL1xuICBwaXhlbElzQXJlYSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9LZXlzLkdUUmFzdGVyVHlwZUdlb0tleSA9PT0gMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbWFnZSBib3VuZGluZyBib3ggYXMgYW4gYXJyYXkgb2YgNCB2YWx1ZXM6IG1pbi14LCBtaW4teSxcbiAgICogbWF4LXggYW5kIG1heC15LiBXaGVuIHRoZSBpbWFnZSBoYXMgbm8gYWZmaW5lIHRyYW5zZm9ybWF0aW9uLCB0aGVuIGFuXG4gICAqIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3RpbGVncmlkPWZhbHNlXSBJZiB0cnVlIHJldHVybiBleHRlbnQgZm9yIGEgdGlsZWdyaWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGhvdXQgYWRqdXN0bWVudCBmb3IgTW9kZWxUcmFuc2Zvcm1hdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5PG51bWJlcj59IFRoZSBib3VuZGluZyBib3hcbiAgICovXG4gIGdldEJvdW5kaW5nQm94KHRpbGVncmlkID0gZmFsc2UpIHtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpO1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xuXG4gICAgaWYgKHRoaXMuZmlsZURpcmVjdG9yeS5Nb2RlbFRyYW5zZm9ybWF0aW9uICYmICF0aWxlZ3JpZCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICBjb25zdCBbYSwgYiwgYywgZCwgZSwgZiwgZywgaF0gPSB0aGlzLmZpbGVEaXJlY3RvcnkuTW9kZWxUcmFuc2Zvcm1hdGlvbjtcblxuICAgICAgY29uc3QgY29ybmVycyA9IFtcbiAgICAgICAgWzAsIDBdLFxuICAgICAgICBbMCwgaGVpZ2h0XSxcbiAgICAgICAgW3dpZHRoLCAwXSxcbiAgICAgICAgW3dpZHRoLCBoZWlnaHRdLFxuICAgICAgXTtcblxuICAgICAgY29uc3QgcHJvamVjdGVkID0gY29ybmVycy5tYXAoKFtJLCBKXSkgPT4gW1xuICAgICAgICBkICsgKGEgKiBJKSArIChiICogSiksXG4gICAgICAgIGggKyAoZSAqIEkpICsgKGYgKiBKKSxcbiAgICAgIF0pO1xuXG4gICAgICBjb25zdCB4cyA9IHByb2plY3RlZC5tYXAoKHB0KSA9PiBwdFswXSk7XG4gICAgICBjb25zdCB5cyA9IHByb2plY3RlZC5tYXAoKHB0KSA9PiBwdFsxXSk7XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIE1hdGgubWluKC4uLnhzKSxcbiAgICAgICAgTWF0aC5taW4oLi4ueXMpLFxuICAgICAgICBNYXRoLm1heCguLi54cyksXG4gICAgICAgIE1hdGgubWF4KC4uLnlzKSxcbiAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9yaWdpbiA9IHRoaXMuZ2V0T3JpZ2luKCk7XG4gICAgICBjb25zdCByZXNvbHV0aW9uID0gdGhpcy5nZXRSZXNvbHV0aW9uKCk7XG5cbiAgICAgIGNvbnN0IHgxID0gb3JpZ2luWzBdO1xuICAgICAgY29uc3QgeTEgPSBvcmlnaW5bMV07XG5cbiAgICAgIGNvbnN0IHgyID0geDEgKyAocmVzb2x1dGlvblswXSAqIHdpZHRoKTtcbiAgICAgIGNvbnN0IHkyID0geTEgKyAocmVzb2x1dGlvblsxXSAqIGhlaWdodCk7XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIE1hdGgubWluKHgxLCB4MiksXG4gICAgICAgIE1hdGgubWluKHkxLCB5MiksXG4gICAgICAgIE1hdGgubWF4KHgxLCB4MiksXG4gICAgICAgIE1hdGgubWF4KHkxLCB5MiksXG4gICAgICBdO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBHZW9USUZGSW1hZ2U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/geotiffimage.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/geotiffwriter.js":
/*!***********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/geotiffwriter.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   writeGeotiff: () => (/* binding */ writeGeotiff)\n/* harmony export */ });\n/* harmony import */ var _globals_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./globals.js */ \"./node_modules/geotiff/dist-module/globals.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/geotiff/dist-module/utils.js\");\n/*\n  Some parts of this file are based on UTIF.js,\n  which was released under the MIT License.\n  You can view that here:\n  https://github.com/photopea/UTIF.js/blob/master/LICENSE\n*/\n\n\n\nconst tagName2Code = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.invert)(_globals_js__WEBPACK_IMPORTED_MODULE_1__.fieldTagNames);\nconst geoKeyName2Code = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.invert)(_globals_js__WEBPACK_IMPORTED_MODULE_1__.geoKeyNames);\nconst name2code = {};\n(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.assign)(name2code, tagName2Code);\n(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.assign)(name2code, geoKeyName2Code);\nconst typeName2byte = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.invert)(_globals_js__WEBPACK_IMPORTED_MODULE_1__.fieldTypeNames);\n\n// config variables\nconst numBytesInIfd = 1000;\n\nconst _binBE = {\n  nextZero: (data, o) => {\n    let oincr = o;\n    while (data[oincr] !== 0) {\n      oincr++;\n    }\n    return oincr;\n  },\n  readUshort: (buff, p) => {\n    return (buff[p] << 8) | buff[p + 1];\n  },\n  readShort: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 1];\n    a[1] = buff[p + 0];\n    return _binBE.i16[0];\n  },\n  readInt: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.i32[0];\n  },\n  readUint: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.ui32[0];\n  },\n  readASCII: (buff, p, l) => {\n    return l.map((i) => String.fromCharCode(buff[p + i])).join('');\n  },\n  readFloat: (buff, p) => {\n    const a = _binBE.ui8;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(4, (i) => {\n      a[i] = buff[p + 3 - i];\n    });\n    return _binBE.fl32[0];\n  },\n  readDouble: (buff, p) => {\n    const a = _binBE.ui8;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(8, (i) => {\n      a[i] = buff[p + 7 - i];\n    });\n    return _binBE.fl64[0];\n  },\n  writeUshort: (buff, p, n) => {\n    buff[p] = (n >> 8) & 255;\n    buff[p + 1] = n & 255;\n  },\n  writeUint: (buff, p, n) => {\n    buff[p] = (n >> 24) & 255;\n    buff[p + 1] = (n >> 16) & 255;\n    buff[p + 2] = (n >> 8) & 255;\n    buff[p + 3] = (n >> 0) & 255;\n  },\n  writeASCII: (buff, p, s) => {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(s.length, (i) => {\n      buff[p + i] = s.charCodeAt(i);\n    });\n  },\n  ui8: new Uint8Array(8),\n};\n\n_binBE.fl64 = new Float64Array(_binBE.ui8.buffer);\n\n_binBE.writeDouble = (buff, p, n) => {\n  _binBE.fl64[0] = n;\n  (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(8, (i) => {\n    buff[p + i] = _binBE.ui8[7 - i];\n  });\n};\n\nconst _writeIFD = (bin, data, _offset, ifd) => {\n  let offset = _offset;\n\n  const keys = Object.keys(ifd).filter((key) => {\n    return key !== undefined && key !== null && key !== 'undefined';\n  });\n\n  bin.writeUshort(data, offset, keys.length);\n  offset += 2;\n\n  let eoff = offset + (12 * keys.length) + 4;\n\n  for (const key of keys) {\n    let tag = null;\n    if (typeof key === 'number') {\n      tag = key;\n    } else if (typeof key === 'string') {\n      tag = parseInt(key, 10);\n    }\n\n    const typeName = _globals_js__WEBPACK_IMPORTED_MODULE_1__.fieldTagTypes[tag];\n    const typeNum = typeName2byte[typeName];\n\n    if (typeName == null || typeName === undefined || typeof typeName === 'undefined') {\n      throw new Error(`unknown type of tag: ${tag}`);\n    }\n\n    let val = ifd[key];\n\n    if (val === undefined) {\n      throw new Error(`failed to get value for key ${key}`);\n    }\n\n    // ASCIIZ format with trailing 0 character\n    // http://www.fileformat.info/format/tiff/corion.htm\n    // https://stackoverflow.com/questions/7783044/whats-the-difference-between-asciiz-vs-ascii\n    if (typeName === 'ASCII' && typeof val === 'string' && (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.endsWith)(val, '\\u0000') === false) {\n      val += '\\u0000';\n    }\n\n    const num = val.length;\n\n    bin.writeUshort(data, offset, tag);\n    offset += 2;\n\n    bin.writeUshort(data, offset, typeNum);\n    offset += 2;\n\n    bin.writeUint(data, offset, num);\n    offset += 4;\n\n    let dlen = [-1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8][typeNum] * num;\n    let toff = offset;\n\n    if (dlen > 4) {\n      bin.writeUint(data, offset, eoff);\n      toff = eoff;\n    }\n\n    if (typeName === 'ASCII') {\n      bin.writeASCII(data, toff, val);\n    } else if (typeName === 'SHORT') {\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(num, (i) => {\n        bin.writeUshort(data, toff + (2 * i), val[i]);\n      });\n    } else if (typeName === 'LONG') {\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(num, (i) => {\n        bin.writeUint(data, toff + (4 * i), val[i]);\n      });\n    } else if (typeName === 'RATIONAL') {\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(num, (i) => {\n        bin.writeUint(data, toff + (8 * i), Math.round(val[i] * 10000));\n        bin.writeUint(data, toff + (8 * i) + 4, 10000);\n      });\n    } else if (typeName === 'DOUBLE') {\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(num, (i) => {\n        bin.writeDouble(data, toff + (8 * i), val[i]);\n      });\n    }\n\n    if (dlen > 4) {\n      dlen += (dlen & 1);\n      eoff += dlen;\n    }\n\n    offset += 4;\n  }\n\n  return [offset, eoff];\n};\n\nconst encodeIfds = (ifds) => {\n  const data = new Uint8Array(numBytesInIfd);\n  let offset = 4;\n  const bin = _binBE;\n\n  // set big-endian byte-order\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[0] = 77;\n  data[1] = 77;\n\n  // set format-version number\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[3] = 42;\n\n  let ifdo = 8;\n\n  bin.writeUint(data, offset, ifdo);\n\n  offset += 4;\n\n  ifds.forEach((ifd, i) => {\n    const noffs = _writeIFD(bin, data, ifdo, ifd);\n    ifdo = noffs[1];\n    if (i < ifds.length - 1) {\n      bin.writeUint(data, noffs[0], ifdo);\n    }\n  });\n\n  if (data.slice) {\n    return data.slice(0, ifdo).buffer;\n  }\n\n  // node hasn't implemented slice on Uint8Array yet\n  const result = new Uint8Array(ifdo);\n  for (let i = 0; i < ifdo; i++) {\n    result[i] = data[i];\n  }\n  return result.buffer;\n};\n\nconst encodeImage = (values, width, height, metadata) => {\n  if (height === undefined || height === null) {\n    throw new Error(`you passed into encodeImage a width of type ${height}`);\n  }\n\n  if (width === undefined || width === null) {\n    throw new Error(`you passed into encodeImage a width of type ${width}`);\n  }\n\n  const ifd = {\n    256: [width], // ImageWidth\n    257: [height], // ImageLength\n    273: [numBytesInIfd], // strips offset\n    278: [height], // RowsPerStrip\n    305: 'geotiff.js', // no array for ASCII(Z)\n  };\n\n  if (metadata) {\n    for (const i in metadata) {\n      if (metadata.hasOwnProperty(i)) {\n        ifd[i] = metadata[i];\n      }\n    }\n  }\n\n  const prfx = new Uint8Array(encodeIfds([ifd]));\n\n  const img = new Uint8Array(values);\n\n  const samplesPerPixel = ifd[277];\n\n  const data = new Uint8Array(numBytesInIfd + (width * height * samplesPerPixel));\n  (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(prfx.length, (i) => {\n    data[i] = prfx[i];\n  });\n  (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.forEach)(img, (value, i) => {\n    data[numBytesInIfd + i] = value;\n  });\n\n  return data.buffer;\n};\n\nconst convertToTids = (input) => {\n  const result = {};\n  for (const key in input) {\n    if (key !== 'StripOffsets') {\n      if (!name2code[key]) {\n        console.error(key, 'not in name2code:', Object.keys(name2code));\n      }\n      result[name2code[key]] = input[key];\n    }\n  }\n  return result;\n};\n\nconst toArray = (input) => {\n  if (Array.isArray(input)) {\n    return input;\n  }\n  return [input];\n};\n\nconst metadataDefaults = [\n  ['Compression', 1], // no compression\n  ['PlanarConfiguration', 1],\n  ['ExtraSamples', 0],\n];\n\nfunction writeGeotiff(data, metadata) {\n  const isFlattened = typeof data[0] === 'number';\n\n  let height;\n  let numBands;\n  let width;\n  let flattenedValues;\n\n  if (isFlattened) {\n    height = metadata.height || metadata.ImageLength;\n    width = metadata.width || metadata.ImageWidth;\n    numBands = data.length / (height * width);\n    flattenedValues = data;\n  } else {\n    numBands = data.length;\n    height = data[0].length;\n    width = data[0][0].length;\n    flattenedValues = [];\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(height, (rowIndex) => {\n      (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(width, (columnIndex) => {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(numBands, (bandIndex) => {\n          flattenedValues.push(data[bandIndex][rowIndex][columnIndex]);\n        });\n      });\n    });\n  }\n\n  metadata.ImageLength = height;\n  delete metadata.height;\n  metadata.ImageWidth = width;\n  delete metadata.width;\n\n  // consult https://www.loc.gov/preservation/digital/formats/content/tiff_tags.shtml\n\n  if (!metadata.BitsPerSample) {\n    metadata.BitsPerSample = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(numBands, () => 8);\n  }\n\n  metadataDefaults.forEach((tag) => {\n    const key = tag[0];\n    if (!metadata[key]) {\n      const value = tag[1];\n      metadata[key] = value;\n    }\n  });\n\n  // The color space of the image data.\n  // 1=black is zero and 2=RGB.\n  if (!metadata.PhotometricInterpretation) {\n    metadata.PhotometricInterpretation = metadata.BitsPerSample.length === 3 ? 2 : 1;\n  }\n\n  // The number of components per pixel.\n  if (!metadata.SamplesPerPixel) {\n    metadata.SamplesPerPixel = [numBands];\n  }\n\n  if (!metadata.StripByteCounts) {\n    // we are only writing one strip\n    metadata.StripByteCounts = [numBands * height * width];\n  }\n\n  if (!metadata.ModelPixelScale) {\n    // assumes raster takes up exactly the whole globe\n    metadata.ModelPixelScale = [360 / width, 180 / height, 0];\n  }\n\n  if (!metadata.SampleFormat) {\n    metadata.SampleFormat = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.times)(numBands, () => 1);\n  }\n\n  // if didn't pass in projection information, assume the popular 4326 \"geographic projection\"\n  if (!metadata.hasOwnProperty('GeographicTypeGeoKey') && !metadata.hasOwnProperty('ProjectedCSTypeGeoKey')) {\n    metadata.GeographicTypeGeoKey = 4326;\n    metadata.ModelTiepoint = [0, 0, 0, -180, 90, 0]; // raster fits whole globe\n    metadata.GeogCitationGeoKey = 'WGS 84';\n    metadata.GTModelTypeGeoKey = 2;\n  }\n\n  const geoKeys = Object.keys(metadata)\n    .filter((key) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.endsWith)(key, 'GeoKey'))\n    .sort((a, b) => name2code[a] - name2code[b]);\n\n  if (!metadata.GeoAsciiParams) {\n    let geoAsciiParams = '';\n    geoKeys.forEach((name) => {\n      const code = Number(name2code[name]);\n      const tagType = _globals_js__WEBPACK_IMPORTED_MODULE_1__.fieldTagTypes[code];\n      if (tagType === 'ASCII') {\n        geoAsciiParams += `${metadata[name].toString()}\\u0000`;\n      }\n    });\n    if (geoAsciiParams.length > 0) {\n      metadata.GeoAsciiParams = geoAsciiParams;\n    }\n  }\n\n  if (!metadata.GeoKeyDirectory) {\n    const NumberOfKeys = geoKeys.length;\n\n    const GeoKeyDirectory = [1, 1, 0, NumberOfKeys];\n    geoKeys.forEach((geoKey) => {\n      const KeyID = Number(name2code[geoKey]);\n      GeoKeyDirectory.push(KeyID);\n\n      let Count;\n      let TIFFTagLocation;\n      let valueOffset;\n      if (_globals_js__WEBPACK_IMPORTED_MODULE_1__.fieldTagTypes[KeyID] === 'SHORT') {\n        Count = 1;\n        TIFFTagLocation = 0;\n        valueOffset = metadata[geoKey];\n      } else if (geoKey === 'GeogCitationGeoKey') {\n        Count = metadata.GeoAsciiParams.length;\n        TIFFTagLocation = Number(name2code.GeoAsciiParams);\n        valueOffset = 0;\n      } else {\n        console.log(`[geotiff.js] couldn't get TIFFTagLocation for ${geoKey}`);\n      }\n      GeoKeyDirectory.push(TIFFTagLocation);\n      GeoKeyDirectory.push(Count);\n      GeoKeyDirectory.push(valueOffset);\n    });\n    metadata.GeoKeyDirectory = GeoKeyDirectory;\n  }\n\n  // delete GeoKeys from metadata, because stored in GeoKeyDirectory tag\n  for (const geoKey of geoKeys) {\n    if (metadata.hasOwnProperty(geoKey)) {\n      delete metadata[geoKey];\n    }\n  }\n\n  [\n    'Compression',\n    'ExtraSamples',\n    'GeographicTypeGeoKey',\n    'GTModelTypeGeoKey',\n    'GTRasterTypeGeoKey',\n    'ImageLength', // synonym of ImageHeight\n    'ImageWidth',\n    'Orientation',\n    'PhotometricInterpretation',\n    'ProjectedCSTypeGeoKey',\n    'PlanarConfiguration',\n    'ResolutionUnit',\n    'SamplesPerPixel',\n    'XPosition',\n    'YPosition',\n    'RowsPerStrip',\n  ].forEach((name) => {\n    if (metadata[name]) {\n      metadata[name] = toArray(metadata[name]);\n    }\n  });\n\n  const encodedMetadata = convertToTids(metadata);\n\n  const outputImage = encodeImage(flattenedValues, width, height, encodedMetadata);\n\n  return outputImage;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9nZW90aWZmd3JpdGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVycmlhanMtbWFwLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvZ2VvdGlmZndyaXRlci5qcz9jNzRjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gIFNvbWUgcGFydHMgb2YgdGhpcyBmaWxlIGFyZSBiYXNlZCBvbiBVVElGLmpzLFxuICB3aGljaCB3YXMgcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICBZb3UgY2FuIHZpZXcgdGhhdCBoZXJlOlxuICBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9wZWEvVVRJRi5qcy9ibG9iL21hc3Rlci9MSUNFTlNFXG4qL1xuaW1wb3J0IHsgZmllbGRUYWdOYW1lcywgZmllbGRUYWdUeXBlcywgZmllbGRUeXBlTmFtZXMsIGdlb0tleU5hbWVzIH0gZnJvbSAnLi9nbG9iYWxzLmpzJztcbmltcG9ydCB7IGFzc2lnbiwgZW5kc1dpdGgsIGZvckVhY2gsIGludmVydCwgdGltZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcblxuY29uc3QgdGFnTmFtZTJDb2RlID0gaW52ZXJ0KGZpZWxkVGFnTmFtZXMpO1xuY29uc3QgZ2VvS2V5TmFtZTJDb2RlID0gaW52ZXJ0KGdlb0tleU5hbWVzKTtcbmNvbnN0IG5hbWUyY29kZSA9IHt9O1xuYXNzaWduKG5hbWUyY29kZSwgdGFnTmFtZTJDb2RlKTtcbmFzc2lnbihuYW1lMmNvZGUsIGdlb0tleU5hbWUyQ29kZSk7XG5jb25zdCB0eXBlTmFtZTJieXRlID0gaW52ZXJ0KGZpZWxkVHlwZU5hbWVzKTtcblxuLy8gY29uZmlnIHZhcmlhYmxlc1xuY29uc3QgbnVtQnl0ZXNJbklmZCA9IDEwMDA7XG5cbmNvbnN0IF9iaW5CRSA9IHtcbiAgbmV4dFplcm86IChkYXRhLCBvKSA9PiB7XG4gICAgbGV0IG9pbmNyID0gbztcbiAgICB3aGlsZSAoZGF0YVtvaW5jcl0gIT09IDApIHtcbiAgICAgIG9pbmNyKys7XG4gICAgfVxuICAgIHJldHVybiBvaW5jcjtcbiAgfSxcbiAgcmVhZFVzaG9ydDogKGJ1ZmYsIHApID0+IHtcbiAgICByZXR1cm4gKGJ1ZmZbcF0gPDwgOCkgfCBidWZmW3AgKyAxXTtcbiAgfSxcbiAgcmVhZFNob3J0OiAoYnVmZiwgcCkgPT4ge1xuICAgIGNvbnN0IGEgPSBfYmluQkUudWk4O1xuICAgIGFbMF0gPSBidWZmW3AgKyAxXTtcbiAgICBhWzFdID0gYnVmZltwICsgMF07XG4gICAgcmV0dXJuIF9iaW5CRS5pMTZbMF07XG4gIH0sXG4gIHJlYWRJbnQ6IChidWZmLCBwKSA9PiB7XG4gICAgY29uc3QgYSA9IF9iaW5CRS51aTg7XG4gICAgYVswXSA9IGJ1ZmZbcCArIDNdO1xuICAgIGFbMV0gPSBidWZmW3AgKyAyXTtcbiAgICBhWzJdID0gYnVmZltwICsgMV07XG4gICAgYVszXSA9IGJ1ZmZbcCArIDBdO1xuICAgIHJldHVybiBfYmluQkUuaTMyWzBdO1xuICB9LFxuICByZWFkVWludDogKGJ1ZmYsIHApID0+IHtcbiAgICBjb25zdCBhID0gX2JpbkJFLnVpODtcbiAgICBhWzBdID0gYnVmZltwICsgM107XG4gICAgYVsxXSA9IGJ1ZmZbcCArIDJdO1xuICAgIGFbMl0gPSBidWZmW3AgKyAxXTtcbiAgICBhWzNdID0gYnVmZltwICsgMF07XG4gICAgcmV0dXJuIF9iaW5CRS51aTMyWzBdO1xuICB9LFxuICByZWFkQVNDSUk6IChidWZmLCBwLCBsKSA9PiB7XG4gICAgcmV0dXJuIGwubWFwKChpKSA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZmZbcCArIGldKSkuam9pbignJyk7XG4gIH0sXG4gIHJlYWRGbG9hdDogKGJ1ZmYsIHApID0+IHtcbiAgICBjb25zdCBhID0gX2JpbkJFLnVpODtcbiAgICB0aW1lcyg0LCAoaSkgPT4ge1xuICAgICAgYVtpXSA9IGJ1ZmZbcCArIDMgLSBpXTtcbiAgICB9KTtcbiAgICByZXR1cm4gX2JpbkJFLmZsMzJbMF07XG4gIH0sXG4gIHJlYWREb3VibGU6IChidWZmLCBwKSA9PiB7XG4gICAgY29uc3QgYSA9IF9iaW5CRS51aTg7XG4gICAgdGltZXMoOCwgKGkpID0+IHtcbiAgICAgIGFbaV0gPSBidWZmW3AgKyA3IC0gaV07XG4gICAgfSk7XG4gICAgcmV0dXJuIF9iaW5CRS5mbDY0WzBdO1xuICB9LFxuICB3cml0ZVVzaG9ydDogKGJ1ZmYsIHAsIG4pID0+IHtcbiAgICBidWZmW3BdID0gKG4gPj4gOCkgJiAyNTU7XG4gICAgYnVmZltwICsgMV0gPSBuICYgMjU1O1xuICB9LFxuICB3cml0ZVVpbnQ6IChidWZmLCBwLCBuKSA9PiB7XG4gICAgYnVmZltwXSA9IChuID4+IDI0KSAmIDI1NTtcbiAgICBidWZmW3AgKyAxXSA9IChuID4+IDE2KSAmIDI1NTtcbiAgICBidWZmW3AgKyAyXSA9IChuID4+IDgpICYgMjU1O1xuICAgIGJ1ZmZbcCArIDNdID0gKG4gPj4gMCkgJiAyNTU7XG4gIH0sXG4gIHdyaXRlQVNDSUk6IChidWZmLCBwLCBzKSA9PiB7XG4gICAgdGltZXMocy5sZW5ndGgsIChpKSA9PiB7XG4gICAgICBidWZmW3AgKyBpXSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICB9KTtcbiAgfSxcbiAgdWk4OiBuZXcgVWludDhBcnJheSg4KSxcbn07XG5cbl9iaW5CRS5mbDY0ID0gbmV3IEZsb2F0NjRBcnJheShfYmluQkUudWk4LmJ1ZmZlcik7XG5cbl9iaW5CRS53cml0ZURvdWJsZSA9IChidWZmLCBwLCBuKSA9PiB7XG4gIF9iaW5CRS5mbDY0WzBdID0gbjtcbiAgdGltZXMoOCwgKGkpID0+IHtcbiAgICBidWZmW3AgKyBpXSA9IF9iaW5CRS51aThbNyAtIGldO1xuICB9KTtcbn07XG5cbmNvbnN0IF93cml0ZUlGRCA9IChiaW4sIGRhdGEsIF9vZmZzZXQsIGlmZCkgPT4ge1xuICBsZXQgb2Zmc2V0ID0gX29mZnNldDtcblxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaWZkKS5maWx0ZXIoKGtleSkgPT4ge1xuICAgIHJldHVybiBrZXkgIT09IHVuZGVmaW5lZCAmJiBrZXkgIT09IG51bGwgJiYga2V5ICE9PSAndW5kZWZpbmVkJztcbiAgfSk7XG5cbiAgYmluLndyaXRlVXNob3J0KGRhdGEsIG9mZnNldCwga2V5cy5sZW5ndGgpO1xuICBvZmZzZXQgKz0gMjtcblxuICBsZXQgZW9mZiA9IG9mZnNldCArICgxMiAqIGtleXMubGVuZ3RoKSArIDQ7XG5cbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGxldCB0YWcgPSBudWxsO1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnbnVtYmVyJykge1xuICAgICAgdGFnID0ga2V5O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRhZyA9IHBhcnNlSW50KGtleSwgMTApO1xuICAgIH1cblxuICAgIGNvbnN0IHR5cGVOYW1lID0gZmllbGRUYWdUeXBlc1t0YWddO1xuICAgIGNvbnN0IHR5cGVOdW0gPSB0eXBlTmFtZTJieXRlW3R5cGVOYW1lXTtcblxuICAgIGlmICh0eXBlTmFtZSA9PSBudWxsIHx8IHR5cGVOYW1lID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGVOYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHR5cGUgb2YgdGFnOiAke3RhZ31gKTtcbiAgICB9XG5cbiAgICBsZXQgdmFsID0gaWZkW2tleV07XG5cbiAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGdldCB2YWx1ZSBmb3Iga2V5ICR7a2V5fWApO1xuICAgIH1cblxuICAgIC8vIEFTQ0lJWiBmb3JtYXQgd2l0aCB0cmFpbGluZyAwIGNoYXJhY3RlclxuICAgIC8vIGh0dHA6Ly93d3cuZmlsZWZvcm1hdC5pbmZvL2Zvcm1hdC90aWZmL2Nvcmlvbi5odG1cbiAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83NzgzMDQ0L3doYXRzLXRoZS1kaWZmZXJlbmNlLWJldHdlZW4tYXNjaWl6LXZzLWFzY2lpXG4gICAgaWYgKHR5cGVOYW1lID09PSAnQVNDSUknICYmIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnICYmIGVuZHNXaXRoKHZhbCwgJ1xcdTAwMDAnKSA9PT0gZmFsc2UpIHtcbiAgICAgIHZhbCArPSAnXFx1MDAwMCc7XG4gICAgfVxuXG4gICAgY29uc3QgbnVtID0gdmFsLmxlbmd0aDtcblxuICAgIGJpbi53cml0ZVVzaG9ydChkYXRhLCBvZmZzZXQsIHRhZyk7XG4gICAgb2Zmc2V0ICs9IDI7XG5cbiAgICBiaW4ud3JpdGVVc2hvcnQoZGF0YSwgb2Zmc2V0LCB0eXBlTnVtKTtcbiAgICBvZmZzZXQgKz0gMjtcblxuICAgIGJpbi53cml0ZVVpbnQoZGF0YSwgb2Zmc2V0LCBudW0pO1xuICAgIG9mZnNldCArPSA0O1xuXG4gICAgbGV0IGRsZW4gPSBbLTEsIDEsIDEsIDIsIDQsIDgsIDAsIDAsIDAsIDAsIDAsIDAsIDhdW3R5cGVOdW1dICogbnVtO1xuICAgIGxldCB0b2ZmID0gb2Zmc2V0O1xuXG4gICAgaWYgKGRsZW4gPiA0KSB7XG4gICAgICBiaW4ud3JpdGVVaW50KGRhdGEsIG9mZnNldCwgZW9mZik7XG4gICAgICB0b2ZmID0gZW9mZjtcbiAgICB9XG5cbiAgICBpZiAodHlwZU5hbWUgPT09ICdBU0NJSScpIHtcbiAgICAgIGJpbi53cml0ZUFTQ0lJKGRhdGEsIHRvZmYsIHZhbCk7XG4gICAgfSBlbHNlIGlmICh0eXBlTmFtZSA9PT0gJ1NIT1JUJykge1xuICAgICAgdGltZXMobnVtLCAoaSkgPT4ge1xuICAgICAgICBiaW4ud3JpdGVVc2hvcnQoZGF0YSwgdG9mZiArICgyICogaSksIHZhbFtpXSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVOYW1lID09PSAnTE9ORycpIHtcbiAgICAgIHRpbWVzKG51bSwgKGkpID0+IHtcbiAgICAgICAgYmluLndyaXRlVWludChkYXRhLCB0b2ZmICsgKDQgKiBpKSwgdmFsW2ldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZU5hbWUgPT09ICdSQVRJT05BTCcpIHtcbiAgICAgIHRpbWVzKG51bSwgKGkpID0+IHtcbiAgICAgICAgYmluLndyaXRlVWludChkYXRhLCB0b2ZmICsgKDggKiBpKSwgTWF0aC5yb3VuZCh2YWxbaV0gKiAxMDAwMCkpO1xuICAgICAgICBiaW4ud3JpdGVVaW50KGRhdGEsIHRvZmYgKyAoOCAqIGkpICsgNCwgMTAwMDApO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlTmFtZSA9PT0gJ0RPVUJMRScpIHtcbiAgICAgIHRpbWVzKG51bSwgKGkpID0+IHtcbiAgICAgICAgYmluLndyaXRlRG91YmxlKGRhdGEsIHRvZmYgKyAoOCAqIGkpLCB2YWxbaV0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGRsZW4gPiA0KSB7XG4gICAgICBkbGVuICs9IChkbGVuICYgMSk7XG4gICAgICBlb2ZmICs9IGRsZW47XG4gICAgfVxuXG4gICAgb2Zmc2V0ICs9IDQ7XG4gIH1cblxuICByZXR1cm4gW29mZnNldCwgZW9mZl07XG59O1xuXG5jb25zdCBlbmNvZGVJZmRzID0gKGlmZHMpID0+IHtcbiAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KG51bUJ5dGVzSW5JZmQpO1xuICBsZXQgb2Zmc2V0ID0gNDtcbiAgY29uc3QgYmluID0gX2JpbkJFO1xuXG4gIC8vIHNldCBiaWctZW5kaWFuIGJ5dGUtb3JkZXJcbiAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVElGRiNCeXRlX29yZGVyXG4gIGRhdGFbMF0gPSA3NztcbiAgZGF0YVsxXSA9IDc3O1xuXG4gIC8vIHNldCBmb3JtYXQtdmVyc2lvbiBudW1iZXJcbiAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVElGRiNCeXRlX29yZGVyXG4gIGRhdGFbM10gPSA0MjtcblxuICBsZXQgaWZkbyA9IDg7XG5cbiAgYmluLndyaXRlVWludChkYXRhLCBvZmZzZXQsIGlmZG8pO1xuXG4gIG9mZnNldCArPSA0O1xuXG4gIGlmZHMuZm9yRWFjaCgoaWZkLCBpKSA9PiB7XG4gICAgY29uc3Qgbm9mZnMgPSBfd3JpdGVJRkQoYmluLCBkYXRhLCBpZmRvLCBpZmQpO1xuICAgIGlmZG8gPSBub2Zmc1sxXTtcbiAgICBpZiAoaSA8IGlmZHMubGVuZ3RoIC0gMSkge1xuICAgICAgYmluLndyaXRlVWludChkYXRhLCBub2Zmc1swXSwgaWZkbyk7XG4gICAgfVxuICB9KTtcblxuICBpZiAoZGF0YS5zbGljZSkge1xuICAgIHJldHVybiBkYXRhLnNsaWNlKDAsIGlmZG8pLmJ1ZmZlcjtcbiAgfVxuXG4gIC8vIG5vZGUgaGFzbid0IGltcGxlbWVudGVkIHNsaWNlIG9uIFVpbnQ4QXJyYXkgeWV0XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGlmZG8pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlmZG87IGkrKykge1xuICAgIHJlc3VsdFtpXSA9IGRhdGFbaV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5idWZmZXI7XG59O1xuXG5jb25zdCBlbmNvZGVJbWFnZSA9ICh2YWx1ZXMsIHdpZHRoLCBoZWlnaHQsIG1ldGFkYXRhKSA9PiB7XG4gIGlmIChoZWlnaHQgPT09IHVuZGVmaW5lZCB8fCBoZWlnaHQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHlvdSBwYXNzZWQgaW50byBlbmNvZGVJbWFnZSBhIHdpZHRoIG9mIHR5cGUgJHtoZWlnaHR9YCk7XG4gIH1cblxuICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCB8fCB3aWR0aCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgeW91IHBhc3NlZCBpbnRvIGVuY29kZUltYWdlIGEgd2lkdGggb2YgdHlwZSAke3dpZHRofWApO1xuICB9XG5cbiAgY29uc3QgaWZkID0ge1xuICAgIDI1NjogW3dpZHRoXSwgLy8gSW1hZ2VXaWR0aFxuICAgIDI1NzogW2hlaWdodF0sIC8vIEltYWdlTGVuZ3RoXG4gICAgMjczOiBbbnVtQnl0ZXNJbklmZF0sIC8vIHN0cmlwcyBvZmZzZXRcbiAgICAyNzg6IFtoZWlnaHRdLCAvLyBSb3dzUGVyU3RyaXBcbiAgICAzMDU6ICdnZW90aWZmLmpzJywgLy8gbm8gYXJyYXkgZm9yIEFTQ0lJKFopXG4gIH07XG5cbiAgaWYgKG1ldGFkYXRhKSB7XG4gICAgZm9yIChjb25zdCBpIGluIG1ldGFkYXRhKSB7XG4gICAgICBpZiAobWV0YWRhdGEuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgaWZkW2ldID0gbWV0YWRhdGFbaV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcHJmeCA9IG5ldyBVaW50OEFycmF5KGVuY29kZUlmZHMoW2lmZF0pKTtcblxuICBjb25zdCBpbWcgPSBuZXcgVWludDhBcnJheSh2YWx1ZXMpO1xuXG4gIGNvbnN0IHNhbXBsZXNQZXJQaXhlbCA9IGlmZFsyNzddO1xuXG4gIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShudW1CeXRlc0luSWZkICsgKHdpZHRoICogaGVpZ2h0ICogc2FtcGxlc1BlclBpeGVsKSk7XG4gIHRpbWVzKHByZngubGVuZ3RoLCAoaSkgPT4ge1xuICAgIGRhdGFbaV0gPSBwcmZ4W2ldO1xuICB9KTtcbiAgZm9yRWFjaChpbWcsICh2YWx1ZSwgaSkgPT4ge1xuICAgIGRhdGFbbnVtQnl0ZXNJbklmZCArIGldID0gdmFsdWU7XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhLmJ1ZmZlcjtcbn07XG5cbmNvbnN0IGNvbnZlcnRUb1RpZHMgPSAoaW5wdXQpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIGlucHV0KSB7XG4gICAgaWYgKGtleSAhPT0gJ1N0cmlwT2Zmc2V0cycpIHtcbiAgICAgIGlmICghbmFtZTJjb2RlW2tleV0pIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihrZXksICdub3QgaW4gbmFtZTJjb2RlOicsIE9iamVjdC5rZXlzKG5hbWUyY29kZSkpO1xuICAgICAgfVxuICAgICAgcmVzdWx0W25hbWUyY29kZVtrZXldXSA9IGlucHV0W2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5jb25zdCB0b0FycmF5ID0gKGlucHV0KSA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuICByZXR1cm4gW2lucHV0XTtcbn07XG5cbmNvbnN0IG1ldGFkYXRhRGVmYXVsdHMgPSBbXG4gIFsnQ29tcHJlc3Npb24nLCAxXSwgLy8gbm8gY29tcHJlc3Npb25cbiAgWydQbGFuYXJDb25maWd1cmF0aW9uJywgMV0sXG4gIFsnRXh0cmFTYW1wbGVzJywgMF0sXG5dO1xuXG5leHBvcnQgZnVuY3Rpb24gd3JpdGVHZW90aWZmKGRhdGEsIG1ldGFkYXRhKSB7XG4gIGNvbnN0IGlzRmxhdHRlbmVkID0gdHlwZW9mIGRhdGFbMF0gPT09ICdudW1iZXInO1xuXG4gIGxldCBoZWlnaHQ7XG4gIGxldCBudW1CYW5kcztcbiAgbGV0IHdpZHRoO1xuICBsZXQgZmxhdHRlbmVkVmFsdWVzO1xuXG4gIGlmIChpc0ZsYXR0ZW5lZCkge1xuICAgIGhlaWdodCA9IG1ldGFkYXRhLmhlaWdodCB8fCBtZXRhZGF0YS5JbWFnZUxlbmd0aDtcbiAgICB3aWR0aCA9IG1ldGFkYXRhLndpZHRoIHx8IG1ldGFkYXRhLkltYWdlV2lkdGg7XG4gICAgbnVtQmFuZHMgPSBkYXRhLmxlbmd0aCAvIChoZWlnaHQgKiB3aWR0aCk7XG4gICAgZmxhdHRlbmVkVmFsdWVzID0gZGF0YTtcbiAgfSBlbHNlIHtcbiAgICBudW1CYW5kcyA9IGRhdGEubGVuZ3RoO1xuICAgIGhlaWdodCA9IGRhdGFbMF0ubGVuZ3RoO1xuICAgIHdpZHRoID0gZGF0YVswXVswXS5sZW5ndGg7XG4gICAgZmxhdHRlbmVkVmFsdWVzID0gW107XG4gICAgdGltZXMoaGVpZ2h0LCAocm93SW5kZXgpID0+IHtcbiAgICAgIHRpbWVzKHdpZHRoLCAoY29sdW1uSW5kZXgpID0+IHtcbiAgICAgICAgdGltZXMobnVtQmFuZHMsIChiYW5kSW5kZXgpID0+IHtcbiAgICAgICAgICBmbGF0dGVuZWRWYWx1ZXMucHVzaChkYXRhW2JhbmRJbmRleF1bcm93SW5kZXhdW2NvbHVtbkluZGV4XSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBtZXRhZGF0YS5JbWFnZUxlbmd0aCA9IGhlaWdodDtcbiAgZGVsZXRlIG1ldGFkYXRhLmhlaWdodDtcbiAgbWV0YWRhdGEuSW1hZ2VXaWR0aCA9IHdpZHRoO1xuICBkZWxldGUgbWV0YWRhdGEud2lkdGg7XG5cbiAgLy8gY29uc3VsdCBodHRwczovL3d3dy5sb2MuZ292L3ByZXNlcnZhdGlvbi9kaWdpdGFsL2Zvcm1hdHMvY29udGVudC90aWZmX3RhZ3Muc2h0bWxcblxuICBpZiAoIW1ldGFkYXRhLkJpdHNQZXJTYW1wbGUpIHtcbiAgICBtZXRhZGF0YS5CaXRzUGVyU2FtcGxlID0gdGltZXMobnVtQmFuZHMsICgpID0+IDgpO1xuICB9XG5cbiAgbWV0YWRhdGFEZWZhdWx0cy5mb3JFYWNoKCh0YWcpID0+IHtcbiAgICBjb25zdCBrZXkgPSB0YWdbMF07XG4gICAgaWYgKCFtZXRhZGF0YVtrZXldKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRhZ1sxXTtcbiAgICAgIG1ldGFkYXRhW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFRoZSBjb2xvciBzcGFjZSBvZiB0aGUgaW1hZ2UgZGF0YS5cbiAgLy8gMT1ibGFjayBpcyB6ZXJvIGFuZCAyPVJHQi5cbiAgaWYgKCFtZXRhZGF0YS5QaG90b21ldHJpY0ludGVycHJldGF0aW9uKSB7XG4gICAgbWV0YWRhdGEuUGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbiA9IG1ldGFkYXRhLkJpdHNQZXJTYW1wbGUubGVuZ3RoID09PSAzID8gMiA6IDE7XG4gIH1cblxuICAvLyBUaGUgbnVtYmVyIG9mIGNvbXBvbmVudHMgcGVyIHBpeGVsLlxuICBpZiAoIW1ldGFkYXRhLlNhbXBsZXNQZXJQaXhlbCkge1xuICAgIG1ldGFkYXRhLlNhbXBsZXNQZXJQaXhlbCA9IFtudW1CYW5kc107XG4gIH1cblxuICBpZiAoIW1ldGFkYXRhLlN0cmlwQnl0ZUNvdW50cykge1xuICAgIC8vIHdlIGFyZSBvbmx5IHdyaXRpbmcgb25lIHN0cmlwXG4gICAgbWV0YWRhdGEuU3RyaXBCeXRlQ291bnRzID0gW251bUJhbmRzICogaGVpZ2h0ICogd2lkdGhdO1xuICB9XG5cbiAgaWYgKCFtZXRhZGF0YS5Nb2RlbFBpeGVsU2NhbGUpIHtcbiAgICAvLyBhc3N1bWVzIHJhc3RlciB0YWtlcyB1cCBleGFjdGx5IHRoZSB3aG9sZSBnbG9iZVxuICAgIG1ldGFkYXRhLk1vZGVsUGl4ZWxTY2FsZSA9IFszNjAgLyB3aWR0aCwgMTgwIC8gaGVpZ2h0LCAwXTtcbiAgfVxuXG4gIGlmICghbWV0YWRhdGEuU2FtcGxlRm9ybWF0KSB7XG4gICAgbWV0YWRhdGEuU2FtcGxlRm9ybWF0ID0gdGltZXMobnVtQmFuZHMsICgpID0+IDEpO1xuICB9XG5cbiAgLy8gaWYgZGlkbid0IHBhc3MgaW4gcHJvamVjdGlvbiBpbmZvcm1hdGlvbiwgYXNzdW1lIHRoZSBwb3B1bGFyIDQzMjYgXCJnZW9ncmFwaGljIHByb2plY3Rpb25cIlxuICBpZiAoIW1ldGFkYXRhLmhhc093blByb3BlcnR5KCdHZW9ncmFwaGljVHlwZUdlb0tleScpICYmICFtZXRhZGF0YS5oYXNPd25Qcm9wZXJ0eSgnUHJvamVjdGVkQ1NUeXBlR2VvS2V5JykpIHtcbiAgICBtZXRhZGF0YS5HZW9ncmFwaGljVHlwZUdlb0tleSA9IDQzMjY7XG4gICAgbWV0YWRhdGEuTW9kZWxUaWVwb2ludCA9IFswLCAwLCAwLCAtMTgwLCA5MCwgMF07IC8vIHJhc3RlciBmaXRzIHdob2xlIGdsb2JlXG4gICAgbWV0YWRhdGEuR2VvZ0NpdGF0aW9uR2VvS2V5ID0gJ1dHUyA4NCc7XG4gICAgbWV0YWRhdGEuR1RNb2RlbFR5cGVHZW9LZXkgPSAyO1xuICB9XG5cbiAgY29uc3QgZ2VvS2V5cyA9IE9iamVjdC5rZXlzKG1ldGFkYXRhKVxuICAgIC5maWx0ZXIoKGtleSkgPT4gZW5kc1dpdGgoa2V5LCAnR2VvS2V5JykpXG4gICAgLnNvcnQoKGEsIGIpID0+IG5hbWUyY29kZVthXSAtIG5hbWUyY29kZVtiXSk7XG5cbiAgaWYgKCFtZXRhZGF0YS5HZW9Bc2NpaVBhcmFtcykge1xuICAgIGxldCBnZW9Bc2NpaVBhcmFtcyA9ICcnO1xuICAgIGdlb0tleXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgY29uc3QgY29kZSA9IE51bWJlcihuYW1lMmNvZGVbbmFtZV0pO1xuICAgICAgY29uc3QgdGFnVHlwZSA9IGZpZWxkVGFnVHlwZXNbY29kZV07XG4gICAgICBpZiAodGFnVHlwZSA9PT0gJ0FTQ0lJJykge1xuICAgICAgICBnZW9Bc2NpaVBhcmFtcyArPSBgJHttZXRhZGF0YVtuYW1lXS50b1N0cmluZygpfVxcdTAwMDBgO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChnZW9Bc2NpaVBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICBtZXRhZGF0YS5HZW9Bc2NpaVBhcmFtcyA9IGdlb0FzY2lpUGFyYW1zO1xuICAgIH1cbiAgfVxuXG4gIGlmICghbWV0YWRhdGEuR2VvS2V5RGlyZWN0b3J5KSB7XG4gICAgY29uc3QgTnVtYmVyT2ZLZXlzID0gZ2VvS2V5cy5sZW5ndGg7XG5cbiAgICBjb25zdCBHZW9LZXlEaXJlY3RvcnkgPSBbMSwgMSwgMCwgTnVtYmVyT2ZLZXlzXTtcbiAgICBnZW9LZXlzLmZvckVhY2goKGdlb0tleSkgPT4ge1xuICAgICAgY29uc3QgS2V5SUQgPSBOdW1iZXIobmFtZTJjb2RlW2dlb0tleV0pO1xuICAgICAgR2VvS2V5RGlyZWN0b3J5LnB1c2goS2V5SUQpO1xuXG4gICAgICBsZXQgQ291bnQ7XG4gICAgICBsZXQgVElGRlRhZ0xvY2F0aW9uO1xuICAgICAgbGV0IHZhbHVlT2Zmc2V0O1xuICAgICAgaWYgKGZpZWxkVGFnVHlwZXNbS2V5SURdID09PSAnU0hPUlQnKSB7XG4gICAgICAgIENvdW50ID0gMTtcbiAgICAgICAgVElGRlRhZ0xvY2F0aW9uID0gMDtcbiAgICAgICAgdmFsdWVPZmZzZXQgPSBtZXRhZGF0YVtnZW9LZXldO1xuICAgICAgfSBlbHNlIGlmIChnZW9LZXkgPT09ICdHZW9nQ2l0YXRpb25HZW9LZXknKSB7XG4gICAgICAgIENvdW50ID0gbWV0YWRhdGEuR2VvQXNjaWlQYXJhbXMubGVuZ3RoO1xuICAgICAgICBUSUZGVGFnTG9jYXRpb24gPSBOdW1iZXIobmFtZTJjb2RlLkdlb0FzY2lpUGFyYW1zKTtcbiAgICAgICAgdmFsdWVPZmZzZXQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtnZW90aWZmLmpzXSBjb3VsZG4ndCBnZXQgVElGRlRhZ0xvY2F0aW9uIGZvciAke2dlb0tleX1gKTtcbiAgICAgIH1cbiAgICAgIEdlb0tleURpcmVjdG9yeS5wdXNoKFRJRkZUYWdMb2NhdGlvbik7XG4gICAgICBHZW9LZXlEaXJlY3RvcnkucHVzaChDb3VudCk7XG4gICAgICBHZW9LZXlEaXJlY3RvcnkucHVzaCh2YWx1ZU9mZnNldCk7XG4gICAgfSk7XG4gICAgbWV0YWRhdGEuR2VvS2V5RGlyZWN0b3J5ID0gR2VvS2V5RGlyZWN0b3J5O1xuICB9XG5cbiAgLy8gZGVsZXRlIEdlb0tleXMgZnJvbSBtZXRhZGF0YSwgYmVjYXVzZSBzdG9yZWQgaW4gR2VvS2V5RGlyZWN0b3J5IHRhZ1xuICBmb3IgKGNvbnN0IGdlb0tleSBvZiBnZW9LZXlzKSB7XG4gICAgaWYgKG1ldGFkYXRhLmhhc093blByb3BlcnR5KGdlb0tleSkpIHtcbiAgICAgIGRlbGV0ZSBtZXRhZGF0YVtnZW9LZXldO1xuICAgIH1cbiAgfVxuXG4gIFtcbiAgICAnQ29tcHJlc3Npb24nLFxuICAgICdFeHRyYVNhbXBsZXMnLFxuICAgICdHZW9ncmFwaGljVHlwZUdlb0tleScsXG4gICAgJ0dUTW9kZWxUeXBlR2VvS2V5JyxcbiAgICAnR1RSYXN0ZXJUeXBlR2VvS2V5JyxcbiAgICAnSW1hZ2VMZW5ndGgnLCAvLyBzeW5vbnltIG9mIEltYWdlSGVpZ2h0XG4gICAgJ0ltYWdlV2lkdGgnLFxuICAgICdPcmllbnRhdGlvbicsXG4gICAgJ1Bob3RvbWV0cmljSW50ZXJwcmV0YXRpb24nLFxuICAgICdQcm9qZWN0ZWRDU1R5cGVHZW9LZXknLFxuICAgICdQbGFuYXJDb25maWd1cmF0aW9uJyxcbiAgICAnUmVzb2x1dGlvblVuaXQnLFxuICAgICdTYW1wbGVzUGVyUGl4ZWwnLFxuICAgICdYUG9zaXRpb24nLFxuICAgICdZUG9zaXRpb24nLFxuICAgICdSb3dzUGVyU3RyaXAnLFxuICBdLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICBpZiAobWV0YWRhdGFbbmFtZV0pIHtcbiAgICAgIG1ldGFkYXRhW25hbWVdID0gdG9BcnJheShtZXRhZGF0YVtuYW1lXSk7XG4gICAgfVxuICB9KTtcblxuICBjb25zdCBlbmNvZGVkTWV0YWRhdGEgPSBjb252ZXJ0VG9UaWRzKG1ldGFkYXRhKTtcblxuICBjb25zdCBvdXRwdXRJbWFnZSA9IGVuY29kZUltYWdlKGZsYXR0ZW5lZFZhbHVlcywgd2lkdGgsIGhlaWdodCwgZW5jb2RlZE1ldGFkYXRhKTtcblxuICByZXR1cm4gb3V0cHV0SW1hZ2U7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/geotiffwriter.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/globals.js":
/*!*****************************************************!*\
  !*** ./node_modules/geotiff/dist-module/globals.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ExtraSamplesValues: () => (/* binding */ ExtraSamplesValues),\n/* harmony export */   LercAddCompression: () => (/* binding */ LercAddCompression),\n/* harmony export */   LercParameters: () => (/* binding */ LercParameters),\n/* harmony export */   arrayFields: () => (/* binding */ arrayFields),\n/* harmony export */   fieldTagNames: () => (/* binding */ fieldTagNames),\n/* harmony export */   fieldTagTypes: () => (/* binding */ fieldTagTypes),\n/* harmony export */   fieldTags: () => (/* binding */ fieldTags),\n/* harmony export */   fieldTypeNames: () => (/* binding */ fieldTypeNames),\n/* harmony export */   fieldTypes: () => (/* binding */ fieldTypes),\n/* harmony export */   geoKeyNames: () => (/* binding */ geoKeyNames),\n/* harmony export */   geoKeys: () => (/* binding */ geoKeys),\n/* harmony export */   photometricInterpretations: () => (/* binding */ photometricInterpretations)\n/* harmony export */ });\nconst fieldTagNames = {\n  // TIFF Baseline\n  0x013B: 'Artist',\n  0x0102: 'BitsPerSample',\n  0x0109: 'CellLength',\n  0x0108: 'CellWidth',\n  0x0140: 'ColorMap',\n  0x0103: 'Compression',\n  0x8298: 'Copyright',\n  0x0132: 'DateTime',\n  0x0152: 'ExtraSamples',\n  0x010A: 'FillOrder',\n  0x0121: 'FreeByteCounts',\n  0x0120: 'FreeOffsets',\n  0x0123: 'GrayResponseCurve',\n  0x0122: 'GrayResponseUnit',\n  0x013C: 'HostComputer',\n  0x010E: 'ImageDescription',\n  0x0101: 'ImageLength',\n  0x0100: 'ImageWidth',\n  0x010F: 'Make',\n  0x0119: 'MaxSampleValue',\n  0x0118: 'MinSampleValue',\n  0x0110: 'Model',\n  0x00FE: 'NewSubfileType',\n  0x0112: 'Orientation',\n  0x0106: 'PhotometricInterpretation',\n  0x011C: 'PlanarConfiguration',\n  0x0128: 'ResolutionUnit',\n  0x0116: 'RowsPerStrip',\n  0x0115: 'SamplesPerPixel',\n  0x0131: 'Software',\n  0x0117: 'StripByteCounts',\n  0x0111: 'StripOffsets',\n  0x00FF: 'SubfileType',\n  0x0107: 'Threshholding',\n  0x011A: 'XResolution',\n  0x011B: 'YResolution',\n\n  // TIFF Extended\n  0x0146: 'BadFaxLines',\n  0x0147: 'CleanFaxData',\n  0x0157: 'ClipPath',\n  0x0148: 'ConsecutiveBadFaxLines',\n  0x01B1: 'Decode',\n  0x01B2: 'DefaultImageColor',\n  0x010D: 'DocumentName',\n  0x0150: 'DotRange',\n  0x0141: 'HalftoneHints',\n  0x015A: 'Indexed',\n  0x015B: 'JPEGTables',\n  0x011D: 'PageName',\n  0x0129: 'PageNumber',\n  0x013D: 'Predictor',\n  0x013F: 'PrimaryChromaticities',\n  0x0214: 'ReferenceBlackWhite',\n  0x0153: 'SampleFormat',\n  0x0154: 'SMinSampleValue',\n  0x0155: 'SMaxSampleValue',\n  0x022F: 'StripRowCounts',\n  0x014A: 'SubIFDs',\n  0x0124: 'T4Options',\n  0x0125: 'T6Options',\n  0x0145: 'TileByteCounts',\n  0x0143: 'TileLength',\n  0x0144: 'TileOffsets',\n  0x0142: 'TileWidth',\n  0x012D: 'TransferFunction',\n  0x013E: 'WhitePoint',\n  0x0158: 'XClipPathUnits',\n  0x011E: 'XPosition',\n  0x0211: 'YCbCrCoefficients',\n  0x0213: 'YCbCrPositioning',\n  0x0212: 'YCbCrSubSampling',\n  0x0159: 'YClipPathUnits',\n  0x011F: 'YPosition',\n\n  // EXIF\n  0x9202: 'ApertureValue',\n  0xA001: 'ColorSpace',\n  0x9004: 'DateTimeDigitized',\n  0x9003: 'DateTimeOriginal',\n  0x8769: 'Exif IFD',\n  0x9000: 'ExifVersion',\n  0x829A: 'ExposureTime',\n  0xA300: 'FileSource',\n  0x9209: 'Flash',\n  0xA000: 'FlashpixVersion',\n  0x829D: 'FNumber',\n  0xA420: 'ImageUniqueID',\n  0x9208: 'LightSource',\n  0x927C: 'MakerNote',\n  0x9201: 'ShutterSpeedValue',\n  0x9286: 'UserComment',\n\n  // IPTC\n  0x83BB: 'IPTC',\n\n  // ICC\n  0x8773: 'ICC Profile',\n\n  // XMP\n  0x02BC: 'XMP',\n\n  // GDAL\n  0xA480: 'GDAL_METADATA',\n  0xA481: 'GDAL_NODATA',\n\n  // Photoshop\n  0x8649: 'Photoshop',\n\n  // GeoTiff\n  0x830E: 'ModelPixelScale',\n  0x8482: 'ModelTiepoint',\n  0x85D8: 'ModelTransformation',\n  0x87AF: 'GeoKeyDirectory',\n  0x87B0: 'GeoDoubleParams',\n  0x87B1: 'GeoAsciiParams',\n\n  // LERC\n  0xC5F2: 'LercParameters',\n};\n\nconst fieldTags = {};\nfor (const key in fieldTagNames) {\n  if (fieldTagNames.hasOwnProperty(key)) {\n    fieldTags[fieldTagNames[key]] = parseInt(key, 10);\n  }\n}\n\nconst fieldTagTypes = {\n  256: 'SHORT',\n  257: 'SHORT',\n  258: 'SHORT',\n  259: 'SHORT',\n  262: 'SHORT',\n  273: 'LONG',\n  274: 'SHORT',\n  277: 'SHORT',\n  278: 'LONG',\n  279: 'LONG',\n  282: 'RATIONAL',\n  283: 'RATIONAL',\n  284: 'SHORT',\n  286: 'SHORT',\n  287: 'RATIONAL',\n  296: 'SHORT',\n  297: 'SHORT',\n  305: 'ASCII',\n  306: 'ASCII',\n  338: 'SHORT',\n  339: 'SHORT',\n  513: 'LONG',\n  514: 'LONG',\n  1024: 'SHORT',\n  1025: 'SHORT',\n  2048: 'SHORT',\n  2049: 'ASCII',\n  3072: 'SHORT',\n  3073: 'ASCII',\n  33550: 'DOUBLE',\n  33922: 'DOUBLE',\n  34264: 'DOUBLE',\n  34665: 'LONG',\n  34735: 'SHORT',\n  34736: 'DOUBLE',\n  34737: 'ASCII',\n  42113: 'ASCII',\n};\n\nconst arrayFields = [\n  fieldTags.BitsPerSample,\n  fieldTags.ExtraSamples,\n  fieldTags.SampleFormat,\n  fieldTags.StripByteCounts,\n  fieldTags.StripOffsets,\n  fieldTags.StripRowCounts,\n  fieldTags.TileByteCounts,\n  fieldTags.TileOffsets,\n  fieldTags.SubIFDs,\n];\n\nconst fieldTypeNames = {\n  0x0001: 'BYTE',\n  0x0002: 'ASCII',\n  0x0003: 'SHORT',\n  0x0004: 'LONG',\n  0x0005: 'RATIONAL',\n  0x0006: 'SBYTE',\n  0x0007: 'UNDEFINED',\n  0x0008: 'SSHORT',\n  0x0009: 'SLONG',\n  0x000A: 'SRATIONAL',\n  0x000B: 'FLOAT',\n  0x000C: 'DOUBLE',\n  // IFD offset, suggested by https://owl.phy.queensu.ca/~phil/exiftool/standards.html\n  0x000D: 'IFD',\n  // introduced by BigTIFF\n  0x0010: 'LONG8',\n  0x0011: 'SLONG8',\n  0x0012: 'IFD8',\n};\n\nconst fieldTypes = {};\nfor (const key in fieldTypeNames) {\n  if (fieldTypeNames.hasOwnProperty(key)) {\n    fieldTypes[fieldTypeNames[key]] = parseInt(key, 10);\n  }\n}\n\nconst photometricInterpretations = {\n  WhiteIsZero: 0,\n  BlackIsZero: 1,\n  RGB: 2,\n  Palette: 3,\n  TransparencyMask: 4,\n  CMYK: 5,\n  YCbCr: 6,\n\n  CIELab: 8,\n  ICCLab: 9,\n};\n\nconst ExtraSamplesValues = {\n  Unspecified: 0,\n  Assocalpha: 1,\n  Unassalpha: 2,\n};\n\nconst LercParameters = {\n  Version: 0,\n  AddCompression: 1,\n};\n\nconst LercAddCompression = {\n  None: 0,\n  Deflate: 1,\n  Zstandard: 2,\n};\n\nconst geoKeyNames = {\n  1024: 'GTModelTypeGeoKey',\n  1025: 'GTRasterTypeGeoKey',\n  1026: 'GTCitationGeoKey',\n  2048: 'GeographicTypeGeoKey',\n  2049: 'GeogCitationGeoKey',\n  2050: 'GeogGeodeticDatumGeoKey',\n  2051: 'GeogPrimeMeridianGeoKey',\n  2052: 'GeogLinearUnitsGeoKey',\n  2053: 'GeogLinearUnitSizeGeoKey',\n  2054: 'GeogAngularUnitsGeoKey',\n  2055: 'GeogAngularUnitSizeGeoKey',\n  2056: 'GeogEllipsoidGeoKey',\n  2057: 'GeogSemiMajorAxisGeoKey',\n  2058: 'GeogSemiMinorAxisGeoKey',\n  2059: 'GeogInvFlatteningGeoKey',\n  2060: 'GeogAzimuthUnitsGeoKey',\n  2061: 'GeogPrimeMeridianLongGeoKey',\n  2062: 'GeogTOWGS84GeoKey',\n  3072: 'ProjectedCSTypeGeoKey',\n  3073: 'PCSCitationGeoKey',\n  3074: 'ProjectionGeoKey',\n  3075: 'ProjCoordTransGeoKey',\n  3076: 'ProjLinearUnitsGeoKey',\n  3077: 'ProjLinearUnitSizeGeoKey',\n  3078: 'ProjStdParallel1GeoKey',\n  3079: 'ProjStdParallel2GeoKey',\n  3080: 'ProjNatOriginLongGeoKey',\n  3081: 'ProjNatOriginLatGeoKey',\n  3082: 'ProjFalseEastingGeoKey',\n  3083: 'ProjFalseNorthingGeoKey',\n  3084: 'ProjFalseOriginLongGeoKey',\n  3085: 'ProjFalseOriginLatGeoKey',\n  3086: 'ProjFalseOriginEastingGeoKey',\n  3087: 'ProjFalseOriginNorthingGeoKey',\n  3088: 'ProjCenterLongGeoKey',\n  3089: 'ProjCenterLatGeoKey',\n  3090: 'ProjCenterEastingGeoKey',\n  3091: 'ProjCenterNorthingGeoKey',\n  3092: 'ProjScaleAtNatOriginGeoKey',\n  3093: 'ProjScaleAtCenterGeoKey',\n  3094: 'ProjAzimuthAngleGeoKey',\n  3095: 'ProjStraightVertPoleLongGeoKey',\n  3096: 'ProjRectifiedGridAngleGeoKey',\n  4096: 'VerticalCSTypeGeoKey',\n  4097: 'VerticalCitationGeoKey',\n  4098: 'VerticalDatumGeoKey',\n  4099: 'VerticalUnitsGeoKey',\n};\n\nconst geoKeys = {};\nfor (const key in geoKeyNames) {\n  if (geoKeyNames.hasOwnProperty(key)) {\n    geoKeys[geoKeyNames[key]] = parseInt(key, 10);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9nbG9iYWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZXJyaWFqcy1tYXAvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9nbG9iYWxzLmpzP2ZjNTMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IGZpZWxkVGFnTmFtZXMgPSB7XG4gIC8vIFRJRkYgQmFzZWxpbmVcbiAgMHgwMTNCOiAnQXJ0aXN0JyxcbiAgMHgwMTAyOiAnQml0c1BlclNhbXBsZScsXG4gIDB4MDEwOTogJ0NlbGxMZW5ndGgnLFxuICAweDAxMDg6ICdDZWxsV2lkdGgnLFxuICAweDAxNDA6ICdDb2xvck1hcCcsXG4gIDB4MDEwMzogJ0NvbXByZXNzaW9uJyxcbiAgMHg4Mjk4OiAnQ29weXJpZ2h0JyxcbiAgMHgwMTMyOiAnRGF0ZVRpbWUnLFxuICAweDAxNTI6ICdFeHRyYVNhbXBsZXMnLFxuICAweDAxMEE6ICdGaWxsT3JkZXInLFxuICAweDAxMjE6ICdGcmVlQnl0ZUNvdW50cycsXG4gIDB4MDEyMDogJ0ZyZWVPZmZzZXRzJyxcbiAgMHgwMTIzOiAnR3JheVJlc3BvbnNlQ3VydmUnLFxuICAweDAxMjI6ICdHcmF5UmVzcG9uc2VVbml0JyxcbiAgMHgwMTNDOiAnSG9zdENvbXB1dGVyJyxcbiAgMHgwMTBFOiAnSW1hZ2VEZXNjcmlwdGlvbicsXG4gIDB4MDEwMTogJ0ltYWdlTGVuZ3RoJyxcbiAgMHgwMTAwOiAnSW1hZ2VXaWR0aCcsXG4gIDB4MDEwRjogJ01ha2UnLFxuICAweDAxMTk6ICdNYXhTYW1wbGVWYWx1ZScsXG4gIDB4MDExODogJ01pblNhbXBsZVZhbHVlJyxcbiAgMHgwMTEwOiAnTW9kZWwnLFxuICAweDAwRkU6ICdOZXdTdWJmaWxlVHlwZScsXG4gIDB4MDExMjogJ09yaWVudGF0aW9uJyxcbiAgMHgwMTA2OiAnUGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbicsXG4gIDB4MDExQzogJ1BsYW5hckNvbmZpZ3VyYXRpb24nLFxuICAweDAxMjg6ICdSZXNvbHV0aW9uVW5pdCcsXG4gIDB4MDExNjogJ1Jvd3NQZXJTdHJpcCcsXG4gIDB4MDExNTogJ1NhbXBsZXNQZXJQaXhlbCcsXG4gIDB4MDEzMTogJ1NvZnR3YXJlJyxcbiAgMHgwMTE3OiAnU3RyaXBCeXRlQ291bnRzJyxcbiAgMHgwMTExOiAnU3RyaXBPZmZzZXRzJyxcbiAgMHgwMEZGOiAnU3ViZmlsZVR5cGUnLFxuICAweDAxMDc6ICdUaHJlc2hob2xkaW5nJyxcbiAgMHgwMTFBOiAnWFJlc29sdXRpb24nLFxuICAweDAxMUI6ICdZUmVzb2x1dGlvbicsXG5cbiAgLy8gVElGRiBFeHRlbmRlZFxuICAweDAxNDY6ICdCYWRGYXhMaW5lcycsXG4gIDB4MDE0NzogJ0NsZWFuRmF4RGF0YScsXG4gIDB4MDE1NzogJ0NsaXBQYXRoJyxcbiAgMHgwMTQ4OiAnQ29uc2VjdXRpdmVCYWRGYXhMaW5lcycsXG4gIDB4MDFCMTogJ0RlY29kZScsXG4gIDB4MDFCMjogJ0RlZmF1bHRJbWFnZUNvbG9yJyxcbiAgMHgwMTBEOiAnRG9jdW1lbnROYW1lJyxcbiAgMHgwMTUwOiAnRG90UmFuZ2UnLFxuICAweDAxNDE6ICdIYWxmdG9uZUhpbnRzJyxcbiAgMHgwMTVBOiAnSW5kZXhlZCcsXG4gIDB4MDE1QjogJ0pQRUdUYWJsZXMnLFxuICAweDAxMUQ6ICdQYWdlTmFtZScsXG4gIDB4MDEyOTogJ1BhZ2VOdW1iZXInLFxuICAweDAxM0Q6ICdQcmVkaWN0b3InLFxuICAweDAxM0Y6ICdQcmltYXJ5Q2hyb21hdGljaXRpZXMnLFxuICAweDAyMTQ6ICdSZWZlcmVuY2VCbGFja1doaXRlJyxcbiAgMHgwMTUzOiAnU2FtcGxlRm9ybWF0JyxcbiAgMHgwMTU0OiAnU01pblNhbXBsZVZhbHVlJyxcbiAgMHgwMTU1OiAnU01heFNhbXBsZVZhbHVlJyxcbiAgMHgwMjJGOiAnU3RyaXBSb3dDb3VudHMnLFxuICAweDAxNEE6ICdTdWJJRkRzJyxcbiAgMHgwMTI0OiAnVDRPcHRpb25zJyxcbiAgMHgwMTI1OiAnVDZPcHRpb25zJyxcbiAgMHgwMTQ1OiAnVGlsZUJ5dGVDb3VudHMnLFxuICAweDAxNDM6ICdUaWxlTGVuZ3RoJyxcbiAgMHgwMTQ0OiAnVGlsZU9mZnNldHMnLFxuICAweDAxNDI6ICdUaWxlV2lkdGgnLFxuICAweDAxMkQ6ICdUcmFuc2ZlckZ1bmN0aW9uJyxcbiAgMHgwMTNFOiAnV2hpdGVQb2ludCcsXG4gIDB4MDE1ODogJ1hDbGlwUGF0aFVuaXRzJyxcbiAgMHgwMTFFOiAnWFBvc2l0aW9uJyxcbiAgMHgwMjExOiAnWUNiQ3JDb2VmZmljaWVudHMnLFxuICAweDAyMTM6ICdZQ2JDclBvc2l0aW9uaW5nJyxcbiAgMHgwMjEyOiAnWUNiQ3JTdWJTYW1wbGluZycsXG4gIDB4MDE1OTogJ1lDbGlwUGF0aFVuaXRzJyxcbiAgMHgwMTFGOiAnWVBvc2l0aW9uJyxcblxuICAvLyBFWElGXG4gIDB4OTIwMjogJ0FwZXJ0dXJlVmFsdWUnLFxuICAweEEwMDE6ICdDb2xvclNwYWNlJyxcbiAgMHg5MDA0OiAnRGF0ZVRpbWVEaWdpdGl6ZWQnLFxuICAweDkwMDM6ICdEYXRlVGltZU9yaWdpbmFsJyxcbiAgMHg4NzY5OiAnRXhpZiBJRkQnLFxuICAweDkwMDA6ICdFeGlmVmVyc2lvbicsXG4gIDB4ODI5QTogJ0V4cG9zdXJlVGltZScsXG4gIDB4QTMwMDogJ0ZpbGVTb3VyY2UnLFxuICAweDkyMDk6ICdGbGFzaCcsXG4gIDB4QTAwMDogJ0ZsYXNocGl4VmVyc2lvbicsXG4gIDB4ODI5RDogJ0ZOdW1iZXInLFxuICAweEE0MjA6ICdJbWFnZVVuaXF1ZUlEJyxcbiAgMHg5MjA4OiAnTGlnaHRTb3VyY2UnLFxuICAweDkyN0M6ICdNYWtlck5vdGUnLFxuICAweDkyMDE6ICdTaHV0dGVyU3BlZWRWYWx1ZScsXG4gIDB4OTI4NjogJ1VzZXJDb21tZW50JyxcblxuICAvLyBJUFRDXG4gIDB4ODNCQjogJ0lQVEMnLFxuXG4gIC8vIElDQ1xuICAweDg3NzM6ICdJQ0MgUHJvZmlsZScsXG5cbiAgLy8gWE1QXG4gIDB4MDJCQzogJ1hNUCcsXG5cbiAgLy8gR0RBTFxuICAweEE0ODA6ICdHREFMX01FVEFEQVRBJyxcbiAgMHhBNDgxOiAnR0RBTF9OT0RBVEEnLFxuXG4gIC8vIFBob3Rvc2hvcFxuICAweDg2NDk6ICdQaG90b3Nob3AnLFxuXG4gIC8vIEdlb1RpZmZcbiAgMHg4MzBFOiAnTW9kZWxQaXhlbFNjYWxlJyxcbiAgMHg4NDgyOiAnTW9kZWxUaWVwb2ludCcsXG4gIDB4ODVEODogJ01vZGVsVHJhbnNmb3JtYXRpb24nLFxuICAweDg3QUY6ICdHZW9LZXlEaXJlY3RvcnknLFxuICAweDg3QjA6ICdHZW9Eb3VibGVQYXJhbXMnLFxuICAweDg3QjE6ICdHZW9Bc2NpaVBhcmFtcycsXG5cbiAgLy8gTEVSQ1xuICAweEM1RjI6ICdMZXJjUGFyYW1ldGVycycsXG59O1xuXG5leHBvcnQgY29uc3QgZmllbGRUYWdzID0ge307XG5mb3IgKGNvbnN0IGtleSBpbiBmaWVsZFRhZ05hbWVzKSB7XG4gIGlmIChmaWVsZFRhZ05hbWVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICBmaWVsZFRhZ3NbZmllbGRUYWdOYW1lc1trZXldXSA9IHBhcnNlSW50KGtleSwgMTApO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBmaWVsZFRhZ1R5cGVzID0ge1xuICAyNTY6ICdTSE9SVCcsXG4gIDI1NzogJ1NIT1JUJyxcbiAgMjU4OiAnU0hPUlQnLFxuICAyNTk6ICdTSE9SVCcsXG4gIDI2MjogJ1NIT1JUJyxcbiAgMjczOiAnTE9ORycsXG4gIDI3NDogJ1NIT1JUJyxcbiAgMjc3OiAnU0hPUlQnLFxuICAyNzg6ICdMT05HJyxcbiAgMjc5OiAnTE9ORycsXG4gIDI4MjogJ1JBVElPTkFMJyxcbiAgMjgzOiAnUkFUSU9OQUwnLFxuICAyODQ6ICdTSE9SVCcsXG4gIDI4NjogJ1NIT1JUJyxcbiAgMjg3OiAnUkFUSU9OQUwnLFxuICAyOTY6ICdTSE9SVCcsXG4gIDI5NzogJ1NIT1JUJyxcbiAgMzA1OiAnQVNDSUknLFxuICAzMDY6ICdBU0NJSScsXG4gIDMzODogJ1NIT1JUJyxcbiAgMzM5OiAnU0hPUlQnLFxuICA1MTM6ICdMT05HJyxcbiAgNTE0OiAnTE9ORycsXG4gIDEwMjQ6ICdTSE9SVCcsXG4gIDEwMjU6ICdTSE9SVCcsXG4gIDIwNDg6ICdTSE9SVCcsXG4gIDIwNDk6ICdBU0NJSScsXG4gIDMwNzI6ICdTSE9SVCcsXG4gIDMwNzM6ICdBU0NJSScsXG4gIDMzNTUwOiAnRE9VQkxFJyxcbiAgMzM5MjI6ICdET1VCTEUnLFxuICAzNDI2NDogJ0RPVUJMRScsXG4gIDM0NjY1OiAnTE9ORycsXG4gIDM0NzM1OiAnU0hPUlQnLFxuICAzNDczNjogJ0RPVUJMRScsXG4gIDM0NzM3OiAnQVNDSUknLFxuICA0MjExMzogJ0FTQ0lJJyxcbn07XG5cbmV4cG9ydCBjb25zdCBhcnJheUZpZWxkcyA9IFtcbiAgZmllbGRUYWdzLkJpdHNQZXJTYW1wbGUsXG4gIGZpZWxkVGFncy5FeHRyYVNhbXBsZXMsXG4gIGZpZWxkVGFncy5TYW1wbGVGb3JtYXQsXG4gIGZpZWxkVGFncy5TdHJpcEJ5dGVDb3VudHMsXG4gIGZpZWxkVGFncy5TdHJpcE9mZnNldHMsXG4gIGZpZWxkVGFncy5TdHJpcFJvd0NvdW50cyxcbiAgZmllbGRUYWdzLlRpbGVCeXRlQ291bnRzLFxuICBmaWVsZFRhZ3MuVGlsZU9mZnNldHMsXG4gIGZpZWxkVGFncy5TdWJJRkRzLFxuXTtcblxuZXhwb3J0IGNvbnN0IGZpZWxkVHlwZU5hbWVzID0ge1xuICAweDAwMDE6ICdCWVRFJyxcbiAgMHgwMDAyOiAnQVNDSUknLFxuICAweDAwMDM6ICdTSE9SVCcsXG4gIDB4MDAwNDogJ0xPTkcnLFxuICAweDAwMDU6ICdSQVRJT05BTCcsXG4gIDB4MDAwNjogJ1NCWVRFJyxcbiAgMHgwMDA3OiAnVU5ERUZJTkVEJyxcbiAgMHgwMDA4OiAnU1NIT1JUJyxcbiAgMHgwMDA5OiAnU0xPTkcnLFxuICAweDAwMEE6ICdTUkFUSU9OQUwnLFxuICAweDAwMEI6ICdGTE9BVCcsXG4gIDB4MDAwQzogJ0RPVUJMRScsXG4gIC8vIElGRCBvZmZzZXQsIHN1Z2dlc3RlZCBieSBodHRwczovL293bC5waHkucXVlZW5zdS5jYS9+cGhpbC9leGlmdG9vbC9zdGFuZGFyZHMuaHRtbFxuICAweDAwMEQ6ICdJRkQnLFxuICAvLyBpbnRyb2R1Y2VkIGJ5IEJpZ1RJRkZcbiAgMHgwMDEwOiAnTE9ORzgnLFxuICAweDAwMTE6ICdTTE9ORzgnLFxuICAweDAwMTI6ICdJRkQ4Jyxcbn07XG5cbmV4cG9ydCBjb25zdCBmaWVsZFR5cGVzID0ge307XG5mb3IgKGNvbnN0IGtleSBpbiBmaWVsZFR5cGVOYW1lcykge1xuICBpZiAoZmllbGRUeXBlTmFtZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgIGZpZWxkVHlwZXNbZmllbGRUeXBlTmFtZXNba2V5XV0gPSBwYXJzZUludChrZXksIDEwKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgcGhvdG9tZXRyaWNJbnRlcnByZXRhdGlvbnMgPSB7XG4gIFdoaXRlSXNaZXJvOiAwLFxuICBCbGFja0lzWmVybzogMSxcbiAgUkdCOiAyLFxuICBQYWxldHRlOiAzLFxuICBUcmFuc3BhcmVuY3lNYXNrOiA0LFxuICBDTVlLOiA1LFxuICBZQ2JDcjogNixcblxuICBDSUVMYWI6IDgsXG4gIElDQ0xhYjogOSxcbn07XG5cbmV4cG9ydCBjb25zdCBFeHRyYVNhbXBsZXNWYWx1ZXMgPSB7XG4gIFVuc3BlY2lmaWVkOiAwLFxuICBBc3NvY2FscGhhOiAxLFxuICBVbmFzc2FscGhhOiAyLFxufTtcblxuZXhwb3J0IGNvbnN0IExlcmNQYXJhbWV0ZXJzID0ge1xuICBWZXJzaW9uOiAwLFxuICBBZGRDb21wcmVzc2lvbjogMSxcbn07XG5cbmV4cG9ydCBjb25zdCBMZXJjQWRkQ29tcHJlc3Npb24gPSB7XG4gIE5vbmU6IDAsXG4gIERlZmxhdGU6IDEsXG4gIFpzdGFuZGFyZDogMixcbn07XG5cbmV4cG9ydCBjb25zdCBnZW9LZXlOYW1lcyA9IHtcbiAgMTAyNDogJ0dUTW9kZWxUeXBlR2VvS2V5JyxcbiAgMTAyNTogJ0dUUmFzdGVyVHlwZUdlb0tleScsXG4gIDEwMjY6ICdHVENpdGF0aW9uR2VvS2V5JyxcbiAgMjA0ODogJ0dlb2dyYXBoaWNUeXBlR2VvS2V5JyxcbiAgMjA0OTogJ0dlb2dDaXRhdGlvbkdlb0tleScsXG4gIDIwNTA6ICdHZW9nR2VvZGV0aWNEYXR1bUdlb0tleScsXG4gIDIwNTE6ICdHZW9nUHJpbWVNZXJpZGlhbkdlb0tleScsXG4gIDIwNTI6ICdHZW9nTGluZWFyVW5pdHNHZW9LZXknLFxuICAyMDUzOiAnR2VvZ0xpbmVhclVuaXRTaXplR2VvS2V5JyxcbiAgMjA1NDogJ0dlb2dBbmd1bGFyVW5pdHNHZW9LZXknLFxuICAyMDU1OiAnR2VvZ0FuZ3VsYXJVbml0U2l6ZUdlb0tleScsXG4gIDIwNTY6ICdHZW9nRWxsaXBzb2lkR2VvS2V5JyxcbiAgMjA1NzogJ0dlb2dTZW1pTWFqb3JBeGlzR2VvS2V5JyxcbiAgMjA1ODogJ0dlb2dTZW1pTWlub3JBeGlzR2VvS2V5JyxcbiAgMjA1OTogJ0dlb2dJbnZGbGF0dGVuaW5nR2VvS2V5JyxcbiAgMjA2MDogJ0dlb2dBemltdXRoVW5pdHNHZW9LZXknLFxuICAyMDYxOiAnR2VvZ1ByaW1lTWVyaWRpYW5Mb25nR2VvS2V5JyxcbiAgMjA2MjogJ0dlb2dUT1dHUzg0R2VvS2V5JyxcbiAgMzA3MjogJ1Byb2plY3RlZENTVHlwZUdlb0tleScsXG4gIDMwNzM6ICdQQ1NDaXRhdGlvbkdlb0tleScsXG4gIDMwNzQ6ICdQcm9qZWN0aW9uR2VvS2V5JyxcbiAgMzA3NTogJ1Byb2pDb29yZFRyYW5zR2VvS2V5JyxcbiAgMzA3NjogJ1Byb2pMaW5lYXJVbml0c0dlb0tleScsXG4gIDMwNzc6ICdQcm9qTGluZWFyVW5pdFNpemVHZW9LZXknLFxuICAzMDc4OiAnUHJvalN0ZFBhcmFsbGVsMUdlb0tleScsXG4gIDMwNzk6ICdQcm9qU3RkUGFyYWxsZWwyR2VvS2V5JyxcbiAgMzA4MDogJ1Byb2pOYXRPcmlnaW5Mb25nR2VvS2V5JyxcbiAgMzA4MTogJ1Byb2pOYXRPcmlnaW5MYXRHZW9LZXknLFxuICAzMDgyOiAnUHJvakZhbHNlRWFzdGluZ0dlb0tleScsXG4gIDMwODM6ICdQcm9qRmFsc2VOb3J0aGluZ0dlb0tleScsXG4gIDMwODQ6ICdQcm9qRmFsc2VPcmlnaW5Mb25nR2VvS2V5JyxcbiAgMzA4NTogJ1Byb2pGYWxzZU9yaWdpbkxhdEdlb0tleScsXG4gIDMwODY6ICdQcm9qRmFsc2VPcmlnaW5FYXN0aW5nR2VvS2V5JyxcbiAgMzA4NzogJ1Byb2pGYWxzZU9yaWdpbk5vcnRoaW5nR2VvS2V5JyxcbiAgMzA4ODogJ1Byb2pDZW50ZXJMb25nR2VvS2V5JyxcbiAgMzA4OTogJ1Byb2pDZW50ZXJMYXRHZW9LZXknLFxuICAzMDkwOiAnUHJvakNlbnRlckVhc3RpbmdHZW9LZXknLFxuICAzMDkxOiAnUHJvakNlbnRlck5vcnRoaW5nR2VvS2V5JyxcbiAgMzA5MjogJ1Byb2pTY2FsZUF0TmF0T3JpZ2luR2VvS2V5JyxcbiAgMzA5MzogJ1Byb2pTY2FsZUF0Q2VudGVyR2VvS2V5JyxcbiAgMzA5NDogJ1Byb2pBemltdXRoQW5nbGVHZW9LZXknLFxuICAzMDk1OiAnUHJvalN0cmFpZ2h0VmVydFBvbGVMb25nR2VvS2V5JyxcbiAgMzA5NjogJ1Byb2pSZWN0aWZpZWRHcmlkQW5nbGVHZW9LZXknLFxuICA0MDk2OiAnVmVydGljYWxDU1R5cGVHZW9LZXknLFxuICA0MDk3OiAnVmVydGljYWxDaXRhdGlvbkdlb0tleScsXG4gIDQwOTg6ICdWZXJ0aWNhbERhdHVtR2VvS2V5JyxcbiAgNDA5OTogJ1ZlcnRpY2FsVW5pdHNHZW9LZXknLFxufTtcblxuZXhwb3J0IGNvbnN0IGdlb0tleXMgPSB7fTtcbmZvciAoY29uc3Qga2V5IGluIGdlb0tleU5hbWVzKSB7XG4gIGlmIChnZW9LZXlOYW1lcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgZ2VvS2V5c1tnZW9LZXlOYW1lc1trZXldXSA9IHBhcnNlSW50KGtleSwgMTApO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/globals.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/logging.js":
/*!*****************************************************!*\
  !*** ./node_modules/geotiff/dist-module/logging.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   debug: () => (/* binding */ debug),\n/* harmony export */   error: () => (/* binding */ error),\n/* harmony export */   info: () => (/* binding */ info),\n/* harmony export */   log: () => (/* binding */ log),\n/* harmony export */   setLogger: () => (/* binding */ setLogger),\n/* harmony export */   time: () => (/* binding */ time),\n/* harmony export */   timeEnd: () => (/* binding */ timeEnd),\n/* harmony export */   warn: () => (/* binding */ warn)\n/* harmony export */ });\n/**\n * A no-op logger\n */\nclass DummyLogger {\n  log() {}\n\n  debug() {}\n\n  info() {}\n\n  warn() {}\n\n  error() {}\n\n  time() {}\n\n  timeEnd() {}\n}\n\nlet LOGGER = new DummyLogger();\n\n/**\n *\n * @param {object} logger the new logger. e.g `console`\n */\nfunction setLogger(logger = new DummyLogger()) {\n  LOGGER = logger;\n}\n\nfunction debug(...args) {\n  return LOGGER.debug(...args);\n}\n\nfunction log(...args) {\n  return LOGGER.log(...args);\n}\n\nfunction info(...args) {\n  return LOGGER.info(...args);\n}\n\nfunction warn(...args) {\n  return LOGGER.warn(...args);\n}\n\nfunction error(...args) {\n  return LOGGER.error(...args);\n}\n\nfunction time(...args) {\n  return LOGGER.time(...args);\n}\n\nfunction timeEnd(...args) {\n  return LOGGER.timeEnd(...args);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9sb2dnaW5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlcnJpYWpzLW1hcC8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL2xvZ2dpbmcuanM/OTQ4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEEgbm8tb3AgbG9nZ2VyXG4gKi9cbmNsYXNzIER1bW15TG9nZ2VyIHtcbiAgbG9nKCkge31cblxuICBkZWJ1ZygpIHt9XG5cbiAgaW5mbygpIHt9XG5cbiAgd2FybigpIHt9XG5cbiAgZXJyb3IoKSB7fVxuXG4gIHRpbWUoKSB7fVxuXG4gIHRpbWVFbmQoKSB7fVxufVxuXG5sZXQgTE9HR0VSID0gbmV3IER1bW15TG9nZ2VyKCk7XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBsb2dnZXIgdGhlIG5ldyBsb2dnZXIuIGUuZyBgY29uc29sZWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldExvZ2dlcihsb2dnZXIgPSBuZXcgRHVtbXlMb2dnZXIoKSkge1xuICBMT0dHRVIgPSBsb2dnZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWJ1ZyguLi5hcmdzKSB7XG4gIHJldHVybiBMT0dHRVIuZGVidWcoLi4uYXJncyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2coLi4uYXJncykge1xuICByZXR1cm4gTE9HR0VSLmxvZyguLi5hcmdzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluZm8oLi4uYXJncykge1xuICByZXR1cm4gTE9HR0VSLmluZm8oLi4uYXJncyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3YXJuKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIExPR0dFUi53YXJuKC4uLmFyZ3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXJyb3IoLi4uYXJncykge1xuICByZXR1cm4gTE9HR0VSLmVycm9yKC4uLmFyZ3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGltZSguLi5hcmdzKSB7XG4gIHJldHVybiBMT0dHRVIudGltZSguLi5hcmdzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRpbWVFbmQoLi4uYXJncykge1xuICByZXR1cm4gTE9HR0VSLnRpbWVFbmQoLi4uYXJncyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/logging.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/pool.js":
/*!**************************************************!*\
  !*** ./node_modules/geotiff/dist-module/pool.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _compression_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compression/index.js */ \"./node_modules/geotiff/dist-module/compression/index.js\");\n\n\nconst defaultPoolSize = typeof navigator !== 'undefined' ? (navigator.hardwareConcurrency || 2) : 2;\n\n/**\n * @module pool\n */\n\n/**\n * Pool for workers to decode chunks of the images.\n */\nclass Pool {\n  /**\n   * @constructor\n   * @param {Number} [size] The size of the pool. Defaults to the number of CPUs\n   *                      available. When this parameter is `null` or 0, then the\n   *                      decoding will be done in the main thread.\n   * @param {function(): Worker} [createWorker] A function that creates the decoder worker.\n   * Defaults to a worker with all decoders that ship with geotiff.js. The `createWorker()`\n   * function is expected to return a `Worker` compatible with Web Workers. For code that\n   * runs in Node, [web-worker](https://www.npmjs.com/package/web-worker) is a good choice.\n   *\n   * A worker that uses a custom lzw decoder would look like this `my-custom-worker.js` file:\n   * ```js\n   * import { addDecoder, getDecoder } from 'geotiff';\n   * addDecoder(5, () => import ('./my-custom-lzw').then((m) => m.default));\n   * self.addEventListener('message', async (e) => {\n   *   const { id, fileDirectory, buffer } = e.data;\n   *   const decoder = await getDecoder(fileDirectory);\n   *   const decoded = await decoder.decode(fileDirectory, buffer);\n   *   self.postMessage({ decoded, id }, [decoded]);\n   * });\n   * ```\n   * The way the above code is built into a worker by the `createWorker()` function\n   * depends on the used bundler. For most bundlers, something like this will work:\n   * ```js\n   * function createWorker() {\n   *   return new Worker(new URL('./my-custom-worker.js', import.meta.url));\n   * }\n   * ```\n   */\n  constructor(size = defaultPoolSize, createWorker) {\n    this.workers = null;\n    this._awaitingDecoder = null;\n    this.size = size;\n    this.messageId = 0;\n    if (size) {\n      this._awaitingDecoder = createWorker ? Promise.resolve(createWorker) : new Promise((resolve) => {\n        __webpack_require__.e(/*! import() */ \"vendors-node_modules_geotiff_dist-module_worker_decoder_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./worker/decoder.js */ \"./node_modules/geotiff/dist-module/worker/decoder.js\")).then((module) => {\n          resolve(module.create);\n        });\n      });\n      this._awaitingDecoder.then((create) => {\n        this._awaitingDecoder = null;\n        this.workers = [];\n        for (let i = 0; i < size; i++) {\n          this.workers.push({ worker: create(), idle: true });\n        }\n      });\n    }\n  }\n\n  /**\n   * Decode the given block of bytes with the set compression method.\n   * @param {ArrayBuffer} buffer the array buffer of bytes to decode.\n   * @returns {Promise<ArrayBuffer>} the decoded result as a `Promise`\n   */\n  async decode(fileDirectory, buffer) {\n    if (this._awaitingDecoder) {\n      await this._awaitingDecoder;\n    }\n    return this.size === 0\n      ? (0,_compression_index_js__WEBPACK_IMPORTED_MODULE_0__.getDecoder)(fileDirectory).then((decoder) => decoder.decode(fileDirectory, buffer))\n      : new Promise((resolve) => {\n        const worker = this.workers.find((candidate) => candidate.idle)\n          || this.workers[Math.floor(Math.random() * this.size)];\n        worker.idle = false;\n        const id = this.messageId++;\n        const onMessage = (e) => {\n          if (e.data.id === id) {\n            worker.idle = true;\n            resolve(e.data.decoded);\n            worker.worker.removeEventListener('message', onMessage);\n          }\n        };\n        worker.worker.addEventListener('message', onMessage);\n        worker.worker.postMessage({ fileDirectory, buffer, id }, [buffer]);\n      });\n  }\n\n  destroy() {\n    if (this.workers) {\n      this.workers.forEach((worker) => {\n        worker.worker.terminate();\n      });\n      this.workers = null;\n    }\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Pool);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9wb29sLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlcnJpYWpzLW1hcC8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3Bvb2wuanM/YjEwNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXREZWNvZGVyIH0gZnJvbSAnLi9jb21wcmVzc2lvbi9pbmRleC5qcyc7XG5cbmNvbnN0IGRlZmF1bHRQb29sU2l6ZSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnID8gKG5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5IHx8IDIpIDogMjtcblxuLyoqXG4gKiBAbW9kdWxlIHBvb2xcbiAqL1xuXG4vKipcbiAqIFBvb2wgZm9yIHdvcmtlcnMgdG8gZGVjb2RlIGNodW5rcyBvZiB0aGUgaW1hZ2VzLlxuICovXG5jbGFzcyBQb29sIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge051bWJlcn0gW3NpemVdIFRoZSBzaXplIG9mIHRoZSBwb29sLiBEZWZhdWx0cyB0byB0aGUgbnVtYmVyIG9mIENQVXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlLiBXaGVuIHRoaXMgcGFyYW1ldGVyIGlzIGBudWxsYCBvciAwLCB0aGVuIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICBkZWNvZGluZyB3aWxsIGJlIGRvbmUgaW4gdGhlIG1haW4gdGhyZWFkLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IFdvcmtlcn0gW2NyZWF0ZVdvcmtlcl0gQSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgdGhlIGRlY29kZXIgd29ya2VyLlxuICAgKiBEZWZhdWx0cyB0byBhIHdvcmtlciB3aXRoIGFsbCBkZWNvZGVycyB0aGF0IHNoaXAgd2l0aCBnZW90aWZmLmpzLiBUaGUgYGNyZWF0ZVdvcmtlcigpYFxuICAgKiBmdW5jdGlvbiBpcyBleHBlY3RlZCB0byByZXR1cm4gYSBgV29ya2VyYCBjb21wYXRpYmxlIHdpdGggV2ViIFdvcmtlcnMuIEZvciBjb2RlIHRoYXRcbiAgICogcnVucyBpbiBOb2RlLCBbd2ViLXdvcmtlcl0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvd2ViLXdvcmtlcikgaXMgYSBnb29kIGNob2ljZS5cbiAgICpcbiAgICogQSB3b3JrZXIgdGhhdCB1c2VzIGEgY3VzdG9tIGx6dyBkZWNvZGVyIHdvdWxkIGxvb2sgbGlrZSB0aGlzIGBteS1jdXN0b20td29ya2VyLmpzYCBmaWxlOlxuICAgKiBgYGBqc1xuICAgKiBpbXBvcnQgeyBhZGREZWNvZGVyLCBnZXREZWNvZGVyIH0gZnJvbSAnZ2VvdGlmZic7XG4gICAqIGFkZERlY29kZXIoNSwgKCkgPT4gaW1wb3J0ICgnLi9teS1jdXN0b20tbHp3JykudGhlbigobSkgPT4gbS5kZWZhdWx0KSk7XG4gICAqIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGFzeW5jIChlKSA9PiB7XG4gICAqICAgY29uc3QgeyBpZCwgZmlsZURpcmVjdG9yeSwgYnVmZmVyIH0gPSBlLmRhdGE7XG4gICAqICAgY29uc3QgZGVjb2RlciA9IGF3YWl0IGdldERlY29kZXIoZmlsZURpcmVjdG9yeSk7XG4gICAqICAgY29uc3QgZGVjb2RlZCA9IGF3YWl0IGRlY29kZXIuZGVjb2RlKGZpbGVEaXJlY3RvcnksIGJ1ZmZlcik7XG4gICAqICAgc2VsZi5wb3N0TWVzc2FnZSh7IGRlY29kZWQsIGlkIH0sIFtkZWNvZGVkXSk7XG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICogVGhlIHdheSB0aGUgYWJvdmUgY29kZSBpcyBidWlsdCBpbnRvIGEgd29ya2VyIGJ5IHRoZSBgY3JlYXRlV29ya2VyKClgIGZ1bmN0aW9uXG4gICAqIGRlcGVuZHMgb24gdGhlIHVzZWQgYnVuZGxlci4gRm9yIG1vc3QgYnVuZGxlcnMsIHNvbWV0aGluZyBsaWtlIHRoaXMgd2lsbCB3b3JrOlxuICAgKiBgYGBqc1xuICAgKiBmdW5jdGlvbiBjcmVhdGVXb3JrZXIoKSB7XG4gICAqICAgcmV0dXJuIG5ldyBXb3JrZXIobmV3IFVSTCgnLi9teS1jdXN0b20td29ya2VyLmpzJywgaW1wb3J0Lm1ldGEudXJsKSk7XG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzaXplID0gZGVmYXVsdFBvb2xTaXplLCBjcmVhdGVXb3JrZXIpIHtcbiAgICB0aGlzLndvcmtlcnMgPSBudWxsO1xuICAgIHRoaXMuX2F3YWl0aW5nRGVjb2RlciA9IG51bGw7XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB0aGlzLm1lc3NhZ2VJZCA9IDA7XG4gICAgaWYgKHNpemUpIHtcbiAgICAgIHRoaXMuX2F3YWl0aW5nRGVjb2RlciA9IGNyZWF0ZVdvcmtlciA/IFByb21pc2UucmVzb2x2ZShjcmVhdGVXb3JrZXIpIDogbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgaW1wb3J0KCcuL3dvcmtlci9kZWNvZGVyLmpzJykudGhlbigobW9kdWxlKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZShtb2R1bGUuY3JlYXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2F3YWl0aW5nRGVjb2Rlci50aGVuKChjcmVhdGUpID0+IHtcbiAgICAgICAgdGhpcy5fYXdhaXRpbmdEZWNvZGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy53b3JrZXJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgdGhpcy53b3JrZXJzLnB1c2goeyB3b3JrZXI6IGNyZWF0ZSgpLCBpZGxlOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIHRoZSBnaXZlbiBibG9jayBvZiBieXRlcyB3aXRoIHRoZSBzZXQgY29tcHJlc3Npb24gbWV0aG9kLlxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBidWZmZXIgdGhlIGFycmF5IGJ1ZmZlciBvZiBieXRlcyB0byBkZWNvZGUuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5QnVmZmVyPn0gdGhlIGRlY29kZWQgcmVzdWx0IGFzIGEgYFByb21pc2VgXG4gICAqL1xuICBhc3luYyBkZWNvZGUoZmlsZURpcmVjdG9yeSwgYnVmZmVyKSB7XG4gICAgaWYgKHRoaXMuX2F3YWl0aW5nRGVjb2Rlcikge1xuICAgICAgYXdhaXQgdGhpcy5fYXdhaXRpbmdEZWNvZGVyO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zaXplID09PSAwXG4gICAgICA/IGdldERlY29kZXIoZmlsZURpcmVjdG9yeSkudGhlbigoZGVjb2RlcikgPT4gZGVjb2Rlci5kZWNvZGUoZmlsZURpcmVjdG9yeSwgYnVmZmVyKSlcbiAgICAgIDogbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY29uc3Qgd29ya2VyID0gdGhpcy53b3JrZXJzLmZpbmQoKGNhbmRpZGF0ZSkgPT4gY2FuZGlkYXRlLmlkbGUpXG4gICAgICAgICAgfHwgdGhpcy53b3JrZXJzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHRoaXMuc2l6ZSldO1xuICAgICAgICB3b3JrZXIuaWRsZSA9IGZhbHNlO1xuICAgICAgICBjb25zdCBpZCA9IHRoaXMubWVzc2FnZUlkKys7XG4gICAgICAgIGNvbnN0IG9uTWVzc2FnZSA9IChlKSA9PiB7XG4gICAgICAgICAgaWYgKGUuZGF0YS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgIHdvcmtlci5pZGxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc29sdmUoZS5kYXRhLmRlY29kZWQpO1xuICAgICAgICAgICAgd29ya2VyLndvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb25NZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHdvcmtlci53b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG9uTWVzc2FnZSk7XG4gICAgICAgIHdvcmtlci53b3JrZXIucG9zdE1lc3NhZ2UoeyBmaWxlRGlyZWN0b3J5LCBidWZmZXIsIGlkIH0sIFtidWZmZXJdKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy53b3JrZXJzKSB7XG4gICAgICB0aGlzLndvcmtlcnMuZm9yRWFjaCgod29ya2VyKSA9PiB7XG4gICAgICAgIHdvcmtlci53b3JrZXIudGVybWluYXRlKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMud29ya2VycyA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBvb2w7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/pool.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/predictor.js":
/*!*******************************************************!*\
  !*** ./node_modules/geotiff/dist-module/predictor.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyPredictor: () => (/* binding */ applyPredictor)\n/* harmony export */ });\nfunction decodeRowAcc(row, stride) {\n  let length = row.length - stride;\n  let offset = 0;\n  do {\n    for (let i = stride; i > 0; i--) {\n      row[offset + stride] += row[offset];\n      offset++;\n    }\n\n    length -= stride;\n  } while (length > 0);\n}\n\nfunction decodeRowFloatingPoint(row, stride, bytesPerSample) {\n  let index = 0;\n  let count = row.length;\n  const wc = count / bytesPerSample;\n\n  while (count > stride) {\n    for (let i = stride; i > 0; --i) {\n      row[index + stride] += row[index];\n      ++index;\n    }\n    count -= stride;\n  }\n\n  const copy = row.slice();\n  for (let i = 0; i < wc; ++i) {\n    for (let b = 0; b < bytesPerSample; ++b) {\n      row[(bytesPerSample * i) + b] = copy[((bytesPerSample - b - 1) * wc) + i];\n    }\n  }\n}\n\nfunction applyPredictor(block, predictor, width, height, bitsPerSample,\n  planarConfiguration) {\n  if (!predictor || predictor === 1) {\n    return block;\n  }\n\n  for (let i = 0; i < bitsPerSample.length; ++i) {\n    if (bitsPerSample[i] % 8 !== 0) {\n      throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');\n    }\n    if (bitsPerSample[i] !== bitsPerSample[0]) {\n      throw new Error('When decoding with predictor, all samples must have the same size.');\n    }\n  }\n\n  const bytesPerSample = bitsPerSample[0] / 8;\n  const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;\n\n  for (let i = 0; i < height; ++i) {\n    // Last strip will be truncated if height % stripHeight != 0\n    if (i * stride * width * bytesPerSample >= block.byteLength) {\n      break;\n    }\n    let row;\n    if (predictor === 2) { // horizontal prediction\n      switch (bitsPerSample[0]) {\n        case 8:\n          row = new Uint8Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n          );\n          break;\n        case 16:\n          row = new Uint16Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 2,\n          );\n          break;\n        case 32:\n          row = new Uint32Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 4,\n          );\n          break;\n        default:\n          throw new Error(`Predictor 2 not allowed with ${bitsPerSample[0]} bits per sample.`);\n      }\n      decodeRowAcc(row, stride, bytesPerSample);\n    } else if (predictor === 3) { // horizontal floating point\n      row = new Uint8Array(\n        block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n      );\n      decodeRowFloatingPoint(row, stride, bytesPerSample);\n    }\n  }\n  return block;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9wcmVkaWN0b3IuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVycmlhanMtbWFwLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvcHJlZGljdG9yLmpzP2JhZjEiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gZGVjb2RlUm93QWNjKHJvdywgc3RyaWRlKSB7XG4gIGxldCBsZW5ndGggPSByb3cubGVuZ3RoIC0gc3RyaWRlO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZG8ge1xuICAgIGZvciAobGV0IGkgPSBzdHJpZGU7IGkgPiAwOyBpLS0pIHtcbiAgICAgIHJvd1tvZmZzZXQgKyBzdHJpZGVdICs9IHJvd1tvZmZzZXRdO1xuICAgICAgb2Zmc2V0Kys7XG4gICAgfVxuXG4gICAgbGVuZ3RoIC09IHN0cmlkZTtcbiAgfSB3aGlsZSAobGVuZ3RoID4gMCk7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVJvd0Zsb2F0aW5nUG9pbnQocm93LCBzdHJpZGUsIGJ5dGVzUGVyU2FtcGxlKSB7XG4gIGxldCBpbmRleCA9IDA7XG4gIGxldCBjb3VudCA9IHJvdy5sZW5ndGg7XG4gIGNvbnN0IHdjID0gY291bnQgLyBieXRlc1BlclNhbXBsZTtcblxuICB3aGlsZSAoY291bnQgPiBzdHJpZGUpIHtcbiAgICBmb3IgKGxldCBpID0gc3RyaWRlOyBpID4gMDsgLS1pKSB7XG4gICAgICByb3dbaW5kZXggKyBzdHJpZGVdICs9IHJvd1tpbmRleF07XG4gICAgICArK2luZGV4O1xuICAgIH1cbiAgICBjb3VudCAtPSBzdHJpZGU7XG4gIH1cblxuICBjb25zdCBjb3B5ID0gcm93LnNsaWNlKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgd2M7ICsraSkge1xuICAgIGZvciAobGV0IGIgPSAwOyBiIDwgYnl0ZXNQZXJTYW1wbGU7ICsrYikge1xuICAgICAgcm93WyhieXRlc1BlclNhbXBsZSAqIGkpICsgYl0gPSBjb3B5WygoYnl0ZXNQZXJTYW1wbGUgLSBiIC0gMSkgKiB3YykgKyBpXTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UHJlZGljdG9yKGJsb2NrLCBwcmVkaWN0b3IsIHdpZHRoLCBoZWlnaHQsIGJpdHNQZXJTYW1wbGUsXG4gIHBsYW5hckNvbmZpZ3VyYXRpb24pIHtcbiAgaWYgKCFwcmVkaWN0b3IgfHwgcHJlZGljdG9yID09PSAxKSB7XG4gICAgcmV0dXJuIGJsb2NrO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaXRzUGVyU2FtcGxlLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGJpdHNQZXJTYW1wbGVbaV0gJSA4ICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1doZW4gZGVjb2Rpbmcgd2l0aCBwcmVkaWN0b3IsIG9ubHkgbXVsdGlwbGUgb2YgOCBiaXRzIGFyZSBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuICAgIGlmIChiaXRzUGVyU2FtcGxlW2ldICE9PSBiaXRzUGVyU2FtcGxlWzBdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1doZW4gZGVjb2Rpbmcgd2l0aCBwcmVkaWN0b3IsIGFsbCBzYW1wbGVzIG11c3QgaGF2ZSB0aGUgc2FtZSBzaXplLicpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGJ5dGVzUGVyU2FtcGxlID0gYml0c1BlclNhbXBsZVswXSAvIDg7XG4gIGNvbnN0IHN0cmlkZSA9IHBsYW5hckNvbmZpZ3VyYXRpb24gPT09IDIgPyAxIDogYml0c1BlclNhbXBsZS5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWlnaHQ7ICsraSkge1xuICAgIC8vIExhc3Qgc3RyaXAgd2lsbCBiZSB0cnVuY2F0ZWQgaWYgaGVpZ2h0ICUgc3RyaXBIZWlnaHQgIT0gMFxuICAgIGlmIChpICogc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSA+PSBibG9jay5ieXRlTGVuZ3RoKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbGV0IHJvdztcbiAgICBpZiAocHJlZGljdG9yID09PSAyKSB7IC8vIGhvcml6b250YWwgcHJlZGljdGlvblxuICAgICAgc3dpdGNoIChiaXRzUGVyU2FtcGxlWzBdKSB7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICByb3cgPSBuZXcgVWludDhBcnJheShcbiAgICAgICAgICAgIGJsb2NrLCBpICogc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSwgc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIHJvdyA9IG5ldyBVaW50MTZBcnJheShcbiAgICAgICAgICAgIGJsb2NrLCBpICogc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSwgc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSAvIDIsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICByb3cgPSBuZXcgVWludDMyQXJyYXkoXG4gICAgICAgICAgICBibG9jaywgaSAqIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUsIHN0cmlkZSAqIHdpZHRoICogYnl0ZXNQZXJTYW1wbGUgLyA0LFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcmVkaWN0b3IgMiBub3QgYWxsb3dlZCB3aXRoICR7Yml0c1BlclNhbXBsZVswXX0gYml0cyBwZXIgc2FtcGxlLmApO1xuICAgICAgfVxuICAgICAgZGVjb2RlUm93QWNjKHJvdywgc3RyaWRlLCBieXRlc1BlclNhbXBsZSk7XG4gICAgfSBlbHNlIGlmIChwcmVkaWN0b3IgPT09IDMpIHsgLy8gaG9yaXpvbnRhbCBmbG9hdGluZyBwb2ludFxuICAgICAgcm93ID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgIGJsb2NrLCBpICogc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSwgc3RyaWRlICogd2lkdGggKiBieXRlc1BlclNhbXBsZSxcbiAgICAgICk7XG4gICAgICBkZWNvZGVSb3dGbG9hdGluZ1BvaW50KHJvdywgc3RyaWRlLCBieXRlc1BlclNhbXBsZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBibG9jaztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/predictor.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/resample.js":
/*!******************************************************!*\
  !*** ./node_modules/geotiff/dist-module/resample.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   resample: () => (/* binding */ resample),\n/* harmony export */   resampleBilinear: () => (/* binding */ resampleBilinear),\n/* harmony export */   resampleBilinearInterleaved: () => (/* binding */ resampleBilinearInterleaved),\n/* harmony export */   resampleInterleaved: () => (/* binding */ resampleInterleaved),\n/* harmony export */   resampleNearest: () => (/* binding */ resampleNearest),\n/* harmony export */   resampleNearestInterleaved: () => (/* binding */ resampleNearestInterleaved)\n/* harmony export */ });\n/**\n * @module resample\n */\n\nfunction copyNewSize(array, width, height, samplesPerPixel = 1) {\n  return new (Object.getPrototypeOf(array).constructor)(width * height * samplesPerPixel);\n}\n\n/**\n * Resample the input arrays using nearest neighbor value selection.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nfunction resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const cy = Math.min(Math.round(relY * y), inHeight - 1);\n      for (let x = 0; x < outWidth; ++x) {\n        const cx = Math.min(Math.round(relX * x), inWidth - 1);\n        const value = array[(cy * inWidth) + cx];\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n// simple linear interpolation, code from:\n// https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\nfunction lerp(v0, v1, t) {\n  return ((1 - t) * v0) + (t * v1);\n}\n\n/**\n * Resample the input arrays using bilinear interpolation.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nfunction resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const rawY = relY * y;\n\n      const yl = Math.floor(rawY);\n      const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n      for (let x = 0; x < outWidth; ++x) {\n        const rawX = relX * x;\n        const tx = rawX % 1;\n\n        const xl = Math.floor(rawX);\n        const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n        const ll = array[(yl * inWidth) + xl];\n        const hl = array[(yl * inWidth) + xh];\n        const lh = array[(yh * inWidth) + xl];\n        const hh = array[(yh * inWidth) + xh];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n/**\n * Resample the input arrays using the selected resampling method.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray[]} The resampled rasters\n */\nfunction resample(valueArrays, inWidth, inHeight, outWidth, outHeight, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n\n/**\n * Resample the pixel interleaved input array using nearest neighbor value selection.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nfunction resampleNearestInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const cy = Math.min(Math.round(relY * y), inHeight - 1);\n    for (let x = 0; x < outWidth; ++x) {\n      const cx = Math.min(Math.round(relX * x), inWidth - 1);\n      for (let i = 0; i < samples; ++i) {\n        const value = valueArray[(cy * inWidth * samples) + (cx * samples) + i];\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using bilinear interpolation.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nfunction resampleBilinearInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const rawY = relY * y;\n\n    const yl = Math.floor(rawY);\n    const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n    for (let x = 0; x < outWidth; ++x) {\n      const rawX = relX * x;\n      const tx = rawX % 1;\n\n      const xl = Math.floor(rawX);\n      const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n      for (let i = 0; i < samples; ++i) {\n        const ll = valueArray[(yl * inWidth * samples) + (xl * samples) + i];\n        const hl = valueArray[(yl * inWidth * samples) + (xh * samples) + i];\n        const lh = valueArray[(yh * inWidth * samples) + (xl * samples) + i];\n        const hh = valueArray[(yh * inWidth * samples) + (xh * samples) + i];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using the selected resampling method.\n * @param {TypedArray} valueArray The input array to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                                 interleaved data\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray} The resampled rasters\n */\nfunction resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearestInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinearInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9yZXNhbXBsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlcnJpYWpzLW1hcC8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3Jlc2FtcGxlLmpzPzM4OGMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIHJlc2FtcGxlXG4gKi9cblxuZnVuY3Rpb24gY29weU5ld1NpemUoYXJyYXksIHdpZHRoLCBoZWlnaHQsIHNhbXBsZXNQZXJQaXhlbCA9IDEpIHtcbiAgcmV0dXJuIG5ldyAoT2JqZWN0LmdldFByb3RvdHlwZU9mKGFycmF5KS5jb25zdHJ1Y3Rvcikod2lkdGggKiBoZWlnaHQgKiBzYW1wbGVzUGVyUGl4ZWwpO1xufVxuXG4vKipcbiAqIFJlc2FtcGxlIHRoZSBpbnB1dCBhcnJheXMgdXNpbmcgbmVhcmVzdCBuZWlnaGJvciB2YWx1ZSBzZWxlY3Rpb24uXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXlbXX0gdmFsdWVBcnJheXMgVGhlIGlucHV0IGFycmF5cyB0byByZXNhbXBsZVxuICogQHBhcmFtIHtudW1iZXJ9IGluV2lkdGggVGhlIHdpZHRoIG9mIHRoZSBpbnB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gaW5IZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgaW5wdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dFdpZHRoIFRoZSBkZXNpcmVkIHdpZHRoIG9mIHRoZSBvdXRwdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dEhlaWdodCBUaGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIG91dHB1dCByYXN0ZXJzXG4gKiBAcmV0dXJucyB7VHlwZWRBcnJheVtdfSBUaGUgcmVzYW1wbGVkIHJhc3RlcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2FtcGxlTmVhcmVzdCh2YWx1ZUFycmF5cywgaW5XaWR0aCwgaW5IZWlnaHQsIG91dFdpZHRoLCBvdXRIZWlnaHQpIHtcbiAgY29uc3QgcmVsWCA9IGluV2lkdGggLyBvdXRXaWR0aDtcbiAgY29uc3QgcmVsWSA9IGluSGVpZ2h0IC8gb3V0SGVpZ2h0O1xuICByZXR1cm4gdmFsdWVBcnJheXMubWFwKChhcnJheSkgPT4ge1xuICAgIGNvbnN0IG5ld0FycmF5ID0gY29weU5ld1NpemUoYXJyYXksIG91dFdpZHRoLCBvdXRIZWlnaHQpO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgb3V0SGVpZ2h0OyArK3kpIHtcbiAgICAgIGNvbnN0IGN5ID0gTWF0aC5taW4oTWF0aC5yb3VuZChyZWxZICogeSksIGluSGVpZ2h0IC0gMSk7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG91dFdpZHRoOyArK3gpIHtcbiAgICAgICAgY29uc3QgY3ggPSBNYXRoLm1pbihNYXRoLnJvdW5kKHJlbFggKiB4KSwgaW5XaWR0aCAtIDEpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGFycmF5WyhjeSAqIGluV2lkdGgpICsgY3hdO1xuICAgICAgICBuZXdBcnJheVsoeSAqIG91dFdpZHRoKSArIHhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdBcnJheTtcbiAgfSk7XG59XG5cbi8vIHNpbXBsZSBsaW5lYXIgaW50ZXJwb2xhdGlvbiwgY29kZSBmcm9tOlxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZWFyX2ludGVycG9sYXRpb24jUHJvZ3JhbW1pbmdfbGFuZ3VhZ2Vfc3VwcG9ydFxuZnVuY3Rpb24gbGVycCh2MCwgdjEsIHQpIHtcbiAgcmV0dXJuICgoMSAtIHQpICogdjApICsgKHQgKiB2MSk7XG59XG5cbi8qKlxuICogUmVzYW1wbGUgdGhlIGlucHV0IGFycmF5cyB1c2luZyBiaWxpbmVhciBpbnRlcnBvbGF0aW9uLlxuICogQHBhcmFtIHtUeXBlZEFycmF5W119IHZhbHVlQXJyYXlzIFRoZSBpbnB1dCBhcnJheXMgdG8gcmVzYW1wbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbldpZHRoIFRoZSB3aWR0aCBvZiB0aGUgaW5wdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IGluSGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIGlucHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRXaWR0aCBUaGUgZGVzaXJlZCB3aWR0aCBvZiB0aGUgb3V0cHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRIZWlnaHQgVGhlIGRlc2lyZWQgaGVpZ2h0IG9mIHRoZSBvdXRwdXQgcmFzdGVyc1xuICogQHJldHVybnMge1R5cGVkQXJyYXlbXX0gVGhlIHJlc2FtcGxlZCByYXN0ZXJzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNhbXBsZUJpbGluZWFyKHZhbHVlQXJyYXlzLCBpbldpZHRoLCBpbkhlaWdodCwgb3V0V2lkdGgsIG91dEhlaWdodCkge1xuICBjb25zdCByZWxYID0gaW5XaWR0aCAvIG91dFdpZHRoO1xuICBjb25zdCByZWxZID0gaW5IZWlnaHQgLyBvdXRIZWlnaHQ7XG5cbiAgcmV0dXJuIHZhbHVlQXJyYXlzLm1hcCgoYXJyYXkpID0+IHtcbiAgICBjb25zdCBuZXdBcnJheSA9IGNvcHlOZXdTaXplKGFycmF5LCBvdXRXaWR0aCwgb3V0SGVpZ2h0KTtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IG91dEhlaWdodDsgKyt5KSB7XG4gICAgICBjb25zdCByYXdZID0gcmVsWSAqIHk7XG5cbiAgICAgIGNvbnN0IHlsID0gTWF0aC5mbG9vcihyYXdZKTtcbiAgICAgIGNvbnN0IHloID0gTWF0aC5taW4oTWF0aC5jZWlsKHJhd1kpLCAoaW5IZWlnaHQgLSAxKSk7XG5cbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgb3V0V2lkdGg7ICsreCkge1xuICAgICAgICBjb25zdCByYXdYID0gcmVsWCAqIHg7XG4gICAgICAgIGNvbnN0IHR4ID0gcmF3WCAlIDE7XG5cbiAgICAgICAgY29uc3QgeGwgPSBNYXRoLmZsb29yKHJhd1gpO1xuICAgICAgICBjb25zdCB4aCA9IE1hdGgubWluKE1hdGguY2VpbChyYXdYKSwgKGluV2lkdGggLSAxKSk7XG5cbiAgICAgICAgY29uc3QgbGwgPSBhcnJheVsoeWwgKiBpbldpZHRoKSArIHhsXTtcbiAgICAgICAgY29uc3QgaGwgPSBhcnJheVsoeWwgKiBpbldpZHRoKSArIHhoXTtcbiAgICAgICAgY29uc3QgbGggPSBhcnJheVsoeWggKiBpbldpZHRoKSArIHhsXTtcbiAgICAgICAgY29uc3QgaGggPSBhcnJheVsoeWggKiBpbldpZHRoKSArIHhoXTtcblxuICAgICAgICBjb25zdCB2YWx1ZSA9IGxlcnAoXG4gICAgICAgICAgbGVycChsbCwgaGwsIHR4KSxcbiAgICAgICAgICBsZXJwKGxoLCBoaCwgdHgpLFxuICAgICAgICAgIHJhd1kgJSAxLFxuICAgICAgICApO1xuICAgICAgICBuZXdBcnJheVsoeSAqIG91dFdpZHRoKSArIHhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdBcnJheTtcbiAgfSk7XG59XG5cbi8qKlxuICogUmVzYW1wbGUgdGhlIGlucHV0IGFycmF5cyB1c2luZyB0aGUgc2VsZWN0ZWQgcmVzYW1wbGluZyBtZXRob2QuXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXlbXX0gdmFsdWVBcnJheXMgVGhlIGlucHV0IGFycmF5cyB0byByZXNhbXBsZVxuICogQHBhcmFtIHtudW1iZXJ9IGluV2lkdGggVGhlIHdpZHRoIG9mIHRoZSBpbnB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gaW5IZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgaW5wdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dFdpZHRoIFRoZSBkZXNpcmVkIHdpZHRoIG9mIHRoZSBvdXRwdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dEhlaWdodCBUaGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIG91dHB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge3N0cmluZ30gW21ldGhvZCA9ICduZWFyZXN0J10gVGhlIGRlc2lyZWQgcmVzYW1wbGluZyBtZXRob2RcbiAqIEByZXR1cm5zIHtUeXBlZEFycmF5W119IFRoZSByZXNhbXBsZWQgcmFzdGVyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzYW1wbGUodmFsdWVBcnJheXMsIGluV2lkdGgsIGluSGVpZ2h0LCBvdXRXaWR0aCwgb3V0SGVpZ2h0LCBtZXRob2QgPSAnbmVhcmVzdCcpIHtcbiAgc3dpdGNoIChtZXRob2QudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ25lYXJlc3QnOlxuICAgICAgcmV0dXJuIHJlc2FtcGxlTmVhcmVzdCh2YWx1ZUFycmF5cywgaW5XaWR0aCwgaW5IZWlnaHQsIG91dFdpZHRoLCBvdXRIZWlnaHQpO1xuICAgIGNhc2UgJ2JpbGluZWFyJzpcbiAgICBjYXNlICdsaW5lYXInOlxuICAgICAgcmV0dXJuIHJlc2FtcGxlQmlsaW5lYXIodmFsdWVBcnJheXMsIGluV2lkdGgsIGluSGVpZ2h0LCBvdXRXaWR0aCwgb3V0SGVpZ2h0KTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCByZXNhbXBsaW5nIG1ldGhvZDogJyR7bWV0aG9kfSdgKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlc2FtcGxlIHRoZSBwaXhlbCBpbnRlcmxlYXZlZCBpbnB1dCBhcnJheSB1c2luZyBuZWFyZXN0IG5laWdoYm9yIHZhbHVlIHNlbGVjdGlvbi5cbiAqIEBwYXJhbSB7VHlwZWRBcnJheX0gdmFsdWVBcnJheXMgVGhlIGlucHV0IGFycmF5cyB0byByZXNhbXBsZVxuICogQHBhcmFtIHtudW1iZXJ9IGluV2lkdGggVGhlIHdpZHRoIG9mIHRoZSBpbnB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gaW5IZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgaW5wdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dFdpZHRoIFRoZSBkZXNpcmVkIHdpZHRoIG9mIHRoZSBvdXRwdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IG91dEhlaWdodCBUaGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIG91dHB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gc2FtcGxlcyBUaGUgbnVtYmVyIG9mIHNhbXBsZXMgcGVyIHBpeGVsIGZvciBwaXhlbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJsZWF2ZWQgZGF0YVxuICogQHJldHVybnMge1R5cGVkQXJyYXl9IFRoZSByZXNhbXBsZWQgcmFzdGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNhbXBsZU5lYXJlc3RJbnRlcmxlYXZlZChcbiAgdmFsdWVBcnJheSwgaW5XaWR0aCwgaW5IZWlnaHQsIG91dFdpZHRoLCBvdXRIZWlnaHQsIHNhbXBsZXMpIHtcbiAgY29uc3QgcmVsWCA9IGluV2lkdGggLyBvdXRXaWR0aDtcbiAgY29uc3QgcmVsWSA9IGluSGVpZ2h0IC8gb3V0SGVpZ2h0O1xuXG4gIGNvbnN0IG5ld0FycmF5ID0gY29weU5ld1NpemUodmFsdWVBcnJheSwgb3V0V2lkdGgsIG91dEhlaWdodCwgc2FtcGxlcyk7XG4gIGZvciAobGV0IHkgPSAwOyB5IDwgb3V0SGVpZ2h0OyArK3kpIHtcbiAgICBjb25zdCBjeSA9IE1hdGgubWluKE1hdGgucm91bmQocmVsWSAqIHkpLCBpbkhlaWdodCAtIDEpO1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgb3V0V2lkdGg7ICsreCkge1xuICAgICAgY29uc3QgY3ggPSBNYXRoLm1pbihNYXRoLnJvdW5kKHJlbFggKiB4KSwgaW5XaWR0aCAtIDEpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzYW1wbGVzOyArK2kpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZUFycmF5WyhjeSAqIGluV2lkdGggKiBzYW1wbGVzKSArIChjeCAqIHNhbXBsZXMpICsgaV07XG4gICAgICAgIG5ld0FycmF5Wyh5ICogb3V0V2lkdGggKiBzYW1wbGVzKSArICh4ICogc2FtcGxlcykgKyBpXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3QXJyYXk7XG59XG5cbi8qKlxuICogUmVzYW1wbGUgdGhlIHBpeGVsIGludGVybGVhdmVkIGlucHV0IGFycmF5IHVzaW5nIGJpbGluZWFyIGludGVycG9sYXRpb24uXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXl9IHZhbHVlQXJyYXlzIFRoZSBpbnB1dCBhcnJheXMgdG8gcmVzYW1wbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbldpZHRoIFRoZSB3aWR0aCBvZiB0aGUgaW5wdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IGluSGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIGlucHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRXaWR0aCBUaGUgZGVzaXJlZCB3aWR0aCBvZiB0aGUgb3V0cHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBvdXRIZWlnaHQgVGhlIGRlc2lyZWQgaGVpZ2h0IG9mIHRoZSBvdXRwdXQgcmFzdGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IHNhbXBsZXMgVGhlIG51bWJlciBvZiBzYW1wbGVzIHBlciBwaXhlbCBmb3IgcGl4ZWxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybGVhdmVkIGRhdGFcbiAqIEByZXR1cm5zIHtUeXBlZEFycmF5fSBUaGUgcmVzYW1wbGVkIHJhc3RlclxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzYW1wbGVCaWxpbmVhckludGVybGVhdmVkKFxuICB2YWx1ZUFycmF5LCBpbldpZHRoLCBpbkhlaWdodCwgb3V0V2lkdGgsIG91dEhlaWdodCwgc2FtcGxlcykge1xuICBjb25zdCByZWxYID0gaW5XaWR0aCAvIG91dFdpZHRoO1xuICBjb25zdCByZWxZID0gaW5IZWlnaHQgLyBvdXRIZWlnaHQ7XG4gIGNvbnN0IG5ld0FycmF5ID0gY29weU5ld1NpemUodmFsdWVBcnJheSwgb3V0V2lkdGgsIG91dEhlaWdodCwgc2FtcGxlcyk7XG4gIGZvciAobGV0IHkgPSAwOyB5IDwgb3V0SGVpZ2h0OyArK3kpIHtcbiAgICBjb25zdCByYXdZID0gcmVsWSAqIHk7XG5cbiAgICBjb25zdCB5bCA9IE1hdGguZmxvb3IocmF3WSk7XG4gICAgY29uc3QgeWggPSBNYXRoLm1pbihNYXRoLmNlaWwocmF3WSksIChpbkhlaWdodCAtIDEpKTtcblxuICAgIGZvciAobGV0IHggPSAwOyB4IDwgb3V0V2lkdGg7ICsreCkge1xuICAgICAgY29uc3QgcmF3WCA9IHJlbFggKiB4O1xuICAgICAgY29uc3QgdHggPSByYXdYICUgMTtcblxuICAgICAgY29uc3QgeGwgPSBNYXRoLmZsb29yKHJhd1gpO1xuICAgICAgY29uc3QgeGggPSBNYXRoLm1pbihNYXRoLmNlaWwocmF3WCksIChpbldpZHRoIC0gMSkpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNhbXBsZXM7ICsraSkge1xuICAgICAgICBjb25zdCBsbCA9IHZhbHVlQXJyYXlbKHlsICogaW5XaWR0aCAqIHNhbXBsZXMpICsgKHhsICogc2FtcGxlcykgKyBpXTtcbiAgICAgICAgY29uc3QgaGwgPSB2YWx1ZUFycmF5Wyh5bCAqIGluV2lkdGggKiBzYW1wbGVzKSArICh4aCAqIHNhbXBsZXMpICsgaV07XG4gICAgICAgIGNvbnN0IGxoID0gdmFsdWVBcnJheVsoeWggKiBpbldpZHRoICogc2FtcGxlcykgKyAoeGwgKiBzYW1wbGVzKSArIGldO1xuICAgICAgICBjb25zdCBoaCA9IHZhbHVlQXJyYXlbKHloICogaW5XaWR0aCAqIHNhbXBsZXMpICsgKHhoICogc2FtcGxlcykgKyBpXTtcblxuICAgICAgICBjb25zdCB2YWx1ZSA9IGxlcnAoXG4gICAgICAgICAgbGVycChsbCwgaGwsIHR4KSxcbiAgICAgICAgICBsZXJwKGxoLCBoaCwgdHgpLFxuICAgICAgICAgIHJhd1kgJSAxLFxuICAgICAgICApO1xuICAgICAgICBuZXdBcnJheVsoeSAqIG91dFdpZHRoICogc2FtcGxlcykgKyAoeCAqIHNhbXBsZXMpICsgaV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld0FycmF5O1xufVxuXG4vKipcbiAqIFJlc2FtcGxlIHRoZSBwaXhlbCBpbnRlcmxlYXZlZCBpbnB1dCBhcnJheSB1c2luZyB0aGUgc2VsZWN0ZWQgcmVzYW1wbGluZyBtZXRob2QuXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXl9IHZhbHVlQXJyYXkgVGhlIGlucHV0IGFycmF5IHRvIHJlc2FtcGxlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5XaWR0aCBUaGUgd2lkdGggb2YgdGhlIGlucHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbkhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBpbnB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gb3V0V2lkdGggVGhlIGRlc2lyZWQgd2lkdGggb2YgdGhlIG91dHB1dCByYXN0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gb3V0SGVpZ2h0IFRoZSBkZXNpcmVkIGhlaWdodCBvZiB0aGUgb3V0cHV0IHJhc3RlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBzYW1wbGVzIFRoZSBudW1iZXIgb2Ygc2FtcGxlcyBwZXIgcGl4ZWwgZm9yIHBpeGVsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVybGVhdmVkIGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbWV0aG9kID0gJ25lYXJlc3QnXSBUaGUgZGVzaXJlZCByZXNhbXBsaW5nIG1ldGhvZFxuICogQHJldHVybnMge1R5cGVkQXJyYXl9IFRoZSByZXNhbXBsZWQgcmFzdGVyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzYW1wbGVJbnRlcmxlYXZlZCh2YWx1ZUFycmF5LCBpbldpZHRoLCBpbkhlaWdodCwgb3V0V2lkdGgsIG91dEhlaWdodCwgc2FtcGxlcywgbWV0aG9kID0gJ25lYXJlc3QnKSB7XG4gIHN3aXRjaCAobWV0aG9kLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICduZWFyZXN0JzpcbiAgICAgIHJldHVybiByZXNhbXBsZU5lYXJlc3RJbnRlcmxlYXZlZChcbiAgICAgICAgdmFsdWVBcnJheSwgaW5XaWR0aCwgaW5IZWlnaHQsIG91dFdpZHRoLCBvdXRIZWlnaHQsIHNhbXBsZXMsXG4gICAgICApO1xuICAgIGNhc2UgJ2JpbGluZWFyJzpcbiAgICBjYXNlICdsaW5lYXInOlxuICAgICAgcmV0dXJuIHJlc2FtcGxlQmlsaW5lYXJJbnRlcmxlYXZlZChcbiAgICAgICAgdmFsdWVBcnJheSwgaW5XaWR0aCwgaW5IZWlnaHQsIG91dFdpZHRoLCBvdXRIZWlnaHQsIHNhbXBsZXMsXG4gICAgICApO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHJlc2FtcGxpbmcgbWV0aG9kOiAnJHttZXRob2R9J2ApO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/resample.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/rgb.js":
/*!*************************************************!*\
  !*** ./node_modules/geotiff/dist-module/rgb.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromBlackIsZero: () => (/* binding */ fromBlackIsZero),\n/* harmony export */   fromCIELab: () => (/* binding */ fromCIELab),\n/* harmony export */   fromCMYK: () => (/* binding */ fromCMYK),\n/* harmony export */   fromPalette: () => (/* binding */ fromPalette),\n/* harmony export */   fromWhiteIsZero: () => (/* binding */ fromWhiteIsZero),\n/* harmony export */   fromYCbCr: () => (/* binding */ fromYCbCr)\n/* harmony export */ });\nfunction fromWhiteIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = 256 - (raster[i] / max * 256);\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nfunction fromBlackIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = raster[i] / max * 256;\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nfunction fromPalette(raster, colorMap) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  const greenOffset = colorMap.length / 3;\n  const blueOffset = colorMap.length / 3 * 2;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    const mapIndex = raster[i];\n    rgbRaster[j] = colorMap[mapIndex] / 65536 * 256;\n    rgbRaster[j + 1] = colorMap[mapIndex + greenOffset] / 65536 * 256;\n    rgbRaster[j + 2] = colorMap[mapIndex + blueOffset] / 65536 * 256;\n  }\n  return rgbRaster;\n}\n\nfunction fromCMYK(cmykRaster) {\n  const { width, height } = cmykRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  for (let i = 0, j = 0; i < cmykRaster.length; i += 4, j += 3) {\n    const c = cmykRaster[i];\n    const m = cmykRaster[i + 1];\n    const y = cmykRaster[i + 2];\n    const k = cmykRaster[i + 3];\n\n    rgbRaster[j] = 255 * ((255 - c) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 1] = 255 * ((255 - m) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 2] = 255 * ((255 - y) / 256) * ((255 - k) / 256);\n  }\n  return rgbRaster;\n}\n\nfunction fromYCbCr(yCbCrRaster) {\n  const { width, height } = yCbCrRaster;\n  const rgbRaster = new Uint8ClampedArray(width * height * 3);\n  for (let i = 0, j = 0; i < yCbCrRaster.length; i += 3, j += 3) {\n    const y = yCbCrRaster[i];\n    const cb = yCbCrRaster[i + 1];\n    const cr = yCbCrRaster[i + 2];\n\n    rgbRaster[j] = (y + (1.40200 * (cr - 0x80)));\n    rgbRaster[j + 1] = (y - (0.34414 * (cb - 0x80)) - (0.71414 * (cr - 0x80)));\n    rgbRaster[j + 2] = (y + (1.77200 * (cb - 0x80)));\n  }\n  return rgbRaster;\n}\n\nconst Xn = 0.95047;\nconst Yn = 1.00000;\nconst Zn = 1.08883;\n\n// from https://github.com/antimatter15/rgb-lab/blob/master/color.js\n\nfunction fromCIELab(cieLabRaster) {\n  const { width, height } = cieLabRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n\n  for (let i = 0, j = 0; i < cieLabRaster.length; i += 3, j += 3) {\n    const L = cieLabRaster[i + 0];\n    const a_ = cieLabRaster[i + 1] << 24 >> 24; // conversion from uint8 to int8\n    const b_ = cieLabRaster[i + 2] << 24 >> 24; // same\n\n    let y = (L + 16) / 116;\n    let x = (a_ / 500) + y;\n    let z = y - (b_ / 200);\n    let r;\n    let g;\n    let b;\n\n    x = Xn * ((x * x * x > 0.008856) ? x * x * x : (x - (16 / 116)) / 7.787);\n    y = Yn * ((y * y * y > 0.008856) ? y * y * y : (y - (16 / 116)) / 7.787);\n    z = Zn * ((z * z * z > 0.008856) ? z * z * z : (z - (16 / 116)) / 7.787);\n\n    r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n    g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n    b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n    r = (r > 0.0031308) ? ((1.055 * (r ** (1 / 2.4))) - 0.055) : 12.92 * r;\n    g = (g > 0.0031308) ? ((1.055 * (g ** (1 / 2.4))) - 0.055) : 12.92 * g;\n    b = (b > 0.0031308) ? ((1.055 * (b ** (1 / 2.4))) - 0.055) : 12.92 * b;\n\n    rgbRaster[j] = Math.max(0, Math.min(1, r)) * 255;\n    rgbRaster[j + 1] = Math.max(0, Math.min(1, g)) * 255;\n    rgbRaster[j + 2] = Math.max(0, Math.min(1, b)) * 255;\n  }\n  return rgbRaster;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9yZ2IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVycmlhanMtbWFwLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvcmdiLmpzP2IyOTAiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGZyb21XaGl0ZUlzWmVybyhyYXN0ZXIsIG1heCkge1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHJhc3RlcjtcbiAgY29uc3QgcmdiUmFzdGVyID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiAzKTtcbiAgbGV0IHZhbHVlO1xuICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCByYXN0ZXIubGVuZ3RoOyArK2ksIGogKz0gMykge1xuICAgIHZhbHVlID0gMjU2IC0gKHJhc3RlcltpXSAvIG1heCAqIDI1Nik7XG4gICAgcmdiUmFzdGVyW2pdID0gdmFsdWU7XG4gICAgcmdiUmFzdGVyW2ogKyAxXSA9IHZhbHVlO1xuICAgIHJnYlJhc3RlcltqICsgMl0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gcmdiUmFzdGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZnJvbUJsYWNrSXNaZXJvKHJhc3RlciwgbWF4KSB7XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gcmFzdGVyO1xuICBjb25zdCByZ2JSYXN0ZXIgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDMpO1xuICBsZXQgdmFsdWU7XG4gIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IHJhc3Rlci5sZW5ndGg7ICsraSwgaiArPSAzKSB7XG4gICAgdmFsdWUgPSByYXN0ZXJbaV0gLyBtYXggKiAyNTY7XG4gICAgcmdiUmFzdGVyW2pdID0gdmFsdWU7XG4gICAgcmdiUmFzdGVyW2ogKyAxXSA9IHZhbHVlO1xuICAgIHJnYlJhc3RlcltqICsgMl0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gcmdiUmFzdGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVBhbGV0dGUocmFzdGVyLCBjb2xvck1hcCkge1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHJhc3RlcjtcbiAgY29uc3QgcmdiUmFzdGVyID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiAzKTtcbiAgY29uc3QgZ3JlZW5PZmZzZXQgPSBjb2xvck1hcC5sZW5ndGggLyAzO1xuICBjb25zdCBibHVlT2Zmc2V0ID0gY29sb3JNYXAubGVuZ3RoIC8gMyAqIDI7XG4gIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IHJhc3Rlci5sZW5ndGg7ICsraSwgaiArPSAzKSB7XG4gICAgY29uc3QgbWFwSW5kZXggPSByYXN0ZXJbaV07XG4gICAgcmdiUmFzdGVyW2pdID0gY29sb3JNYXBbbWFwSW5kZXhdIC8gNjU1MzYgKiAyNTY7XG4gICAgcmdiUmFzdGVyW2ogKyAxXSA9IGNvbG9yTWFwW21hcEluZGV4ICsgZ3JlZW5PZmZzZXRdIC8gNjU1MzYgKiAyNTY7XG4gICAgcmdiUmFzdGVyW2ogKyAyXSA9IGNvbG9yTWFwW21hcEluZGV4ICsgYmx1ZU9mZnNldF0gLyA2NTUzNiAqIDI1NjtcbiAgfVxuICByZXR1cm4gcmdiUmFzdGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZnJvbUNNWUsoY215a1Jhc3Rlcikge1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGNteWtSYXN0ZXI7XG4gIGNvbnN0IHJnYlJhc3RlciA9IG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0ICogMyk7XG4gIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IGNteWtSYXN0ZXIubGVuZ3RoOyBpICs9IDQsIGogKz0gMykge1xuICAgIGNvbnN0IGMgPSBjbXlrUmFzdGVyW2ldO1xuICAgIGNvbnN0IG0gPSBjbXlrUmFzdGVyW2kgKyAxXTtcbiAgICBjb25zdCB5ID0gY215a1Jhc3RlcltpICsgMl07XG4gICAgY29uc3QgayA9IGNteWtSYXN0ZXJbaSArIDNdO1xuXG4gICAgcmdiUmFzdGVyW2pdID0gMjU1ICogKCgyNTUgLSBjKSAvIDI1NikgKiAoKDI1NSAtIGspIC8gMjU2KTtcbiAgICByZ2JSYXN0ZXJbaiArIDFdID0gMjU1ICogKCgyNTUgLSBtKSAvIDI1NikgKiAoKDI1NSAtIGspIC8gMjU2KTtcbiAgICByZ2JSYXN0ZXJbaiArIDJdID0gMjU1ICogKCgyNTUgLSB5KSAvIDI1NikgKiAoKDI1NSAtIGspIC8gMjU2KTtcbiAgfVxuICByZXR1cm4gcmdiUmFzdGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVlDYkNyKHlDYkNyUmFzdGVyKSB7XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0geUNiQ3JSYXN0ZXI7XG4gIGNvbnN0IHJnYlJhc3RlciA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh3aWR0aCAqIGhlaWdodCAqIDMpO1xuICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCB5Q2JDclJhc3Rlci5sZW5ndGg7IGkgKz0gMywgaiArPSAzKSB7XG4gICAgY29uc3QgeSA9IHlDYkNyUmFzdGVyW2ldO1xuICAgIGNvbnN0IGNiID0geUNiQ3JSYXN0ZXJbaSArIDFdO1xuICAgIGNvbnN0IGNyID0geUNiQ3JSYXN0ZXJbaSArIDJdO1xuXG4gICAgcmdiUmFzdGVyW2pdID0gKHkgKyAoMS40MDIwMCAqIChjciAtIDB4ODApKSk7XG4gICAgcmdiUmFzdGVyW2ogKyAxXSA9ICh5IC0gKDAuMzQ0MTQgKiAoY2IgLSAweDgwKSkgLSAoMC43MTQxNCAqIChjciAtIDB4ODApKSk7XG4gICAgcmdiUmFzdGVyW2ogKyAyXSA9ICh5ICsgKDEuNzcyMDAgKiAoY2IgLSAweDgwKSkpO1xuICB9XG4gIHJldHVybiByZ2JSYXN0ZXI7XG59XG5cbmNvbnN0IFhuID0gMC45NTA0NztcbmNvbnN0IFluID0gMS4wMDAwMDtcbmNvbnN0IFpuID0gMS4wODg4MztcblxuLy8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYW50aW1hdHRlcjE1L3JnYi1sYWIvYmxvYi9tYXN0ZXIvY29sb3IuanNcblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21DSUVMYWIoY2llTGFiUmFzdGVyKSB7XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gY2llTGFiUmFzdGVyO1xuICBjb25zdCByZ2JSYXN0ZXIgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDMpO1xuXG4gIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IGNpZUxhYlJhc3Rlci5sZW5ndGg7IGkgKz0gMywgaiArPSAzKSB7XG4gICAgY29uc3QgTCA9IGNpZUxhYlJhc3RlcltpICsgMF07XG4gICAgY29uc3QgYV8gPSBjaWVMYWJSYXN0ZXJbaSArIDFdIDw8IDI0ID4+IDI0OyAvLyBjb252ZXJzaW9uIGZyb20gdWludDggdG8gaW50OFxuICAgIGNvbnN0IGJfID0gY2llTGFiUmFzdGVyW2kgKyAyXSA8PCAyNCA+PiAyNDsgLy8gc2FtZVxuXG4gICAgbGV0IHkgPSAoTCArIDE2KSAvIDExNjtcbiAgICBsZXQgeCA9IChhXyAvIDUwMCkgKyB5O1xuICAgIGxldCB6ID0geSAtIChiXyAvIDIwMCk7XG4gICAgbGV0IHI7XG4gICAgbGV0IGc7XG4gICAgbGV0IGI7XG5cbiAgICB4ID0gWG4gKiAoKHggKiB4ICogeCA+IDAuMDA4ODU2KSA/IHggKiB4ICogeCA6ICh4IC0gKDE2IC8gMTE2KSkgLyA3Ljc4Nyk7XG4gICAgeSA9IFluICogKCh5ICogeSAqIHkgPiAwLjAwODg1NikgPyB5ICogeSAqIHkgOiAoeSAtICgxNiAvIDExNikpIC8gNy43ODcpO1xuICAgIHogPSBabiAqICgoeiAqIHogKiB6ID4gMC4wMDg4NTYpID8geiAqIHogKiB6IDogKHogLSAoMTYgLyAxMTYpKSAvIDcuNzg3KTtcblxuICAgIHIgPSAoeCAqIDMuMjQwNikgKyAoeSAqIC0xLjUzNzIpICsgKHogKiAtMC40OTg2KTtcbiAgICBnID0gKHggKiAtMC45Njg5KSArICh5ICogMS44NzU4KSArICh6ICogMC4wNDE1KTtcbiAgICBiID0gKHggKiAwLjA1NTcpICsgKHkgKiAtMC4yMDQwKSArICh6ICogMS4wNTcwKTtcblxuICAgIHIgPSAociA+IDAuMDAzMTMwOCkgPyAoKDEuMDU1ICogKHIgKiogKDEgLyAyLjQpKSkgLSAwLjA1NSkgOiAxMi45MiAqIHI7XG4gICAgZyA9IChnID4gMC4wMDMxMzA4KSA/ICgoMS4wNTUgKiAoZyAqKiAoMSAvIDIuNCkpKSAtIDAuMDU1KSA6IDEyLjkyICogZztcbiAgICBiID0gKGIgPiAwLjAwMzEzMDgpID8gKCgxLjA1NSAqIChiICoqICgxIC8gMi40KSkpIC0gMC4wNTUpIDogMTIuOTIgKiBiO1xuXG4gICAgcmdiUmFzdGVyW2pdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgcikpICogMjU1O1xuICAgIHJnYlJhc3RlcltqICsgMV0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBnKSkgKiAyNTU7XG4gICAgcmdiUmFzdGVyW2ogKyAyXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIGIpKSAqIDI1NTtcbiAgfVxuICByZXR1cm4gcmdiUmFzdGVyO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/rgb.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/arraybuffer.js":
/*!****************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/arraybuffer.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   makeBufferSource: () => (/* binding */ makeBufferSource)\n/* harmony export */ });\n/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basesource.js */ \"./node_modules/geotiff/dist-module/source/basesource.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"./node_modules/geotiff/dist-module/utils.js\");\n\n\n\nclass ArrayBufferSource extends _basesource_js__WEBPACK_IMPORTED_MODULE_0__.BaseSource {\n  constructor(arrayBuffer) {\n    super();\n    this.arrayBuffer = arrayBuffer;\n  }\n\n  fetchSlice(slice, signal) {\n    if (signal && signal.aborted) {\n      throw new _utils_js__WEBPACK_IMPORTED_MODULE_1__.AbortError('Request aborted');\n    }\n    return this.arrayBuffer.slice(slice.offset, slice.offset + slice.length);\n  }\n}\n\nfunction makeBufferSource(arrayBuffer) {\n  return new ArrayBufferSource(arrayBuffer);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvYXJyYXlidWZmZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlcnJpYWpzLW1hcC8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9hcnJheWJ1ZmZlci5qcz9jYTY2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VTb3VyY2UgfSBmcm9tICcuL2Jhc2Vzb3VyY2UuanMnO1xuaW1wb3J0IHsgQWJvcnRFcnJvciB9IGZyb20gJy4uL3V0aWxzLmpzJztcblxuY2xhc3MgQXJyYXlCdWZmZXJTb3VyY2UgZXh0ZW5kcyBCYXNlU291cmNlIHtcbiAgY29uc3RydWN0b3IoYXJyYXlCdWZmZXIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBhcnJheUJ1ZmZlcjtcbiAgfVxuXG4gIGZldGNoU2xpY2Uoc2xpY2UsIHNpZ25hbCkge1xuICAgIGlmIChzaWduYWwgJiYgc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBBYm9ydEVycm9yKCdSZXF1ZXN0IGFib3J0ZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYXJyYXlCdWZmZXIuc2xpY2Uoc2xpY2Uub2Zmc2V0LCBzbGljZS5vZmZzZXQgKyBzbGljZS5sZW5ndGgpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlQnVmZmVyU291cmNlKGFycmF5QnVmZmVyKSB7XG4gIHJldHVybiBuZXcgQXJyYXlCdWZmZXJTb3VyY2UoYXJyYXlCdWZmZXIpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/source/arraybuffer.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/basesource.js":
/*!***************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/basesource.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseSource: () => (/* binding */ BaseSource)\n/* harmony export */ });\n/**\n * @typedef Slice\n * @property {number} offset\n * @property {number} length\n */\n\nclass BaseSource {\n  /**\n   *\n   * @param {Slice[]} slices\n   * @returns {ArrayBuffer[]}\n   */\n  async fetch(slices, signal = undefined) {\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  /**\n   *\n   * @param {Slice} slice\n   * @returns {ArrayBuffer}\n   */\n  async fetchSlice(slice) {\n    throw new Error(`fetching of slice ${slice} not possible, not implemented`);\n  }\n\n  /**\n   * Returns the filesize if already determined and null otherwise\n   */\n  get fileSize() {\n    return null;\n  }\n\n  async close() {\n    // no-op by default\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvYmFzZXNvdXJjZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlcnJpYWpzLW1hcC8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9iYXNlc291cmNlLmpzPzk5YjMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAdHlwZWRlZiBTbGljZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IG9mZnNldFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxlbmd0aFxuICovXG5cbmV4cG9ydCBjbGFzcyBCYXNlU291cmNlIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7U2xpY2VbXX0gc2xpY2VzXG4gICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcltdfVxuICAgKi9cbiAgYXN5bmMgZmV0Y2goc2xpY2VzLCBzaWduYWwgPSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICBzbGljZXMubWFwKChzbGljZSkgPT4gdGhpcy5mZXRjaFNsaWNlKHNsaWNlLCBzaWduYWwpKSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7U2xpY2V9IHNsaWNlXG4gICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn1cbiAgICovXG4gIGFzeW5jIGZldGNoU2xpY2Uoc2xpY2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGZldGNoaW5nIG9mIHNsaWNlICR7c2xpY2V9IG5vdCBwb3NzaWJsZSwgbm90IGltcGxlbWVudGVkYCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlsZXNpemUgaWYgYWxyZWFkeSBkZXRlcm1pbmVkIGFuZCBudWxsIG90aGVyd2lzZVxuICAgKi9cbiAgZ2V0IGZpbGVTaXplKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgYXN5bmMgY2xvc2UoKSB7XG4gICAgLy8gbm8tb3AgYnkgZGVmYXVsdFxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/source/basesource.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/blockedsource.js":
/*!******************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/blockedsource.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlockedSource: () => (/* binding */ BlockedSource)\n/* harmony export */ });\n/* harmony import */ var quick_lru__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! quick-lru */ \"./node_modules/quick-lru/index.js\");\n/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basesource.js */ \"./node_modules/geotiff/dist-module/source/basesource.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ \"./node_modules/geotiff/dist-module/utils.js\");\n\n\n\n\nclass Block {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {ArrayBuffer} [data]\n   */\n  constructor(offset, length, data = null) {\n    this.offset = offset;\n    this.length = length;\n    this.data = data;\n  }\n\n  /**\n   * @returns {number} the top byte border\n   */\n  get top() {\n    return this.offset + this.length;\n  }\n}\n\nclass BlockGroup {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {number[]} blockIds\n   */\n  constructor(offset, length, blockIds) {\n    this.offset = offset;\n    this.length = length;\n    this.blockIds = blockIds;\n  }\n}\n\nclass BlockedSource extends _basesource_js__WEBPACK_IMPORTED_MODULE_1__.BaseSource {\n  /**\n   *\n   * @param {BaseSource} source The underlying source that shall be blocked and cached\n   * @param {object} options\n   * @param {number} [options.blockSize]\n   * @param {number} [options.cacheSize]\n   */\n  constructor(source, { blockSize = 65536, cacheSize = 100 } = {}) {\n    super();\n    this.source = source;\n    this.blockSize = blockSize;\n\n    this.blockCache = new quick_lru__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n      maxSize: cacheSize,\n      onEviction: (blockId, block) => {\n        this.evictedBlocks.set(blockId, block);\n      },\n    });\n\n    /** @type {Map<number, Block>} */\n    this.evictedBlocks = new Map();\n\n    // mapping blockId -> Block instance\n    this.blockRequests = new Map();\n\n    // set of blockIds missing for the current requests\n    this.blockIdsToFetch = new Set();\n\n    this.abortedBlockIds = new Set();\n  }\n\n  get fileSize() {\n    return this.source.fileSize;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    const blockRequests = [];\n    const missingBlockIds = [];\n    const allBlockIds = [];\n    this.evictedBlocks.clear();\n\n    for (const { offset, length } of slices) {\n      let top = offset + length;\n\n      const { fileSize } = this;\n      if (fileSize !== null) {\n        top = Math.min(top, fileSize);\n      }\n\n      const firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;\n\n      for (let current = firstBlockOffset; current < top; current += this.blockSize) {\n        const blockId = Math.floor(current / this.blockSize);\n        if (!this.blockCache.has(blockId) && !this.blockRequests.has(blockId)) {\n          this.blockIdsToFetch.add(blockId);\n          missingBlockIds.push(blockId);\n        }\n        if (this.blockRequests.has(blockId)) {\n          blockRequests.push(this.blockRequests.get(blockId));\n        }\n        allBlockIds.push(blockId);\n      }\n    }\n\n    // allow additional block requests to accumulate\n    await (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wait)();\n    this.fetchBlocks(signal);\n\n    // Gather all of the new requests that this fetch call is contributing to `fetch`.\n    const missingRequests = [];\n    for (const blockId of missingBlockIds) {\n      // The requested missing block could already be in the cache\n      // instead of having its request still be outstanding.\n      if (this.blockRequests.has(blockId)) {\n        missingRequests.push(this.blockRequests.get(blockId));\n      }\n    }\n\n    // Actually await all pending requests that are needed for this `fetch`.\n    await Promise.allSettled(blockRequests);\n    await Promise.allSettled(missingRequests);\n\n    // Perform retries if a block was interrupted by a previous signal\n    const abortedBlockRequests = [];\n    const abortedBlockIds = allBlockIds\n      .filter((id) => this.abortedBlockIds.has(id) || !this.blockCache.has(id));\n    abortedBlockIds.forEach((id) => this.blockIdsToFetch.add(id));\n    // start the retry of some blocks if required\n    if (abortedBlockIds.length > 0 && signal && !signal.aborted) {\n      this.fetchBlocks(null);\n      for (const blockId of abortedBlockIds) {\n        const block = this.blockRequests.get(blockId);\n        if (!block) {\n          throw new Error(`Block ${blockId} is not in the block requests`);\n        }\n        abortedBlockRequests.push(block);\n      }\n      await Promise.allSettled(abortedBlockRequests);\n    }\n\n    // throw an  abort error\n    if (signal && signal.aborted) {\n      throw new _utils_js__WEBPACK_IMPORTED_MODULE_2__.AbortError('Request was aborted');\n    }\n\n    const blocks = allBlockIds.map((id) => this.blockCache.get(id) || this.evictedBlocks.get(id));\n    const failedBlocks = blocks.filter((i) => !i);\n    if (failedBlocks.length) {\n      throw new _utils_js__WEBPACK_IMPORTED_MODULE_2__.AggregateError(failedBlocks, 'Request failed');\n    }\n\n    // create a final Map, with all required blocks for this request to satisfy\n    const requiredBlocks = new Map((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.zip)(allBlockIds, blocks));\n\n    // TODO: satisfy each slice\n    return this.readSliceData(slices, requiredBlocks);\n  }\n\n  /**\n   *\n   * @param {AbortSignal} signal\n   */\n  fetchBlocks(signal) {\n    // check if we still need to\n    if (this.blockIdsToFetch.size > 0) {\n      const groups = this.groupBlocks(this.blockIdsToFetch);\n\n      // start requesting slices of data\n      const groupRequests = this.source.fetch(groups, signal);\n\n      for (let groupIndex = 0; groupIndex < groups.length; ++groupIndex) {\n        const group = groups[groupIndex];\n\n        for (const blockId of group.blockIds) {\n          // make an async IIFE for each block\n          this.blockRequests.set(blockId, (async () => {\n            try {\n              const response = (await groupRequests)[groupIndex];\n              const blockOffset = blockId * this.blockSize;\n              const o = blockOffset - response.offset;\n              const t = Math.min(o + this.blockSize, response.data.byteLength);\n              const data = response.data.slice(o, t);\n              const block = new Block(\n                blockOffset,\n                data.byteLength,\n                data,\n                blockId,\n              );\n              this.blockCache.set(blockId, block);\n              this.abortedBlockIds.delete(blockId);\n            } catch (err) {\n              if (err.name === 'AbortError') {\n                // store the signal here, we need it to determine later if an\n                // error was caused by this signal\n                err.signal = signal;\n                this.blockCache.delete(blockId);\n                this.abortedBlockIds.add(blockId);\n              } else {\n                throw err;\n              }\n            } finally {\n              this.blockRequests.delete(blockId);\n            }\n          })());\n        }\n      }\n      this.blockIdsToFetch.clear();\n    }\n  }\n\n  /**\n   *\n   * @param {Set} blockIds\n   * @returns {BlockGroup[]}\n   */\n  groupBlocks(blockIds) {\n    const sortedBlockIds = Array.from(blockIds).sort((a, b) => a - b);\n    if (sortedBlockIds.length === 0) {\n      return [];\n    }\n    let current = [];\n    let lastBlockId = null;\n    const groups = [];\n\n    for (const blockId of sortedBlockIds) {\n      if (lastBlockId === null || lastBlockId + 1 === blockId) {\n        current.push(blockId);\n        lastBlockId = blockId;\n      } else {\n        groups.push(new BlockGroup(\n          current[0] * this.blockSize,\n          current.length * this.blockSize,\n          current,\n        ));\n        current = [blockId];\n        lastBlockId = blockId;\n      }\n    }\n\n    groups.push(new BlockGroup(\n      current[0] * this.blockSize,\n      current.length * this.blockSize,\n      current,\n    ));\n\n    return groups;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   * @param {Map} blocks\n   */\n  readSliceData(slices, blocks) {\n    return slices.map((slice) => {\n      let top = slice.offset + slice.length;\n      if (this.fileSize !== null) {\n        top = Math.min(this.fileSize, top);\n      }\n      const blockIdLow = Math.floor(slice.offset / this.blockSize);\n      const blockIdHigh = Math.floor(top / this.blockSize);\n      const sliceData = new ArrayBuffer(slice.length);\n      const sliceView = new Uint8Array(sliceData);\n\n      for (let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {\n        const block = blocks.get(blockId);\n        const delta = block.offset - slice.offset;\n        const topDelta = block.top - top;\n        let blockInnerOffset = 0;\n        let rangeInnerOffset = 0;\n        let usedBlockLength;\n\n        if (delta < 0) {\n          blockInnerOffset = -delta;\n        } else if (delta > 0) {\n          rangeInnerOffset = delta;\n        }\n\n        if (topDelta < 0) {\n          usedBlockLength = block.length - blockInnerOffset;\n        } else {\n          usedBlockLength = top - block.offset - blockInnerOffset;\n        }\n\n        const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n        sliceView.set(blockView, rangeInnerOffset);\n      }\n\n      return sliceData;\n    });\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvYmxvY2tlZHNvdXJjZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlcnJpYWpzLW1hcC8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9ibG9ja2Vkc291cmNlLmpzPzExNzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFF1aWNrTFJVIGZyb20gJ3F1aWNrLWxydSc7XG5pbXBvcnQgeyBCYXNlU291cmNlIH0gZnJvbSAnLi9iYXNlc291cmNlLmpzJztcbmltcG9ydCB7IEFib3J0RXJyb3IsIEFnZ3JlZ2F0ZUVycm9yLCB3YWl0LCB6aXAgfSBmcm9tICcuLi91dGlscy5qcyc7XG5cbmNsYXNzIEJsb2NrIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBbZGF0YV1cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9mZnNldCwgbGVuZ3RoLCBkYXRhID0gbnVsbCkge1xuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge251bWJlcn0gdGhlIHRvcCBieXRlIGJvcmRlclxuICAgKi9cbiAgZ2V0IHRvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5vZmZzZXQgKyB0aGlzLmxlbmd0aDtcbiAgfVxufVxuXG5jbGFzcyBCbG9ja0dyb3VwIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICAgKiBAcGFyYW0ge251bWJlcltdfSBibG9ja0lkc1xuICAgKi9cbiAgY29uc3RydWN0b3Iob2Zmc2V0LCBsZW5ndGgsIGJsb2NrSWRzKSB7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgdGhpcy5ibG9ja0lkcyA9IGJsb2NrSWRzO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBCbG9ja2VkU291cmNlIGV4dGVuZHMgQmFzZVNvdXJjZSB7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0Jhc2VTb3VyY2V9IHNvdXJjZSBUaGUgdW5kZXJseWluZyBzb3VyY2UgdGhhdCBzaGFsbCBiZSBibG9ja2VkIGFuZCBjYWNoZWRcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmJsb2NrU2l6ZV1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNhY2hlU2l6ZV1cbiAgICovXG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgeyBibG9ja1NpemUgPSA2NTUzNiwgY2FjaGVTaXplID0gMTAwIH0gPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5ibG9ja1NpemUgPSBibG9ja1NpemU7XG5cbiAgICB0aGlzLmJsb2NrQ2FjaGUgPSBuZXcgUXVpY2tMUlUoe1xuICAgICAgbWF4U2l6ZTogY2FjaGVTaXplLFxuICAgICAgb25FdmljdGlvbjogKGJsb2NrSWQsIGJsb2NrKSA9PiB7XG4gICAgICAgIHRoaXMuZXZpY3RlZEJsb2Nrcy5zZXQoYmxvY2tJZCwgYmxvY2spO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8qKiBAdHlwZSB7TWFwPG51bWJlciwgQmxvY2s+fSAqL1xuICAgIHRoaXMuZXZpY3RlZEJsb2NrcyA9IG5ldyBNYXAoKTtcblxuICAgIC8vIG1hcHBpbmcgYmxvY2tJZCAtPiBCbG9jayBpbnN0YW5jZVxuICAgIHRoaXMuYmxvY2tSZXF1ZXN0cyA9IG5ldyBNYXAoKTtcblxuICAgIC8vIHNldCBvZiBibG9ja0lkcyBtaXNzaW5nIGZvciB0aGUgY3VycmVudCByZXF1ZXN0c1xuICAgIHRoaXMuYmxvY2tJZHNUb0ZldGNoID0gbmV3IFNldCgpO1xuXG4gICAgdGhpcy5hYm9ydGVkQmxvY2tJZHMgPSBuZXcgU2V0KCk7XG4gIH1cblxuICBnZXQgZmlsZVNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlLmZpbGVTaXplO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7aW1wb3J0KFwiLi9iYXNlc291cmNlXCIpLlNsaWNlW119IHNsaWNlc1xuICAgKi9cbiAgYXN5bmMgZmV0Y2goc2xpY2VzLCBzaWduYWwpIHtcbiAgICBjb25zdCBibG9ja1JlcXVlc3RzID0gW107XG4gICAgY29uc3QgbWlzc2luZ0Jsb2NrSWRzID0gW107XG4gICAgY29uc3QgYWxsQmxvY2tJZHMgPSBbXTtcbiAgICB0aGlzLmV2aWN0ZWRCbG9ja3MuY2xlYXIoKTtcblxuICAgIGZvciAoY29uc3QgeyBvZmZzZXQsIGxlbmd0aCB9IG9mIHNsaWNlcykge1xuICAgICAgbGV0IHRvcCA9IG9mZnNldCArIGxlbmd0aDtcblxuICAgICAgY29uc3QgeyBmaWxlU2l6ZSB9ID0gdGhpcztcbiAgICAgIGlmIChmaWxlU2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICB0b3AgPSBNYXRoLm1pbih0b3AsIGZpbGVTaXplKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZmlyc3RCbG9ja09mZnNldCA9IE1hdGguZmxvb3Iob2Zmc2V0IC8gdGhpcy5ibG9ja1NpemUpICogdGhpcy5ibG9ja1NpemU7XG5cbiAgICAgIGZvciAobGV0IGN1cnJlbnQgPSBmaXJzdEJsb2NrT2Zmc2V0OyBjdXJyZW50IDwgdG9wOyBjdXJyZW50ICs9IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrSWQgPSBNYXRoLmZsb29yKGN1cnJlbnQgLyB0aGlzLmJsb2NrU2l6ZSk7XG4gICAgICAgIGlmICghdGhpcy5ibG9ja0NhY2hlLmhhcyhibG9ja0lkKSAmJiAhdGhpcy5ibG9ja1JlcXVlc3RzLmhhcyhibG9ja0lkKSkge1xuICAgICAgICAgIHRoaXMuYmxvY2tJZHNUb0ZldGNoLmFkZChibG9ja0lkKTtcbiAgICAgICAgICBtaXNzaW5nQmxvY2tJZHMucHVzaChibG9ja0lkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ibG9ja1JlcXVlc3RzLmhhcyhibG9ja0lkKSkge1xuICAgICAgICAgIGJsb2NrUmVxdWVzdHMucHVzaCh0aGlzLmJsb2NrUmVxdWVzdHMuZ2V0KGJsb2NrSWQpKTtcbiAgICAgICAgfVxuICAgICAgICBhbGxCbG9ja0lkcy5wdXNoKGJsb2NrSWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFsbG93IGFkZGl0aW9uYWwgYmxvY2sgcmVxdWVzdHMgdG8gYWNjdW11bGF0ZVxuICAgIGF3YWl0IHdhaXQoKTtcbiAgICB0aGlzLmZldGNoQmxvY2tzKHNpZ25hbCk7XG5cbiAgICAvLyBHYXRoZXIgYWxsIG9mIHRoZSBuZXcgcmVxdWVzdHMgdGhhdCB0aGlzIGZldGNoIGNhbGwgaXMgY29udHJpYnV0aW5nIHRvIGBmZXRjaGAuXG4gICAgY29uc3QgbWlzc2luZ1JlcXVlc3RzID0gW107XG4gICAgZm9yIChjb25zdCBibG9ja0lkIG9mIG1pc3NpbmdCbG9ja0lkcykge1xuICAgICAgLy8gVGhlIHJlcXVlc3RlZCBtaXNzaW5nIGJsb2NrIGNvdWxkIGFscmVhZHkgYmUgaW4gdGhlIGNhY2hlXG4gICAgICAvLyBpbnN0ZWFkIG9mIGhhdmluZyBpdHMgcmVxdWVzdCBzdGlsbCBiZSBvdXRzdGFuZGluZy5cbiAgICAgIGlmICh0aGlzLmJsb2NrUmVxdWVzdHMuaGFzKGJsb2NrSWQpKSB7XG4gICAgICAgIG1pc3NpbmdSZXF1ZXN0cy5wdXNoKHRoaXMuYmxvY2tSZXF1ZXN0cy5nZXQoYmxvY2tJZCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFjdHVhbGx5IGF3YWl0IGFsbCBwZW5kaW5nIHJlcXVlc3RzIHRoYXQgYXJlIG5lZWRlZCBmb3IgdGhpcyBgZmV0Y2hgLlxuICAgIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChibG9ja1JlcXVlc3RzKTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQobWlzc2luZ1JlcXVlc3RzKTtcblxuICAgIC8vIFBlcmZvcm0gcmV0cmllcyBpZiBhIGJsb2NrIHdhcyBpbnRlcnJ1cHRlZCBieSBhIHByZXZpb3VzIHNpZ25hbFxuICAgIGNvbnN0IGFib3J0ZWRCbG9ja1JlcXVlc3RzID0gW107XG4gICAgY29uc3QgYWJvcnRlZEJsb2NrSWRzID0gYWxsQmxvY2tJZHNcbiAgICAgIC5maWx0ZXIoKGlkKSA9PiB0aGlzLmFib3J0ZWRCbG9ja0lkcy5oYXMoaWQpIHx8ICF0aGlzLmJsb2NrQ2FjaGUuaGFzKGlkKSk7XG4gICAgYWJvcnRlZEJsb2NrSWRzLmZvckVhY2goKGlkKSA9PiB0aGlzLmJsb2NrSWRzVG9GZXRjaC5hZGQoaWQpKTtcbiAgICAvLyBzdGFydCB0aGUgcmV0cnkgb2Ygc29tZSBibG9ja3MgaWYgcmVxdWlyZWRcbiAgICBpZiAoYWJvcnRlZEJsb2NrSWRzLmxlbmd0aCA+IDAgJiYgc2lnbmFsICYmICFzaWduYWwuYWJvcnRlZCkge1xuICAgICAgdGhpcy5mZXRjaEJsb2NrcyhudWxsKTtcbiAgICAgIGZvciAoY29uc3QgYmxvY2tJZCBvZiBhYm9ydGVkQmxvY2tJZHMpIHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSB0aGlzLmJsb2NrUmVxdWVzdHMuZ2V0KGJsb2NrSWQpO1xuICAgICAgICBpZiAoIWJsb2NrKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCbG9jayAke2Jsb2NrSWR9IGlzIG5vdCBpbiB0aGUgYmxvY2sgcmVxdWVzdHNgKTtcbiAgICAgICAgfVxuICAgICAgICBhYm9ydGVkQmxvY2tSZXF1ZXN0cy5wdXNoKGJsb2NrKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChhYm9ydGVkQmxvY2tSZXF1ZXN0cyk7XG4gICAgfVxuXG4gICAgLy8gdGhyb3cgYW4gIGFib3J0IGVycm9yXG4gICAgaWYgKHNpZ25hbCAmJiBzaWduYWwuYWJvcnRlZCkge1xuICAgICAgdGhyb3cgbmV3IEFib3J0RXJyb3IoJ1JlcXVlc3Qgd2FzIGFib3J0ZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBibG9ja3MgPSBhbGxCbG9ja0lkcy5tYXAoKGlkKSA9PiB0aGlzLmJsb2NrQ2FjaGUuZ2V0KGlkKSB8fCB0aGlzLmV2aWN0ZWRCbG9ja3MuZ2V0KGlkKSk7XG4gICAgY29uc3QgZmFpbGVkQmxvY2tzID0gYmxvY2tzLmZpbHRlcigoaSkgPT4gIWkpO1xuICAgIGlmIChmYWlsZWRCbG9ja3MubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgQWdncmVnYXRlRXJyb3IoZmFpbGVkQmxvY2tzLCAnUmVxdWVzdCBmYWlsZWQnKTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgYSBmaW5hbCBNYXAsIHdpdGggYWxsIHJlcXVpcmVkIGJsb2NrcyBmb3IgdGhpcyByZXF1ZXN0IHRvIHNhdGlzZnlcbiAgICBjb25zdCByZXF1aXJlZEJsb2NrcyA9IG5ldyBNYXAoemlwKGFsbEJsb2NrSWRzLCBibG9ja3MpKTtcblxuICAgIC8vIFRPRE86IHNhdGlzZnkgZWFjaCBzbGljZVxuICAgIHJldHVybiB0aGlzLnJlYWRTbGljZURhdGEoc2xpY2VzLCByZXF1aXJlZEJsb2Nrcyk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gc2lnbmFsXG4gICAqL1xuICBmZXRjaEJsb2NrcyhzaWduYWwpIHtcbiAgICAvLyBjaGVjayBpZiB3ZSBzdGlsbCBuZWVkIHRvXG4gICAgaWYgKHRoaXMuYmxvY2tJZHNUb0ZldGNoLnNpemUgPiAwKSB7XG4gICAgICBjb25zdCBncm91cHMgPSB0aGlzLmdyb3VwQmxvY2tzKHRoaXMuYmxvY2tJZHNUb0ZldGNoKTtcblxuICAgICAgLy8gc3RhcnQgcmVxdWVzdGluZyBzbGljZXMgb2YgZGF0YVxuICAgICAgY29uc3QgZ3JvdXBSZXF1ZXN0cyA9IHRoaXMuc291cmNlLmZldGNoKGdyb3Vwcywgc2lnbmFsKTtcblxuICAgICAgZm9yIChsZXQgZ3JvdXBJbmRleCA9IDA7IGdyb3VwSW5kZXggPCBncm91cHMubGVuZ3RoOyArK2dyb3VwSW5kZXgpIHtcbiAgICAgICAgY29uc3QgZ3JvdXAgPSBncm91cHNbZ3JvdXBJbmRleF07XG5cbiAgICAgICAgZm9yIChjb25zdCBibG9ja0lkIG9mIGdyb3VwLmJsb2NrSWRzKSB7XG4gICAgICAgICAgLy8gbWFrZSBhbiBhc3luYyBJSUZFIGZvciBlYWNoIGJsb2NrXG4gICAgICAgICAgdGhpcy5ibG9ja1JlcXVlc3RzLnNldChibG9ja0lkLCAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSAoYXdhaXQgZ3JvdXBSZXF1ZXN0cylbZ3JvdXBJbmRleF07XG4gICAgICAgICAgICAgIGNvbnN0IGJsb2NrT2Zmc2V0ID0gYmxvY2tJZCAqIHRoaXMuYmxvY2tTaXplO1xuICAgICAgICAgICAgICBjb25zdCBvID0gYmxvY2tPZmZzZXQgLSByZXNwb25zZS5vZmZzZXQ7XG4gICAgICAgICAgICAgIGNvbnN0IHQgPSBNYXRoLm1pbihvICsgdGhpcy5ibG9ja1NpemUsIHJlc3BvbnNlLmRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSByZXNwb25zZS5kYXRhLnNsaWNlKG8sIHQpO1xuICAgICAgICAgICAgICBjb25zdCBibG9jayA9IG5ldyBCbG9jayhcbiAgICAgICAgICAgICAgICBibG9ja09mZnNldCxcbiAgICAgICAgICAgICAgICBkYXRhLmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICBibG9ja0lkLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB0aGlzLmJsb2NrQ2FjaGUuc2V0KGJsb2NrSWQsIGJsb2NrKTtcbiAgICAgICAgICAgICAgdGhpcy5hYm9ydGVkQmxvY2tJZHMuZGVsZXRlKGJsb2NrSWQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIGlmIChlcnIubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RvcmUgdGhlIHNpZ25hbCBoZXJlLCB3ZSBuZWVkIGl0IHRvIGRldGVybWluZSBsYXRlciBpZiBhblxuICAgICAgICAgICAgICAgIC8vIGVycm9yIHdhcyBjYXVzZWQgYnkgdGhpcyBzaWduYWxcbiAgICAgICAgICAgICAgICBlcnIuc2lnbmFsID0gc2lnbmFsO1xuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tDYWNoZS5kZWxldGUoYmxvY2tJZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hYm9ydGVkQmxvY2tJZHMuYWRkKGJsb2NrSWQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgdGhpcy5ibG9ja1JlcXVlc3RzLmRlbGV0ZShibG9ja0lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5ibG9ja0lkc1RvRmV0Y2guY2xlYXIoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtTZXR9IGJsb2NrSWRzXG4gICAqIEByZXR1cm5zIHtCbG9ja0dyb3VwW119XG4gICAqL1xuICBncm91cEJsb2NrcyhibG9ja0lkcykge1xuICAgIGNvbnN0IHNvcnRlZEJsb2NrSWRzID0gQXJyYXkuZnJvbShibG9ja0lkcykuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgIGlmIChzb3J0ZWRCbG9ja0lkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnQgPSBbXTtcbiAgICBsZXQgbGFzdEJsb2NrSWQgPSBudWxsO1xuICAgIGNvbnN0IGdyb3VwcyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBibG9ja0lkIG9mIHNvcnRlZEJsb2NrSWRzKSB7XG4gICAgICBpZiAobGFzdEJsb2NrSWQgPT09IG51bGwgfHwgbGFzdEJsb2NrSWQgKyAxID09PSBibG9ja0lkKSB7XG4gICAgICAgIGN1cnJlbnQucHVzaChibG9ja0lkKTtcbiAgICAgICAgbGFzdEJsb2NrSWQgPSBibG9ja0lkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JvdXBzLnB1c2gobmV3IEJsb2NrR3JvdXAoXG4gICAgICAgICAgY3VycmVudFswXSAqIHRoaXMuYmxvY2tTaXplLFxuICAgICAgICAgIGN1cnJlbnQubGVuZ3RoICogdGhpcy5ibG9ja1NpemUsXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgKSk7XG4gICAgICAgIGN1cnJlbnQgPSBbYmxvY2tJZF07XG4gICAgICAgIGxhc3RCbG9ja0lkID0gYmxvY2tJZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBncm91cHMucHVzaChuZXcgQmxvY2tHcm91cChcbiAgICAgIGN1cnJlbnRbMF0gKiB0aGlzLmJsb2NrU2l6ZSxcbiAgICAgIGN1cnJlbnQubGVuZ3RoICogdGhpcy5ibG9ja1NpemUsXG4gICAgICBjdXJyZW50LFxuICAgICkpO1xuXG4gICAgcmV0dXJuIGdyb3VwcztcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge2ltcG9ydChcIi4vYmFzZXNvdXJjZVwiKS5TbGljZVtdfSBzbGljZXNcbiAgICogQHBhcmFtIHtNYXB9IGJsb2Nrc1xuICAgKi9cbiAgcmVhZFNsaWNlRGF0YShzbGljZXMsIGJsb2Nrcykge1xuICAgIHJldHVybiBzbGljZXMubWFwKChzbGljZSkgPT4ge1xuICAgICAgbGV0IHRvcCA9IHNsaWNlLm9mZnNldCArIHNsaWNlLmxlbmd0aDtcbiAgICAgIGlmICh0aGlzLmZpbGVTaXplICE9PSBudWxsKSB7XG4gICAgICAgIHRvcCA9IE1hdGgubWluKHRoaXMuZmlsZVNpemUsIHRvcCk7XG4gICAgICB9XG4gICAgICBjb25zdCBibG9ja0lkTG93ID0gTWF0aC5mbG9vcihzbGljZS5vZmZzZXQgLyB0aGlzLmJsb2NrU2l6ZSk7XG4gICAgICBjb25zdCBibG9ja0lkSGlnaCA9IE1hdGguZmxvb3IodG9wIC8gdGhpcy5ibG9ja1NpemUpO1xuICAgICAgY29uc3Qgc2xpY2VEYXRhID0gbmV3IEFycmF5QnVmZmVyKHNsaWNlLmxlbmd0aCk7XG4gICAgICBjb25zdCBzbGljZVZpZXcgPSBuZXcgVWludDhBcnJheShzbGljZURhdGEpO1xuXG4gICAgICBmb3IgKGxldCBibG9ja0lkID0gYmxvY2tJZExvdzsgYmxvY2tJZCA8PSBibG9ja0lkSGlnaDsgKytibG9ja0lkKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gYmxvY2tzLmdldChibG9ja0lkKTtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBibG9jay5vZmZzZXQgLSBzbGljZS5vZmZzZXQ7XG4gICAgICAgIGNvbnN0IHRvcERlbHRhID0gYmxvY2sudG9wIC0gdG9wO1xuICAgICAgICBsZXQgYmxvY2tJbm5lck9mZnNldCA9IDA7XG4gICAgICAgIGxldCByYW5nZUlubmVyT2Zmc2V0ID0gMDtcbiAgICAgICAgbGV0IHVzZWRCbG9ja0xlbmd0aDtcblxuICAgICAgICBpZiAoZGVsdGEgPCAwKSB7XG4gICAgICAgICAgYmxvY2tJbm5lck9mZnNldCA9IC1kZWx0YTtcbiAgICAgICAgfSBlbHNlIGlmIChkZWx0YSA+IDApIHtcbiAgICAgICAgICByYW5nZUlubmVyT2Zmc2V0ID0gZGVsdGE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9wRGVsdGEgPCAwKSB7XG4gICAgICAgICAgdXNlZEJsb2NrTGVuZ3RoID0gYmxvY2subGVuZ3RoIC0gYmxvY2tJbm5lck9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1c2VkQmxvY2tMZW5ndGggPSB0b3AgLSBibG9jay5vZmZzZXQgLSBibG9ja0lubmVyT2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYmxvY2tWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2suZGF0YSwgYmxvY2tJbm5lck9mZnNldCwgdXNlZEJsb2NrTGVuZ3RoKTtcbiAgICAgICAgc2xpY2VWaWV3LnNldChibG9ja1ZpZXcsIHJhbmdlSW5uZXJPZmZzZXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2xpY2VEYXRhO1xuICAgIH0pO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/source/blockedsource.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/client/base.js":
/*!****************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/client/base.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseClient: () => (/* binding */ BaseClient),\n/* harmony export */   BaseResponse: () => (/* binding */ BaseResponse)\n/* harmony export */ });\nclass BaseResponse {\n  /**\n   * Returns whether the response has an ok'ish status code\n   */\n  get ok() {\n    return this.status >= 200 && this.status <= 299;\n  }\n\n  /**\n   * Returns the status code of the response\n   */\n  get status() {\n    throw new Error('not implemented');\n  }\n\n  /**\n   * Returns the value of the specified header\n   * @param {string} headerName the header name\n   * @returns {string} the header value\n   */\n  getHeader(headerName) { // eslint-disable-line no-unused-vars\n    throw new Error('not implemented');\n  }\n\n  /**\n   * @returns {ArrayBuffer} the response data of the request\n   */\n  async getData() {\n    throw new Error('not implemented');\n  }\n}\n\nclass BaseClient {\n  constructor(url) {\n    this.url = url;\n  }\n\n  /**\n   * Send a request with the options\n   * @param {{headers: HeadersInit, signal: AbortSignal}} [options={}]\n   * @returns {Promise<BaseResponse>}\n   */\n  async request({ headers, signal } = {}) { // eslint-disable-line no-unused-vars\n    throw new Error('request is not implemented');\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvY2xpZW50L2Jhc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlcnJpYWpzLW1hcC8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9jbGllbnQvYmFzZS5qcz9iZTg0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBCYXNlUmVzcG9uc2Uge1xuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSByZXNwb25zZSBoYXMgYW4gb2snaXNoIHN0YXR1cyBjb2RlXG4gICAqL1xuICBnZXQgb2soKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8PSAyOTk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RhdHVzIGNvZGUgb2YgdGhlIHJlc3BvbnNlXG4gICAqL1xuICBnZXQgc3RhdHVzKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBoZWFkZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhlYWRlck5hbWUgdGhlIGhlYWRlciBuYW1lXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBoZWFkZXIgdmFsdWVcbiAgICovXG4gIGdldEhlYWRlcihoZWFkZXJOYW1lKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gdGhlIHJlc3BvbnNlIGRhdGEgb2YgdGhlIHJlcXVlc3RcbiAgICovXG4gIGFzeW5jIGdldERhdGEoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQmFzZUNsaWVudCB7XG4gIGNvbnN0cnVjdG9yKHVybCkge1xuICAgIHRoaXMudXJsID0gdXJsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSByZXF1ZXN0IHdpdGggdGhlIG9wdGlvbnNcbiAgICogQHBhcmFtIHt7aGVhZGVyczogSGVhZGVyc0luaXQsIHNpZ25hbDogQWJvcnRTaWduYWx9fSBbb3B0aW9ucz17fV1cbiAgICogQHJldHVybnMge1Byb21pc2U8QmFzZVJlc3BvbnNlPn1cbiAgICovXG4gIGFzeW5jIHJlcXVlc3QoeyBoZWFkZXJzLCBzaWduYWwgfSA9IHt9KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcXVlc3QgaXMgbm90IGltcGxlbWVudGVkJyk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/source/client/base.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/client/fetch.js":
/*!*****************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/client/fetch.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FetchClient: () => (/* binding */ FetchClient)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"./node_modules/geotiff/dist-module/source/client/base.js\");\n\n\nclass FetchResponse extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseResponse {\n  /**\n   * BaseResponse facade for fetch API Response\n   * @param {Response} response\n   */\n  constructor(response) {\n    super();\n    this.response = response;\n  }\n\n  get status() {\n    return this.response.status;\n  }\n\n  getHeader(name) {\n    return this.response.headers.get(name);\n  }\n\n  async getData() {\n    const data = this.response.arrayBuffer\n      ? await this.response.arrayBuffer()\n      : (await this.response.buffer()).buffer;\n    return data;\n  }\n}\n\nclass FetchClient extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseClient {\n  constructor(url, credentials) {\n    super(url);\n    this.credentials = credentials;\n  }\n\n  /**\n   * @param {{headers: HeadersInit, signal: AbortSignal}} [options={}]\n   * @returns {Promise<FetchResponse>}\n   */\n  async request({ headers, signal } = {}) {\n    const response = await fetch(this.url, {\n      headers, credentials: this.credentials, signal,\n    });\n    return new FetchResponse(response);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvY2xpZW50L2ZldGNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVycmlhanMtbWFwLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvc291cmNlL2NsaWVudC9mZXRjaC5qcz8wMjU2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VDbGllbnQsIEJhc2VSZXNwb25zZSB9IGZyb20gJy4vYmFzZS5qcyc7XG5cbmNsYXNzIEZldGNoUmVzcG9uc2UgZXh0ZW5kcyBCYXNlUmVzcG9uc2Uge1xuICAvKipcbiAgICogQmFzZVJlc3BvbnNlIGZhY2FkZSBmb3IgZmV0Y2ggQVBJIFJlc3BvbnNlXG4gICAqIEBwYXJhbSB7UmVzcG9uc2V9IHJlc3BvbnNlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZXNwb25zZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICB9XG5cbiAgZ2V0IHN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNwb25zZS5zdGF0dXM7XG4gIH1cblxuICBnZXRIZWFkZXIobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlLmhlYWRlcnMuZ2V0KG5hbWUpO1xuICB9XG5cbiAgYXN5bmMgZ2V0RGF0YSgpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5yZXNwb25zZS5hcnJheUJ1ZmZlclxuICAgICAgPyBhd2FpdCB0aGlzLnJlc3BvbnNlLmFycmF5QnVmZmVyKClcbiAgICAgIDogKGF3YWl0IHRoaXMucmVzcG9uc2UuYnVmZmVyKCkpLmJ1ZmZlcjtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRmV0Y2hDbGllbnQgZXh0ZW5kcyBCYXNlQ2xpZW50IHtcbiAgY29uc3RydWN0b3IodXJsLCBjcmVkZW50aWFscykge1xuICAgIHN1cGVyKHVybCk7XG4gICAgdGhpcy5jcmVkZW50aWFscyA9IGNyZWRlbnRpYWxzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7e2hlYWRlcnM6IEhlYWRlcnNJbml0LCBzaWduYWw6IEFib3J0U2lnbmFsfX0gW29wdGlvbnM9e31dXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEZldGNoUmVzcG9uc2U+fVxuICAgKi9cbiAgYXN5bmMgcmVxdWVzdCh7IGhlYWRlcnMsIHNpZ25hbCB9ID0ge30pIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHRoaXMudXJsLCB7XG4gICAgICBoZWFkZXJzLCBjcmVkZW50aWFsczogdGhpcy5jcmVkZW50aWFscywgc2lnbmFsLFxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgRmV0Y2hSZXNwb25zZShyZXNwb25zZSk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/source/client/fetch.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/client/http.js":
/*!****************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/client/http.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HttpClient: () => (/* binding */ HttpClient)\n/* harmony export */ });\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! http */ \"?cdec\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! https */ \"?753a\");\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! url */ \"?4e4d\");\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base.js */ \"./node_modules/geotiff/dist-module/source/client/base.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils.js */ \"./node_modules/geotiff/dist-module/utils.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\n\n\n\n\n\n\nclass HttpResponse extends _base_js__WEBPACK_IMPORTED_MODULE_3__.BaseResponse {\n  /**\n   * BaseResponse facade for node HTTP/HTTPS API Response\n   * @param {http.ServerResponse} response\n   */\n  constructor(response, dataPromise) {\n    super();\n    this.response = response;\n    this.dataPromise = dataPromise;\n  }\n\n  get status() {\n    return this.response.statusCode;\n  }\n\n  getHeader(name) {\n    return this.response.headers[name];\n  }\n\n  async getData() {\n    const data = await this.dataPromise;\n    return data;\n  }\n}\n\nclass HttpClient extends _base_js__WEBPACK_IMPORTED_MODULE_3__.BaseClient {\n  constructor(url) {\n    super(url);\n    this.parsedUrl = url__WEBPACK_IMPORTED_MODULE_2__.parse(this.url);\n    this.httpApi = (this.parsedUrl.protocol === 'http:' ? http__WEBPACK_IMPORTED_MODULE_0__ : https__WEBPACK_IMPORTED_MODULE_1__);\n  }\n\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const request = this.httpApi.get(\n        {\n          ...this.parsedUrl,\n          headers,\n        },\n        (response) => {\n          const dataPromise = new Promise((resolveData) => {\n            const chunks = [];\n\n            // collect chunks\n            response.on('data', (chunk) => {\n              chunks.push(chunk);\n            });\n\n            // concatenate all chunks and resolve the promise with the resulting buffer\n            response.on('end', () => {\n              const data = Buffer.concat(chunks).buffer;\n              resolveData(data);\n            });\n            response.on('error', reject);\n          });\n          resolve(new HttpResponse(response, dataPromise));\n        },\n      );\n      request.on('error', reject);\n\n      if (signal) {\n        if (signal.aborted) {\n          request.destroy(new _utils_js__WEBPACK_IMPORTED_MODULE_4__.AbortError('Request aborted'));\n        }\n        signal.addEventListener('abort', () => request.destroy(new _utils_js__WEBPACK_IMPORTED_MODULE_4__.AbortError('Request aborted')));\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvY2xpZW50L2h0dHAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlcnJpYWpzLW1hcC8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9jbGllbnQvaHR0cC5qcz85YTdmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBodHRwIGZyb20gJ2h0dHAnO1xuaW1wb3J0IGh0dHBzIGZyb20gJ2h0dHBzJztcbmltcG9ydCB1cmxNb2QgZnJvbSAndXJsJztcblxuaW1wb3J0IHsgQmFzZUNsaWVudCwgQmFzZVJlc3BvbnNlIH0gZnJvbSAnLi9iYXNlLmpzJztcbmltcG9ydCB7IEFib3J0RXJyb3IgfSBmcm9tICcuLi8uLi91dGlscy5qcyc7XG5cbmNsYXNzIEh0dHBSZXNwb25zZSBleHRlbmRzIEJhc2VSZXNwb25zZSB7XG4gIC8qKlxuICAgKiBCYXNlUmVzcG9uc2UgZmFjYWRlIGZvciBub2RlIEhUVFAvSFRUUFMgQVBJIFJlc3BvbnNlXG4gICAqIEBwYXJhbSB7aHR0cC5TZXJ2ZXJSZXNwb25zZX0gcmVzcG9uc2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlc3BvbnNlLCBkYXRhUHJvbWlzZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIHRoaXMuZGF0YVByb21pc2UgPSBkYXRhUHJvbWlzZTtcbiAgfVxuXG4gIGdldCBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzcG9uc2Uuc3RhdHVzQ29kZTtcbiAgfVxuXG4gIGdldEhlYWRlcihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzcG9uc2UuaGVhZGVyc1tuYW1lXTtcbiAgfVxuXG4gIGFzeW5jIGdldERhdGEoKSB7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuZGF0YVByb21pc2U7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEh0dHBDbGllbnQgZXh0ZW5kcyBCYXNlQ2xpZW50IHtcbiAgY29uc3RydWN0b3IodXJsKSB7XG4gICAgc3VwZXIodXJsKTtcbiAgICB0aGlzLnBhcnNlZFVybCA9IHVybE1vZC5wYXJzZSh0aGlzLnVybCk7XG4gICAgdGhpcy5odHRwQXBpID0gKHRoaXMucGFyc2VkVXJsLnByb3RvY29sID09PSAnaHR0cDonID8gaHR0cCA6IGh0dHBzKTtcbiAgfVxuXG4gIGNvbnN0cnVjdFJlcXVlc3QoaGVhZGVycywgc2lnbmFsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmh0dHBBcGkuZ2V0KFxuICAgICAgICB7XG4gICAgICAgICAgLi4udGhpcy5wYXJzZWRVcmwsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgfSxcbiAgICAgICAgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgY29uc3QgZGF0YVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZURhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuXG4gICAgICAgICAgICAvLyBjb2xsZWN0IGNodW5rc1xuICAgICAgICAgICAgcmVzcG9uc2Uub24oJ2RhdGEnLCAoY2h1bmspID0+IHtcbiAgICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIGNvbmNhdGVuYXRlIGFsbCBjaHVua3MgYW5kIHJlc29sdmUgdGhlIHByb21pc2Ugd2l0aCB0aGUgcmVzdWx0aW5nIGJ1ZmZlclxuICAgICAgICAgICAgcmVzcG9uc2Uub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IEJ1ZmZlci5jb25jYXQoY2h1bmtzKS5idWZmZXI7XG4gICAgICAgICAgICAgIHJlc29sdmVEYXRhKGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXNwb25zZS5vbignZXJyb3InLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlc29sdmUobmV3IEh0dHBSZXNwb25zZShyZXNwb25zZSwgZGF0YVByb21pc2UpKTtcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgICByZXF1ZXN0Lm9uKCdlcnJvcicsIHJlamVjdCk7XG5cbiAgICAgIGlmIChzaWduYWwpIHtcbiAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgcmVxdWVzdC5kZXN0cm95KG5ldyBBYm9ydEVycm9yKCdSZXF1ZXN0IGFib3J0ZWQnKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4gcmVxdWVzdC5kZXN0cm95KG5ldyBBYm9ydEVycm9yKCdSZXF1ZXN0IGFib3J0ZWQnKSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgcmVxdWVzdCh7IGhlYWRlcnMsIHNpZ25hbCB9ID0ge30pIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY29uc3RydWN0UmVxdWVzdChoZWFkZXJzLCBzaWduYWwpO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/source/client/http.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/client/xhr.js":
/*!***************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/client/xhr.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   XHRClient: () => (/* binding */ XHRClient)\n/* harmony export */ });\n/* harmony import */ var _base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base.js */ \"./node_modules/geotiff/dist-module/source/client/base.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils.js */ \"./node_modules/geotiff/dist-module/utils.js\");\n\n\n\nclass XHRResponse extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseResponse {\n  /**\n   * BaseResponse facade for XMLHttpRequest\n   * @param {XMLHttpRequest} xhr\n   * @param {ArrayBuffer} data\n   */\n  constructor(xhr, data) {\n    super();\n    this.xhr = xhr;\n    this.data = data;\n  }\n\n  get status() {\n    return this.xhr.status;\n  }\n\n  getHeader(name) {\n    return this.xhr.getResponseHeader(name);\n  }\n\n  async getData() {\n    return this.data;\n  }\n}\n\nclass XHRClient extends _base_js__WEBPACK_IMPORTED_MODULE_0__.BaseClient {\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('GET', this.url);\n      xhr.responseType = 'arraybuffer';\n      for (const [key, value] of Object.entries(headers)) {\n        xhr.setRequestHeader(key, value);\n      }\n\n      // hook signals\n      xhr.onload = () => {\n        const data = xhr.response;\n        resolve(new XHRResponse(xhr, data));\n      };\n      xhr.onerror = reject;\n      xhr.onabort = () => reject(new _utils_js__WEBPACK_IMPORTED_MODULE_1__.AbortError('Request aborted'));\n      xhr.send();\n\n      if (signal) {\n        if (signal.aborted) {\n          xhr.abort();\n        }\n        signal.addEventListener('abort', () => xhr.abort());\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvY2xpZW50L3hoci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlcnJpYWpzLW1hcC8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9jbGllbnQveGhyLmpzP2NkYjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZUNsaWVudCwgQmFzZVJlc3BvbnNlIH0gZnJvbSAnLi9iYXNlLmpzJztcbmltcG9ydCB7IEFib3J0RXJyb3IgfSBmcm9tICcuLi8uLi91dGlscy5qcyc7XG5cbmNsYXNzIFhIUlJlc3BvbnNlIGV4dGVuZHMgQmFzZVJlc3BvbnNlIHtcbiAgLyoqXG4gICAqIEJhc2VSZXNwb25zZSBmYWNhZGUgZm9yIFhNTEh0dHBSZXF1ZXN0XG4gICAqIEBwYXJhbSB7WE1MSHR0cFJlcXVlc3R9IHhoclxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih4aHIsIGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMueGhyID0geGhyO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cblxuICBnZXQgc3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLnhoci5zdGF0dXM7XG4gIH1cblxuICBnZXRIZWFkZXIobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnhoci5nZXRSZXNwb25zZUhlYWRlcihuYW1lKTtcbiAgfVxuXG4gIGFzeW5jIGdldERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgWEhSQ2xpZW50IGV4dGVuZHMgQmFzZUNsaWVudCB7XG4gIGNvbnN0cnVjdFJlcXVlc3QoaGVhZGVycywgc2lnbmFsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgeGhyLm9wZW4oJ0dFVCcsIHRoaXMudXJsKTtcbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaGVhZGVycykpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGhvb2sgc2lnbmFsc1xuICAgICAgeGhyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHhoci5yZXNwb25zZTtcbiAgICAgICAgcmVzb2x2ZShuZXcgWEhSUmVzcG9uc2UoeGhyLCBkYXRhKSk7XG4gICAgICB9O1xuICAgICAgeGhyLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICB4aHIub25hYm9ydCA9ICgpID0+IHJlamVjdChuZXcgQWJvcnRFcnJvcignUmVxdWVzdCBhYm9ydGVkJykpO1xuICAgICAgeGhyLnNlbmQoKTtcblxuICAgICAgaWYgKHNpZ25hbCkge1xuICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB4aHIuYWJvcnQoKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyByZXF1ZXN0KHsgaGVhZGVycywgc2lnbmFsIH0gPSB7fSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jb25zdHJ1Y3RSZXF1ZXN0KGhlYWRlcnMsIHNpZ25hbCk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/source/client/xhr.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/file.js":
/*!*********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/file.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   makeFileSource: () => (/* binding */ makeFileSource)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"?662e\");\n/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basesource.js */ \"./node_modules/geotiff/dist-module/source/basesource.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\n\n\nfunction closeAsync(fd) {\n  return new Promise((resolve, reject) => {\n    fs__WEBPACK_IMPORTED_MODULE_0__.close(fd, (err) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\nfunction openAsync(path, flags, mode = undefined) {\n  return new Promise((resolve, reject) => {\n    fs__WEBPACK_IMPORTED_MODULE_0__.open(path, flags, mode, (err, fd) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(fd);\n      }\n    });\n  });\n}\n\nfunction readAsync(...args) {\n  return new Promise((resolve, reject) => {\n    fs__WEBPACK_IMPORTED_MODULE_0__.read(...args, (err, bytesRead, buffer) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve({ bytesRead, buffer });\n      }\n    });\n  });\n}\n\nclass FileSource extends _basesource_js__WEBPACK_IMPORTED_MODULE_1__.BaseSource {\n  constructor(path) {\n    super();\n    this.path = path;\n    this.openRequest = openAsync(path, 'r');\n  }\n\n  async fetchSlice(slice) {\n    // TODO: use `signal`\n    const fd = await this.openRequest;\n    const { buffer } = await readAsync(\n      fd,\n      Buffer.alloc(slice.length),\n      0,\n      slice.length,\n      slice.offset,\n    );\n    return buffer.buffer;\n  }\n\n  async close() {\n    const fd = await this.openRequest;\n    await closeAsync(fd);\n  }\n}\n\nfunction makeFileSource(path) {\n  return new FileSource(path);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvZmlsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlcnJpYWpzLW1hcC8uL25vZGVfbW9kdWxlcy9nZW90aWZmL2Rpc3QtbW9kdWxlL3NvdXJjZS9maWxlLmpzPzRjMjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCB7IEJhc2VTb3VyY2UgfSBmcm9tICcuL2Jhc2Vzb3VyY2UuanMnO1xuXG5mdW5jdGlvbiBjbG9zZUFzeW5jKGZkKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZnMuY2xvc2UoZmQsIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvcGVuQXN5bmMocGF0aCwgZmxhZ3MsIG1vZGUgPSB1bmRlZmluZWQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmcy5vcGVuKHBhdGgsIGZsYWdzLCBtb2RlLCAoZXJyLCBmZCkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUoZmQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVhZEFzeW5jKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmcy5yZWFkKC4uLmFyZ3MsIChlcnIsIGJ5dGVzUmVhZCwgYnVmZmVyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZSh7IGJ5dGVzUmVhZCwgYnVmZmVyIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuY2xhc3MgRmlsZVNvdXJjZSBleHRlbmRzIEJhc2VTb3VyY2Uge1xuICBjb25zdHJ1Y3RvcihwYXRoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMub3BlblJlcXVlc3QgPSBvcGVuQXN5bmMocGF0aCwgJ3InKTtcbiAgfVxuXG4gIGFzeW5jIGZldGNoU2xpY2Uoc2xpY2UpIHtcbiAgICAvLyBUT0RPOiB1c2UgYHNpZ25hbGBcbiAgICBjb25zdCBmZCA9IGF3YWl0IHRoaXMub3BlblJlcXVlc3Q7XG4gICAgY29uc3QgeyBidWZmZXIgfSA9IGF3YWl0IHJlYWRBc3luYyhcbiAgICAgIGZkLFxuICAgICAgQnVmZmVyLmFsbG9jKHNsaWNlLmxlbmd0aCksXG4gICAgICAwLFxuICAgICAgc2xpY2UubGVuZ3RoLFxuICAgICAgc2xpY2Uub2Zmc2V0LFxuICAgICk7XG4gICAgcmV0dXJuIGJ1ZmZlci5idWZmZXI7XG4gIH1cblxuICBhc3luYyBjbG9zZSgpIHtcbiAgICBjb25zdCBmZCA9IGF3YWl0IHRoaXMub3BlblJlcXVlc3Q7XG4gICAgYXdhaXQgY2xvc2VBc3luYyhmZCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VGaWxlU291cmNlKHBhdGgpIHtcbiAgcmV0dXJuIG5ldyBGaWxlU291cmNlKHBhdGgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/source/file.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/filereader.js":
/*!***************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/filereader.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   makeFileReaderSource: () => (/* binding */ makeFileReaderSource)\n/* harmony export */ });\n/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basesource.js */ \"./node_modules/geotiff/dist-module/source/basesource.js\");\n\n\nclass FileReaderSource extends _basesource_js__WEBPACK_IMPORTED_MODULE_0__.BaseSource {\n  constructor(file) {\n    super();\n    this.file = file;\n  }\n\n  async fetchSlice(slice, signal) {\n    return new Promise((resolve, reject) => {\n      const blob = this.file.slice(slice.offset, slice.offset + slice.length);\n      const reader = new FileReader();\n      reader.onload = (event) => resolve(event.target.result);\n      reader.onerror = reject;\n      reader.onabort = reject;\n      reader.readAsArrayBuffer(blob);\n\n      if (signal) {\n        signal.addEventListener('abort', () => reader.abort());\n      }\n    });\n  }\n}\n\n/**\n * Create a new source from a given file/blob.\n * @param {Blob} file The file or blob to read from.\n * @returns The constructed source\n */\nfunction makeFileReaderSource(file) {\n  return new FileReaderSource(file);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvZmlsZXJlYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZXJyaWFqcy1tYXAvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvZmlsZXJlYWRlci5qcz8zYjIyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJhc2VTb3VyY2UgfSBmcm9tICcuL2Jhc2Vzb3VyY2UuanMnO1xuXG5jbGFzcyBGaWxlUmVhZGVyU291cmNlIGV4dGVuZHMgQmFzZVNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yKGZpbGUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZmlsZSA9IGZpbGU7XG4gIH1cblxuICBhc3luYyBmZXRjaFNsaWNlKHNsaWNlLCBzaWduYWwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgYmxvYiA9IHRoaXMuZmlsZS5zbGljZShzbGljZS5vZmZzZXQsIHNsaWNlLm9mZnNldCArIHNsaWNlLmxlbmd0aCk7XG4gICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgcmVhZGVyLm9ubG9hZCA9IChldmVudCkgPT4gcmVzb2x2ZShldmVudC50YXJnZXQucmVzdWx0KTtcbiAgICAgIHJlYWRlci5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgcmVhZGVyLm9uYWJvcnQgPSByZWplY3Q7XG4gICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYik7XG5cbiAgICAgIGlmIChzaWduYWwpIHtcbiAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4gcmVhZGVyLmFib3J0KCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHNvdXJjZSBmcm9tIGEgZ2l2ZW4gZmlsZS9ibG9iLlxuICogQHBhcmFtIHtCbG9ifSBmaWxlIFRoZSBmaWxlIG9yIGJsb2IgdG8gcmVhZCBmcm9tLlxuICogQHJldHVybnMgVGhlIGNvbnN0cnVjdGVkIHNvdXJjZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZUZpbGVSZWFkZXJTb3VyY2UoZmlsZSkge1xuICByZXR1cm4gbmV3IEZpbGVSZWFkZXJTb3VyY2UoZmlsZSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/source/filereader.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/httputils.js":
/*!**************************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/httputils.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseByteRanges: () => (/* binding */ parseByteRanges),\n/* harmony export */   parseContentRange: () => (/* binding */ parseContentRange),\n/* harmony export */   parseContentType: () => (/* binding */ parseContentType)\n/* harmony export */ });\nconst CRLFCRLF = '\\r\\n\\r\\n';\n\n/*\n * Shim for 'Object.fromEntries'\n */\nfunction itemsToObject(items) {\n  if (typeof Object.fromEntries !== 'undefined') {\n    return Object.fromEntries(items);\n  }\n  const obj = {};\n  for (const [key, value] of items) {\n    obj[key.toLowerCase()] = value;\n  }\n  return obj;\n}\n\n/**\n * Parse HTTP headers from a given string.\n * @param {String} text the text to parse the headers from\n * @returns {Object} the parsed headers with lowercase keys\n */\nfunction parseHeaders(text) {\n  const items = text\n    .split('\\r\\n')\n    .map((line) => {\n      const kv = line.split(':').map((str) => str.trim());\n      kv[0] = kv[0].toLowerCase();\n      return kv;\n    });\n\n  return itemsToObject(items);\n}\n\n/**\n * Parse a 'Content-Type' header value to the content-type and parameters\n * @param {String} rawContentType the raw string to parse from\n * @returns {Object} the parsed content type with the fields: type and params\n */\nfunction parseContentType(rawContentType) {\n  const [type, ...rawParams] = rawContentType.split(';').map((s) => s.trim());\n  const paramsItems = rawParams.map((param) => param.split('='));\n  return { type, params: itemsToObject(paramsItems) };\n}\n\n/**\n * Parse a 'Content-Range' header value to its start, end, and total parts\n * @param {String} rawContentRange the raw string to parse from\n * @returns {Object} the parsed parts\n */\nfunction parseContentRange(rawContentRange) {\n  let start;\n  let end;\n  let total;\n\n  if (rawContentRange) {\n    [, start, end, total] = rawContentRange.match(/bytes (\\d+)-(\\d+)\\/(\\d+)/);\n    start = parseInt(start, 10);\n    end = parseInt(end, 10);\n    total = parseInt(total, 10);\n  }\n\n  return { start, end, total };\n}\n\n/**\n * Parses a list of byteranges from the given 'multipart/byteranges' HTTP response.\n * Each item in the list has the following properties:\n * - headers: the HTTP headers\n * - data: the sliced ArrayBuffer for that specific part\n * - offset: the offset of the byterange within its originating file\n * - length: the length of the byterange\n * @param {ArrayBuffer} responseArrayBuffer the response to be parsed and split\n * @param {String} boundary the boundary string used to split the sections\n * @returns {Object[]} the parsed byteranges\n */\nfunction parseByteRanges(responseArrayBuffer, boundary) {\n  let offset = null;\n  const decoder = new TextDecoder('ascii');\n  const out = [];\n\n  const startBoundary = `--${boundary}`;\n  const endBoundary = `${startBoundary}--`;\n\n  // search for the initial boundary, may be offset by some bytes\n  // TODO: more efficient to check for `--` in bytes directly\n  for (let i = 0; i < 10; ++i) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, i, startBoundary.length),\n    );\n    if (text === startBoundary) {\n      offset = i;\n    }\n  }\n\n  if (offset === null) {\n    throw new Error('Could not find initial boundary');\n  }\n\n  while (offset < responseArrayBuffer.byteLength) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, offset,\n        Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset),\n      ),\n    );\n\n    // break if we arrived at the end\n    if (text.length === 0 || text.startsWith(endBoundary)) {\n      break;\n    }\n\n    // assert that we are actually dealing with a byterange and are at the correct offset\n    if (!text.startsWith(startBoundary)) {\n      throw new Error('Part does not start with boundary');\n    }\n\n    // get a substring from where we read the headers\n    const innerText = text.substr(startBoundary.length + 2);\n\n    if (innerText.length === 0) {\n      break;\n    }\n\n    // find the double linebreak that denotes the end of the headers\n    const endOfHeaders = innerText.indexOf(CRLFCRLF);\n\n    // parse the headers to get the content range size\n    const headers = parseHeaders(innerText.substr(0, endOfHeaders));\n    const { start, end, total } = parseContentRange(headers['content-range']);\n\n    // calculate the length of the slice and the next offset\n    const startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;\n    const length = parseInt(end, 10) + 1 - parseInt(start, 10);\n    out.push({\n      headers,\n      data: responseArrayBuffer.slice(startOfData, startOfData + length),\n      offset: start,\n      length,\n      fileSize: total,\n    });\n\n    offset = startOfData + length + 4;\n  }\n\n  return out;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvaHR0cHV0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVycmlhanMtbWFwLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvc291cmNlL2h0dHB1dGlscy5qcz85ZjhkIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IENSTEZDUkxGID0gJ1xcclxcblxcclxcbic7XG5cbi8qXG4gKiBTaGltIGZvciAnT2JqZWN0LmZyb21FbnRyaWVzJ1xuICovXG5mdW5jdGlvbiBpdGVtc1RvT2JqZWN0KGl0ZW1zKSB7XG4gIGlmICh0eXBlb2YgT2JqZWN0LmZyb21FbnRyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoaXRlbXMpO1xuICB9XG4gIGNvbnN0IG9iaiA9IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBpdGVtcykge1xuICAgIG9ialtrZXkudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIFBhcnNlIEhUVFAgaGVhZGVycyBmcm9tIGEgZ2l2ZW4gc3RyaW5nLlxuICogQHBhcmFtIHtTdHJpbmd9IHRleHQgdGhlIHRleHQgdG8gcGFyc2UgdGhlIGhlYWRlcnMgZnJvbVxuICogQHJldHVybnMge09iamVjdH0gdGhlIHBhcnNlZCBoZWFkZXJzIHdpdGggbG93ZXJjYXNlIGtleXNcbiAqL1xuZnVuY3Rpb24gcGFyc2VIZWFkZXJzKHRleHQpIHtcbiAgY29uc3QgaXRlbXMgPSB0ZXh0XG4gICAgLnNwbGl0KCdcXHJcXG4nKVxuICAgIC5tYXAoKGxpbmUpID0+IHtcbiAgICAgIGNvbnN0IGt2ID0gbGluZS5zcGxpdCgnOicpLm1hcCgoc3RyKSA9PiBzdHIudHJpbSgpKTtcbiAgICAgIGt2WzBdID0ga3ZbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgIHJldHVybiBrdjtcbiAgICB9KTtcblxuICByZXR1cm4gaXRlbXNUb09iamVjdChpdGVtcyk7XG59XG5cbi8qKlxuICogUGFyc2UgYSAnQ29udGVudC1UeXBlJyBoZWFkZXIgdmFsdWUgdG8gdGhlIGNvbnRlbnQtdHlwZSBhbmQgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtTdHJpbmd9IHJhd0NvbnRlbnRUeXBlIHRoZSByYXcgc3RyaW5nIHRvIHBhcnNlIGZyb21cbiAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBwYXJzZWQgY29udGVudCB0eXBlIHdpdGggdGhlIGZpZWxkczogdHlwZSBhbmQgcGFyYW1zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNvbnRlbnRUeXBlKHJhd0NvbnRlbnRUeXBlKSB7XG4gIGNvbnN0IFt0eXBlLCAuLi5yYXdQYXJhbXNdID0gcmF3Q29udGVudFR5cGUuc3BsaXQoJzsnKS5tYXAoKHMpID0+IHMudHJpbSgpKTtcbiAgY29uc3QgcGFyYW1zSXRlbXMgPSByYXdQYXJhbXMubWFwKChwYXJhbSkgPT4gcGFyYW0uc3BsaXQoJz0nKSk7XG4gIHJldHVybiB7IHR5cGUsIHBhcmFtczogaXRlbXNUb09iamVjdChwYXJhbXNJdGVtcykgfTtcbn1cblxuLyoqXG4gKiBQYXJzZSBhICdDb250ZW50LVJhbmdlJyBoZWFkZXIgdmFsdWUgdG8gaXRzIHN0YXJ0LCBlbmQsIGFuZCB0b3RhbCBwYXJ0c1xuICogQHBhcmFtIHtTdHJpbmd9IHJhd0NvbnRlbnRSYW5nZSB0aGUgcmF3IHN0cmluZyB0byBwYXJzZSBmcm9tXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgcGFyc2VkIHBhcnRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNvbnRlbnRSYW5nZShyYXdDb250ZW50UmFuZ2UpIHtcbiAgbGV0IHN0YXJ0O1xuICBsZXQgZW5kO1xuICBsZXQgdG90YWw7XG5cbiAgaWYgKHJhd0NvbnRlbnRSYW5nZSkge1xuICAgIFssIHN0YXJ0LCBlbmQsIHRvdGFsXSA9IHJhd0NvbnRlbnRSYW5nZS5tYXRjaCgvYnl0ZXMgKFxcZCspLShcXGQrKVxcLyhcXGQrKS8pO1xuICAgIHN0YXJ0ID0gcGFyc2VJbnQoc3RhcnQsIDEwKTtcbiAgICBlbmQgPSBwYXJzZUludChlbmQsIDEwKTtcbiAgICB0b3RhbCA9IHBhcnNlSW50KHRvdGFsLCAxMCk7XG4gIH1cblxuICByZXR1cm4geyBzdGFydCwgZW5kLCB0b3RhbCB9O1xufVxuXG4vKipcbiAqIFBhcnNlcyBhIGxpc3Qgb2YgYnl0ZXJhbmdlcyBmcm9tIHRoZSBnaXZlbiAnbXVsdGlwYXJ0L2J5dGVyYW5nZXMnIEhUVFAgcmVzcG9uc2UuXG4gKiBFYWNoIGl0ZW0gaW4gdGhlIGxpc3QgaGFzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqIC0gaGVhZGVyczogdGhlIEhUVFAgaGVhZGVyc1xuICogLSBkYXRhOiB0aGUgc2xpY2VkIEFycmF5QnVmZmVyIGZvciB0aGF0IHNwZWNpZmljIHBhcnRcbiAqIC0gb2Zmc2V0OiB0aGUgb2Zmc2V0IG9mIHRoZSBieXRlcmFuZ2Ugd2l0aGluIGl0cyBvcmlnaW5hdGluZyBmaWxlXG4gKiAtIGxlbmd0aDogdGhlIGxlbmd0aCBvZiB0aGUgYnl0ZXJhbmdlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSByZXNwb25zZUFycmF5QnVmZmVyIHRoZSByZXNwb25zZSB0byBiZSBwYXJzZWQgYW5kIHNwbGl0XG4gKiBAcGFyYW0ge1N0cmluZ30gYm91bmRhcnkgdGhlIGJvdW5kYXJ5IHN0cmluZyB1c2VkIHRvIHNwbGl0IHRoZSBzZWN0aW9uc1xuICogQHJldHVybnMge09iamVjdFtdfSB0aGUgcGFyc2VkIGJ5dGVyYW5nZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQnl0ZVJhbmdlcyhyZXNwb25zZUFycmF5QnVmZmVyLCBib3VuZGFyeSkge1xuICBsZXQgb2Zmc2V0ID0gbnVsbDtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcignYXNjaWknKTtcbiAgY29uc3Qgb3V0ID0gW107XG5cbiAgY29uc3Qgc3RhcnRCb3VuZGFyeSA9IGAtLSR7Ym91bmRhcnl9YDtcbiAgY29uc3QgZW5kQm91bmRhcnkgPSBgJHtzdGFydEJvdW5kYXJ5fS0tYDtcblxuICAvLyBzZWFyY2ggZm9yIHRoZSBpbml0aWFsIGJvdW5kYXJ5LCBtYXkgYmUgb2Zmc2V0IGJ5IHNvbWUgYnl0ZXNcbiAgLy8gVE9ETzogbW9yZSBlZmZpY2llbnQgdG8gY2hlY2sgZm9yIGAtLWAgaW4gYnl0ZXMgZGlyZWN0bHlcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgKytpKSB7XG4gICAgY29uc3QgdGV4dCA9IGRlY29kZXIuZGVjb2RlKFxuICAgICAgbmV3IFVpbnQ4QXJyYXkocmVzcG9uc2VBcnJheUJ1ZmZlciwgaSwgc3RhcnRCb3VuZGFyeS5sZW5ndGgpLFxuICAgICk7XG4gICAgaWYgKHRleHQgPT09IHN0YXJ0Qm91bmRhcnkpIHtcbiAgICAgIG9mZnNldCA9IGk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9mZnNldCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgaW5pdGlhbCBib3VuZGFyeScpO1xuICB9XG5cbiAgd2hpbGUgKG9mZnNldCA8IHJlc3BvbnNlQXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgIGNvbnN0IHRleHQgPSBkZWNvZGVyLmRlY29kZShcbiAgICAgIG5ldyBVaW50OEFycmF5KHJlc3BvbnNlQXJyYXlCdWZmZXIsIG9mZnNldCxcbiAgICAgICAgTWF0aC5taW4oc3RhcnRCb3VuZGFyeS5sZW5ndGggKyAxMDI0LCByZXNwb25zZUFycmF5QnVmZmVyLmJ5dGVMZW5ndGggLSBvZmZzZXQpLFxuICAgICAgKSxcbiAgICApO1xuXG4gICAgLy8gYnJlYWsgaWYgd2UgYXJyaXZlZCBhdCB0aGUgZW5kXG4gICAgaWYgKHRleHQubGVuZ3RoID09PSAwIHx8IHRleHQuc3RhcnRzV2l0aChlbmRCb3VuZGFyeSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIGFzc2VydCB0aGF0IHdlIGFyZSBhY3R1YWxseSBkZWFsaW5nIHdpdGggYSBieXRlcmFuZ2UgYW5kIGFyZSBhdCB0aGUgY29ycmVjdCBvZmZzZXRcbiAgICBpZiAoIXRleHQuc3RhcnRzV2l0aChzdGFydEJvdW5kYXJ5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJ0IGRvZXMgbm90IHN0YXJ0IHdpdGggYm91bmRhcnknKTtcbiAgICB9XG5cbiAgICAvLyBnZXQgYSBzdWJzdHJpbmcgZnJvbSB3aGVyZSB3ZSByZWFkIHRoZSBoZWFkZXJzXG4gICAgY29uc3QgaW5uZXJUZXh0ID0gdGV4dC5zdWJzdHIoc3RhcnRCb3VuZGFyeS5sZW5ndGggKyAyKTtcblxuICAgIGlmIChpbm5lclRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBmaW5kIHRoZSBkb3VibGUgbGluZWJyZWFrIHRoYXQgZGVub3RlcyB0aGUgZW5kIG9mIHRoZSBoZWFkZXJzXG4gICAgY29uc3QgZW5kT2ZIZWFkZXJzID0gaW5uZXJUZXh0LmluZGV4T2YoQ1JMRkNSTEYpO1xuXG4gICAgLy8gcGFyc2UgdGhlIGhlYWRlcnMgdG8gZ2V0IHRoZSBjb250ZW50IHJhbmdlIHNpemVcbiAgICBjb25zdCBoZWFkZXJzID0gcGFyc2VIZWFkZXJzKGlubmVyVGV4dC5zdWJzdHIoMCwgZW5kT2ZIZWFkZXJzKSk7XG4gICAgY29uc3QgeyBzdGFydCwgZW5kLCB0b3RhbCB9ID0gcGFyc2VDb250ZW50UmFuZ2UoaGVhZGVyc1snY29udGVudC1yYW5nZSddKTtcblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgbGVuZ3RoIG9mIHRoZSBzbGljZSBhbmQgdGhlIG5leHQgb2Zmc2V0XG4gICAgY29uc3Qgc3RhcnRPZkRhdGEgPSBvZmZzZXQgKyBzdGFydEJvdW5kYXJ5Lmxlbmd0aCArIGVuZE9mSGVhZGVycyArIENSTEZDUkxGLmxlbmd0aDtcbiAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChlbmQsIDEwKSArIDEgLSBwYXJzZUludChzdGFydCwgMTApO1xuICAgIG91dC5wdXNoKHtcbiAgICAgIGhlYWRlcnMsXG4gICAgICBkYXRhOiByZXNwb25zZUFycmF5QnVmZmVyLnNsaWNlKHN0YXJ0T2ZEYXRhLCBzdGFydE9mRGF0YSArIGxlbmd0aCksXG4gICAgICBvZmZzZXQ6IHN0YXJ0LFxuICAgICAgbGVuZ3RoLFxuICAgICAgZmlsZVNpemU6IHRvdGFsLFxuICAgIH0pO1xuXG4gICAgb2Zmc2V0ID0gc3RhcnRPZkRhdGEgKyBsZW5ndGggKyA0O1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/source/httputils.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/source/remote.js":
/*!***********************************************************!*\
  !*** ./node_modules/geotiff/dist-module/source/remote.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   makeCustomSource: () => (/* binding */ makeCustomSource),\n/* harmony export */   makeFetchSource: () => (/* binding */ makeFetchSource),\n/* harmony export */   makeHttpSource: () => (/* binding */ makeHttpSource),\n/* harmony export */   makeRemoteSource: () => (/* binding */ makeRemoteSource),\n/* harmony export */   makeXHRSource: () => (/* binding */ makeXHRSource)\n/* harmony export */ });\n/* harmony import */ var _httputils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./httputils.js */ \"./node_modules/geotiff/dist-module/source/httputils.js\");\n/* harmony import */ var _basesource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basesource.js */ \"./node_modules/geotiff/dist-module/source/basesource.js\");\n/* harmony import */ var _blockedsource_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./blockedsource.js */ \"./node_modules/geotiff/dist-module/source/blockedsource.js\");\n/* harmony import */ var _client_fetch_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./client/fetch.js */ \"./node_modules/geotiff/dist-module/source/client/fetch.js\");\n/* harmony import */ var _client_xhr_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./client/xhr.js */ \"./node_modules/geotiff/dist-module/source/client/xhr.js\");\n/* harmony import */ var _client_http_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./client/http.js */ \"./node_modules/geotiff/dist-module/source/client/http.js\");\n\n\n\n\n\n\n\n\nclass RemoteSource extends _basesource_js__WEBPACK_IMPORTED_MODULE_0__.BaseSource {\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  constructor(client, headers, maxRanges, allowFullFile) {\n    super();\n    this.client = client;\n    this.headers = headers;\n    this.maxRanges = maxRanges;\n    this.allowFullFile = allowFullFile;\n    this._fileSize = null;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    // if we allow multi-ranges, split the incoming request into that many sub-requests\n    // and join them afterwards\n    if (this.maxRanges >= slices.length) {\n      return this.fetchSlices(slices, signal);\n    } else if (this.maxRanges > 0 && slices.length > 1) {\n      // TODO: split into multiple multi-range requests\n\n      // const subSlicesRequests = [];\n      // for (let i = 0; i < slices.length; i += this.maxRanges) {\n      //   subSlicesRequests.push(\n      //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n      //   );\n      // }\n      // return (await Promise.all(subSlicesRequests)).flat();\n    }\n\n    // otherwise make a single request for each slice\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  async fetchSlices(slices, signal) {\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${slices\n          .map(({ offset, length }) => `${offset}-${offset + length}`)\n          .join(',')\n        }`,\n      },\n      signal,\n    });\n\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const { type, params } = (0,_httputils_js__WEBPACK_IMPORTED_MODULE_1__.parseContentType)(response.getHeader('content-type'));\n      if (type === 'multipart/byteranges') {\n        const byteRanges = (0,_httputils_js__WEBPACK_IMPORTED_MODULE_1__.parseByteRanges)(await response.getData(), params.boundary);\n        this._fileSize = byteRanges[0].fileSize || null;\n        return byteRanges;\n      }\n\n      const data = await response.getData();\n\n      const { start, end, total } = (0,_httputils_js__WEBPACK_IMPORTED_MODULE_1__.parseContentRange)(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      const first = [{\n        data,\n        offset: start,\n        length: end - start,\n      }];\n\n      if (slices.length > 1) {\n        // we requested more than one slice, but got only the first\n        // unfortunately, some HTTP Servers don't support multi-ranges\n        // and return only the first\n\n        // get the rest of the slices and fetch them iteratively\n        const others = await Promise.all(slices.slice(1).map((slice) => this.fetchSlice(slice, signal)));\n        return first.concat(others);\n      }\n      return first;\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return [{\n        data,\n        offset: 0,\n        length: data.byteLength,\n      }];\n    }\n  }\n\n  async fetchSlice(slice, signal) {\n    const { offset, length } = slice;\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${offset}-${offset + length}`,\n      },\n      signal,\n    });\n\n    // check the response was okay and if the server actually understands range requests\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const data = await response.getData();\n\n      const { total } = (0,_httputils_js__WEBPACK_IMPORTED_MODULE_1__.parseContentRange)(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      return {\n        data,\n        offset,\n        length,\n      };\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n\n      const data = await response.getData();\n\n      this._fileSize = data.byteLength;\n      return {\n        data,\n        offset: 0,\n        length: data.byteLength,\n      };\n    }\n  }\n\n  get fileSize() {\n    return this._fileSize;\n  }\n}\n\nfunction maybeWrapInBlockedSource(source, { blockSize, cacheSize }) {\n  if (blockSize === null) {\n    return source;\n  }\n  return new _blockedsource_js__WEBPACK_IMPORTED_MODULE_2__.BlockedSource(source, { blockSize, cacheSize });\n}\n\nfunction makeFetchSource(url, { headers = {}, credentials, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new _client_fetch_js__WEBPACK_IMPORTED_MODULE_3__.FetchClient(url, credentials);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nfunction makeXHRSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new _client_xhr_js__WEBPACK_IMPORTED_MODULE_4__.XHRClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nfunction makeHttpSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new _client_http_js__WEBPACK_IMPORTED_MODULE_5__.HttpClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nfunction makeCustomSource(client, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\n/**\n *\n * @param {string} url\n * @param {object} options\n */\nfunction makeRemoteSource(url, { forceXHR = false, ...clientOptions } = {}) {\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n  return makeHttpSource(url, clientOptions);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvcmVtb3RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZXJyaWFqcy1tYXAvLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS9zb3VyY2UvcmVtb3RlLmpzPzNhYzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGFyc2VCeXRlUmFuZ2VzLCBwYXJzZUNvbnRlbnRSYW5nZSwgcGFyc2VDb250ZW50VHlwZSB9IGZyb20gJy4vaHR0cHV0aWxzLmpzJztcbmltcG9ydCB7IEJhc2VTb3VyY2UgfSBmcm9tICcuL2Jhc2Vzb3VyY2UuanMnO1xuaW1wb3J0IHsgQmxvY2tlZFNvdXJjZSB9IGZyb20gJy4vYmxvY2tlZHNvdXJjZS5qcyc7XG5cbmltcG9ydCB7IEZldGNoQ2xpZW50IH0gZnJvbSAnLi9jbGllbnQvZmV0Y2guanMnO1xuaW1wb3J0IHsgWEhSQ2xpZW50IH0gZnJvbSAnLi9jbGllbnQveGhyLmpzJztcbmltcG9ydCB7IEh0dHBDbGllbnQgfSBmcm9tICcuL2NsaWVudC9odHRwLmpzJztcblxuY2xhc3MgUmVtb3RlU291cmNlIGV4dGVuZHMgQmFzZVNvdXJjZSB7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0Jhc2VDbGllbnR9IGNsaWVudFxuICAgKiBAcGFyYW0ge29iamVjdH0gaGVhZGVyc1xuICAgKiBAcGFyYW0ge251bWJlcnN9IG1heFJhbmdlc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFsbG93RnVsbEZpbGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgaGVhZGVycywgbWF4UmFuZ2VzLCBhbGxvd0Z1bGxGaWxlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgIHRoaXMubWF4UmFuZ2VzID0gbWF4UmFuZ2VzO1xuICAgIHRoaXMuYWxsb3dGdWxsRmlsZSA9IGFsbG93RnVsbEZpbGU7XG4gICAgdGhpcy5fZmlsZVNpemUgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7U2xpY2VbXX0gc2xpY2VzXG4gICAqL1xuICBhc3luYyBmZXRjaChzbGljZXMsIHNpZ25hbCkge1xuICAgIC8vIGlmIHdlIGFsbG93IG11bHRpLXJhbmdlcywgc3BsaXQgdGhlIGluY29taW5nIHJlcXVlc3QgaW50byB0aGF0IG1hbnkgc3ViLXJlcXVlc3RzXG4gICAgLy8gYW5kIGpvaW4gdGhlbSBhZnRlcndhcmRzXG4gICAgaWYgKHRoaXMubWF4UmFuZ2VzID49IHNsaWNlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLmZldGNoU2xpY2VzKHNsaWNlcywgc2lnbmFsKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWF4UmFuZ2VzID4gMCAmJiBzbGljZXMubGVuZ3RoID4gMSkge1xuICAgICAgLy8gVE9ETzogc3BsaXQgaW50byBtdWx0aXBsZSBtdWx0aS1yYW5nZSByZXF1ZXN0c1xuXG4gICAgICAvLyBjb25zdCBzdWJTbGljZXNSZXF1ZXN0cyA9IFtdO1xuICAgICAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBzbGljZXMubGVuZ3RoOyBpICs9IHRoaXMubWF4UmFuZ2VzKSB7XG4gICAgICAvLyAgIHN1YlNsaWNlc1JlcXVlc3RzLnB1c2goXG4gICAgICAvLyAgICAgdGhpcy5mZXRjaFNsaWNlcyhzbGljZXMuc2xpY2UoaSwgaSArIHRoaXMubWF4UmFuZ2VzKSwgc2lnbmFsKSxcbiAgICAgIC8vICAgKTtcbiAgICAgIC8vIH1cbiAgICAgIC8vIHJldHVybiAoYXdhaXQgUHJvbWlzZS5hbGwoc3ViU2xpY2VzUmVxdWVzdHMpKS5mbGF0KCk7XG4gICAgfVxuXG4gICAgLy8gb3RoZXJ3aXNlIG1ha2UgYSBzaW5nbGUgcmVxdWVzdCBmb3IgZWFjaCBzbGljZVxuICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgIHNsaWNlcy5tYXAoKHNsaWNlKSA9PiB0aGlzLmZldGNoU2xpY2Uoc2xpY2UsIHNpZ25hbCkpLFxuICAgICk7XG4gIH1cblxuICBhc3luYyBmZXRjaFNsaWNlcyhzbGljZXMsIHNpZ25hbCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jbGllbnQucmVxdWVzdCh7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC4uLnRoaXMuaGVhZGVycyxcbiAgICAgICAgUmFuZ2U6IGBieXRlcz0ke3NsaWNlc1xuICAgICAgICAgIC5tYXAoKHsgb2Zmc2V0LCBsZW5ndGggfSkgPT4gYCR7b2Zmc2V0fS0ke29mZnNldCArIGxlbmd0aH1gKVxuICAgICAgICAgIC5qb2luKCcsJylcbiAgICAgICAgfWAsXG4gICAgICB9LFxuICAgICAgc2lnbmFsLFxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBmZXRjaGluZyBkYXRhLicpO1xuICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDYpIHtcbiAgICAgIGNvbnN0IHsgdHlwZSwgcGFyYW1zIH0gPSBwYXJzZUNvbnRlbnRUeXBlKHJlc3BvbnNlLmdldEhlYWRlcignY29udGVudC10eXBlJykpO1xuICAgICAgaWYgKHR5cGUgPT09ICdtdWx0aXBhcnQvYnl0ZXJhbmdlcycpIHtcbiAgICAgICAgY29uc3QgYnl0ZVJhbmdlcyA9IHBhcnNlQnl0ZVJhbmdlcyhhd2FpdCByZXNwb25zZS5nZXREYXRhKCksIHBhcmFtcy5ib3VuZGFyeSk7XG4gICAgICAgIHRoaXMuX2ZpbGVTaXplID0gYnl0ZVJhbmdlc1swXS5maWxlU2l6ZSB8fCBudWxsO1xuICAgICAgICByZXR1cm4gYnl0ZVJhbmdlcztcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmdldERhdGEoKTtcblxuICAgICAgY29uc3QgeyBzdGFydCwgZW5kLCB0b3RhbCB9ID0gcGFyc2VDb250ZW50UmFuZ2UocmVzcG9uc2UuZ2V0SGVhZGVyKCdjb250ZW50LXJhbmdlJykpO1xuICAgICAgdGhpcy5fZmlsZVNpemUgPSB0b3RhbCB8fCBudWxsO1xuICAgICAgY29uc3QgZmlyc3QgPSBbe1xuICAgICAgICBkYXRhLFxuICAgICAgICBvZmZzZXQ6IHN0YXJ0LFxuICAgICAgICBsZW5ndGg6IGVuZCAtIHN0YXJ0LFxuICAgICAgfV07XG5cbiAgICAgIGlmIChzbGljZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyB3ZSByZXF1ZXN0ZWQgbW9yZSB0aGFuIG9uZSBzbGljZSwgYnV0IGdvdCBvbmx5IHRoZSBmaXJzdFxuICAgICAgICAvLyB1bmZvcnR1bmF0ZWx5LCBzb21lIEhUVFAgU2VydmVycyBkb24ndCBzdXBwb3J0IG11bHRpLXJhbmdlc1xuICAgICAgICAvLyBhbmQgcmV0dXJuIG9ubHkgdGhlIGZpcnN0XG5cbiAgICAgICAgLy8gZ2V0IHRoZSByZXN0IG9mIHRoZSBzbGljZXMgYW5kIGZldGNoIHRoZW0gaXRlcmF0aXZlbHlcbiAgICAgICAgY29uc3Qgb3RoZXJzID0gYXdhaXQgUHJvbWlzZS5hbGwoc2xpY2VzLnNsaWNlKDEpLm1hcCgoc2xpY2UpID0+IHRoaXMuZmV0Y2hTbGljZShzbGljZSwgc2lnbmFsKSkpO1xuICAgICAgICByZXR1cm4gZmlyc3QuY29uY2F0KG90aGVycyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmlyc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy5hbGxvd0Z1bGxGaWxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2VydmVyIHJlc3BvbmRlZCB3aXRoIGZ1bGwgZmlsZScpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmdldERhdGEoKTtcbiAgICAgIHRoaXMuX2ZpbGVTaXplID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgbGVuZ3RoOiBkYXRhLmJ5dGVMZW5ndGgsXG4gICAgICB9XTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBmZXRjaFNsaWNlKHNsaWNlLCBzaWduYWwpIHtcbiAgICBjb25zdCB7IG9mZnNldCwgbGVuZ3RoIH0gPSBzbGljZTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2xpZW50LnJlcXVlc3Qoe1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICAuLi50aGlzLmhlYWRlcnMsXG4gICAgICAgIFJhbmdlOiBgYnl0ZXM9JHtvZmZzZXR9LSR7b2Zmc2V0ICsgbGVuZ3RofWAsXG4gICAgICB9LFxuICAgICAgc2lnbmFsLFxuICAgIH0pO1xuXG4gICAgLy8gY2hlY2sgdGhlIHJlc3BvbnNlIHdhcyBva2F5IGFuZCBpZiB0aGUgc2VydmVyIGFjdHVhbGx5IHVuZGVyc3RhbmRzIHJhbmdlIHJlcXVlc3RzXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBmZXRjaGluZyBkYXRhLicpO1xuICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDYpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5nZXREYXRhKCk7XG5cbiAgICAgIGNvbnN0IHsgdG90YWwgfSA9IHBhcnNlQ29udGVudFJhbmdlKHJlc3BvbnNlLmdldEhlYWRlcignY29udGVudC1yYW5nZScpKTtcbiAgICAgIHRoaXMuX2ZpbGVTaXplID0gdG90YWwgfHwgbnVsbDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgbGVuZ3RoLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLmFsbG93RnVsbEZpbGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJ2ZXIgcmVzcG9uZGVkIHdpdGggZnVsbCBmaWxlJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5nZXREYXRhKCk7XG5cbiAgICAgIHRoaXMuX2ZpbGVTaXplID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICBsZW5ndGg6IGRhdGEuYnl0ZUxlbmd0aCxcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgZ2V0IGZpbGVTaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlU2l6ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVdyYXBJbkJsb2NrZWRTb3VyY2Uoc291cmNlLCB7IGJsb2NrU2l6ZSwgY2FjaGVTaXplIH0pIHtcbiAgaWYgKGJsb2NrU2l6ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cbiAgcmV0dXJuIG5ldyBCbG9ja2VkU291cmNlKHNvdXJjZSwgeyBibG9ja1NpemUsIGNhY2hlU2l6ZSB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VGZXRjaFNvdXJjZSh1cmwsIHsgaGVhZGVycyA9IHt9LCBjcmVkZW50aWFscywgbWF4UmFuZ2VzID0gMCwgYWxsb3dGdWxsRmlsZSA9IGZhbHNlLCAuLi5ibG9ja09wdGlvbnMgfSA9IHt9KSB7XG4gIGNvbnN0IGNsaWVudCA9IG5ldyBGZXRjaENsaWVudCh1cmwsIGNyZWRlbnRpYWxzKTtcbiAgY29uc3Qgc291cmNlID0gbmV3IFJlbW90ZVNvdXJjZShjbGllbnQsIGhlYWRlcnMsIG1heFJhbmdlcywgYWxsb3dGdWxsRmlsZSk7XG4gIHJldHVybiBtYXliZVdyYXBJbkJsb2NrZWRTb3VyY2Uoc291cmNlLCBibG9ja09wdGlvbnMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZVhIUlNvdXJjZSh1cmwsIHsgaGVhZGVycyA9IHt9LCBtYXhSYW5nZXMgPSAwLCBhbGxvd0Z1bGxGaWxlID0gZmFsc2UsIC4uLmJsb2NrT3B0aW9ucyB9ID0ge30pIHtcbiAgY29uc3QgY2xpZW50ID0gbmV3IFhIUkNsaWVudCh1cmwpO1xuICBjb25zdCBzb3VyY2UgPSBuZXcgUmVtb3RlU291cmNlKGNsaWVudCwgaGVhZGVycywgbWF4UmFuZ2VzLCBhbGxvd0Z1bGxGaWxlKTtcbiAgcmV0dXJuIG1heWJlV3JhcEluQmxvY2tlZFNvdXJjZShzb3VyY2UsIGJsb2NrT3B0aW9ucyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlSHR0cFNvdXJjZSh1cmwsIHsgaGVhZGVycyA9IHt9LCBtYXhSYW5nZXMgPSAwLCBhbGxvd0Z1bGxGaWxlID0gZmFsc2UsIC4uLmJsb2NrT3B0aW9ucyB9ID0ge30pIHtcbiAgY29uc3QgY2xpZW50ID0gbmV3IEh0dHBDbGllbnQodXJsKTtcbiAgY29uc3Qgc291cmNlID0gbmV3IFJlbW90ZVNvdXJjZShjbGllbnQsIGhlYWRlcnMsIG1heFJhbmdlcywgYWxsb3dGdWxsRmlsZSk7XG4gIHJldHVybiBtYXliZVdyYXBJbkJsb2NrZWRTb3VyY2Uoc291cmNlLCBibG9ja09wdGlvbnMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZUN1c3RvbVNvdXJjZShjbGllbnQsIHsgaGVhZGVycyA9IHt9LCBtYXhSYW5nZXMgPSAwLCBhbGxvd0Z1bGxGaWxlID0gZmFsc2UsIC4uLmJsb2NrT3B0aW9ucyB9ID0ge30pIHtcbiAgY29uc3Qgc291cmNlID0gbmV3IFJlbW90ZVNvdXJjZShjbGllbnQsIGhlYWRlcnMsIG1heFJhbmdlcywgYWxsb3dGdWxsRmlsZSk7XG4gIHJldHVybiBtYXliZVdyYXBJbkJsb2NrZWRTb3VyY2Uoc291cmNlLCBibG9ja09wdGlvbnMpO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZVJlbW90ZVNvdXJjZSh1cmwsIHsgZm9yY2VYSFIgPSBmYWxzZSwgLi4uY2xpZW50T3B0aW9ucyB9ID0ge30pIHtcbiAgaWYgKHR5cGVvZiBmZXRjaCA9PT0gJ2Z1bmN0aW9uJyAmJiAhZm9yY2VYSFIpIHtcbiAgICByZXR1cm4gbWFrZUZldGNoU291cmNlKHVybCwgY2xpZW50T3B0aW9ucyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbWFrZVhIUlNvdXJjZSh1cmwsIGNsaWVudE9wdGlvbnMpO1xuICB9XG4gIHJldHVybiBtYWtlSHR0cFNvdXJjZSh1cmwsIGNsaWVudE9wdGlvbnMpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/source/remote.js\n");

/***/ }),

/***/ "./node_modules/geotiff/dist-module/utils.js":
/*!***************************************************!*\
  !*** ./node_modules/geotiff/dist-module/utils.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortError: () => (/* binding */ AbortError),\n/* harmony export */   AggregateError: () => (/* binding */ AggregateError),\n/* harmony export */   CustomAggregateError: () => (/* binding */ CustomAggregateError),\n/* harmony export */   assign: () => (/* binding */ assign),\n/* harmony export */   chunk: () => (/* binding */ chunk),\n/* harmony export */   endsWith: () => (/* binding */ endsWith),\n/* harmony export */   forEach: () => (/* binding */ forEach),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   parseContentRange: () => (/* binding */ parseContentRange),\n/* harmony export */   range: () => (/* binding */ range),\n/* harmony export */   times: () => (/* binding */ times),\n/* harmony export */   toArray: () => (/* binding */ toArray),\n/* harmony export */   toArrayRecursively: () => (/* binding */ toArrayRecursively),\n/* harmony export */   wait: () => (/* binding */ wait),\n/* harmony export */   zip: () => (/* binding */ zip)\n/* harmony export */ });\nfunction assign(target, source) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\n\nfunction chunk(iterable, length) {\n  const results = [];\n  const lengthOfIterable = iterable.length;\n  for (let i = 0; i < lengthOfIterable; i += length) {\n    const chunked = [];\n    for (let ci = i; ci < i + length; ci++) {\n      chunked.push(iterable[ci]);\n    }\n    results.push(chunked);\n  }\n  return results;\n}\n\nfunction endsWith(string, expectedEnding) {\n  if (string.length < expectedEnding.length) {\n    return false;\n  }\n  const actualEnding = string.substr(string.length - expectedEnding.length);\n  return actualEnding === expectedEnding;\n}\n\nfunction forEach(iterable, func) {\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    func(iterable[i], i);\n  }\n}\n\nfunction invert(oldObj) {\n  const newObj = {};\n  for (const key in oldObj) {\n    if (oldObj.hasOwnProperty(key)) {\n      const value = oldObj[key];\n      newObj[value] = key;\n    }\n  }\n  return newObj;\n}\n\nfunction range(n) {\n  const results = [];\n  for (let i = 0; i < n; i++) {\n    results.push(i);\n  }\n  return results;\n}\n\nfunction times(numTimes, func) {\n  const results = [];\n  for (let i = 0; i < numTimes; i++) {\n    results.push(func(i));\n  }\n  return results;\n}\n\nfunction toArray(iterable) {\n  const results = [];\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    results.push(iterable[i]);\n  }\n  return results;\n}\n\nfunction toArrayRecursively(input) {\n  if (input.length) {\n    return toArray(input).map(toArrayRecursively);\n  }\n  return input;\n}\n\n// copied from https://github.com/academia-de-codigo/parse-content-range-header/blob/master/index.js\nfunction parseContentRange(headerValue) {\n  if (!headerValue) {\n    return null;\n  }\n\n  if (typeof headerValue !== 'string') {\n    throw new Error('invalid argument');\n  }\n\n  const parseInt = (number) => Number.parseInt(number, 10);\n\n  // Check for presence of unit\n  let matches = headerValue.match(/^(\\w*) /);\n  const unit = matches && matches[1];\n\n  // check for start-end/size header format\n  matches = headerValue.match(/(\\d+)-(\\d+)\\/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: parseInt(matches[1]),\n      last: parseInt(matches[2]),\n      length: matches[3] === '*' ? null : parseInt(matches[3]),\n    };\n  }\n\n  // check for size header format\n  matches = headerValue.match(/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: null,\n      last: null,\n      length: matches[1] === '*' ? null : parseInt(matches[1]),\n    };\n  }\n\n  return null;\n}\n\n/*\n * Promisified wrapper around 'setTimeout' to allow 'await'\n */\nasync function wait(milliseconds) {\n  return new Promise((resolve) => setTimeout(resolve, milliseconds));\n}\n\nfunction zip(a, b) {\n  const A = Array.isArray(a) ? a : Array.from(a);\n  const B = Array.isArray(b) ? b : Array.from(b);\n  return A.map((k, i) => [k, B[i]]);\n}\n\n// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\nclass AbortError extends Error {\n  constructor(params) {\n    // Pass remaining arguments (including vendor specific ones) to parent constructor\n    super(params);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AbortError);\n    }\n\n    this.name = 'AbortError';\n  }\n}\n\nclass CustomAggregateError extends Error {\n  constructor(errors, message) {\n    super(message);\n    this.errors = errors;\n    this.message = message;\n    this.name = 'AggregateError';\n  }\n}\n\nconst AggregateError = CustomAggregateError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2VvdGlmZi9kaXN0LW1vZHVsZS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVycmlhanMtbWFwLy4vbm9kZV9tb2R1bGVzL2dlb3RpZmYvZGlzdC1tb2R1bGUvdXRpbHMuanM/Zjg3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNodW5rKGl0ZXJhYmxlLCBsZW5ndGgpIHtcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICBjb25zdCBsZW5ndGhPZkl0ZXJhYmxlID0gaXRlcmFibGUubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aE9mSXRlcmFibGU7IGkgKz0gbGVuZ3RoKSB7XG4gICAgY29uc3QgY2h1bmtlZCA9IFtdO1xuICAgIGZvciAobGV0IGNpID0gaTsgY2kgPCBpICsgbGVuZ3RoOyBjaSsrKSB7XG4gICAgICBjaHVua2VkLnB1c2goaXRlcmFibGVbY2ldKTtcbiAgICB9XG4gICAgcmVzdWx0cy5wdXNoKGNodW5rZWQpO1xuICB9XG4gIHJldHVybiByZXN1bHRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5kc1dpdGgoc3RyaW5nLCBleHBlY3RlZEVuZGluZykge1xuICBpZiAoc3RyaW5nLmxlbmd0aCA8IGV4cGVjdGVkRW5kaW5nLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBhY3R1YWxFbmRpbmcgPSBzdHJpbmcuc3Vic3RyKHN0cmluZy5sZW5ndGggLSBleHBlY3RlZEVuZGluZy5sZW5ndGgpO1xuICByZXR1cm4gYWN0dWFsRW5kaW5nID09PSBleHBlY3RlZEVuZGluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvckVhY2goaXRlcmFibGUsIGZ1bmMpIHtcbiAgY29uc3QgeyBsZW5ndGggfSA9IGl0ZXJhYmxlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgZnVuYyhpdGVyYWJsZVtpXSwgaSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGludmVydChvbGRPYmopIHtcbiAgY29uc3QgbmV3T2JqID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIG9sZE9iaikge1xuICAgIGlmIChvbGRPYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBvbGRPYmpba2V5XTtcbiAgICAgIG5ld09ialt2YWx1ZV0gPSBrZXk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdPYmo7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByYW5nZShuKSB7XG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICByZXN1bHRzLnB1c2goaSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aW1lcyhudW1UaW1lcywgZnVuYykge1xuICBjb25zdCByZXN1bHRzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVGltZXM7IGkrKykge1xuICAgIHJlc3VsdHMucHVzaChmdW5jKGkpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvQXJyYXkoaXRlcmFibGUpIHtcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICBjb25zdCB7IGxlbmd0aCB9ID0gaXRlcmFibGU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHRzLnB1c2goaXRlcmFibGVbaV0pO1xuICB9XG4gIHJldHVybiByZXN1bHRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9BcnJheVJlY3Vyc2l2ZWx5KGlucHV0KSB7XG4gIGlmIChpbnB1dC5sZW5ndGgpIHtcbiAgICByZXR1cm4gdG9BcnJheShpbnB1dCkubWFwKHRvQXJyYXlSZWN1cnNpdmVseSk7XG4gIH1cbiAgcmV0dXJuIGlucHV0O1xufVxuXG4vLyBjb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYWNhZGVtaWEtZGUtY29kaWdvL3BhcnNlLWNvbnRlbnQtcmFuZ2UtaGVhZGVyL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VDb250ZW50UmFuZ2UoaGVhZGVyVmFsdWUpIHtcbiAgaWYgKCFoZWFkZXJWYWx1ZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBoZWFkZXJWYWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXJndW1lbnQnKTtcbiAgfVxuXG4gIGNvbnN0IHBhcnNlSW50ID0gKG51bWJlcikgPT4gTnVtYmVyLnBhcnNlSW50KG51bWJlciwgMTApO1xuXG4gIC8vIENoZWNrIGZvciBwcmVzZW5jZSBvZiB1bml0XG4gIGxldCBtYXRjaGVzID0gaGVhZGVyVmFsdWUubWF0Y2goL14oXFx3KikgLyk7XG4gIGNvbnN0IHVuaXQgPSBtYXRjaGVzICYmIG1hdGNoZXNbMV07XG5cbiAgLy8gY2hlY2sgZm9yIHN0YXJ0LWVuZC9zaXplIGhlYWRlciBmb3JtYXRcbiAgbWF0Y2hlcyA9IGhlYWRlclZhbHVlLm1hdGNoKC8oXFxkKyktKFxcZCspXFwvKFxcZCt8XFwqKS8pO1xuICBpZiAobWF0Y2hlcykge1xuICAgIHJldHVybiB7XG4gICAgICB1bml0LFxuICAgICAgZmlyc3Q6IHBhcnNlSW50KG1hdGNoZXNbMV0pLFxuICAgICAgbGFzdDogcGFyc2VJbnQobWF0Y2hlc1syXSksXG4gICAgICBsZW5ndGg6IG1hdGNoZXNbM10gPT09ICcqJyA/IG51bGwgOiBwYXJzZUludChtYXRjaGVzWzNdKSxcbiAgICB9O1xuICB9XG5cbiAgLy8gY2hlY2sgZm9yIHNpemUgaGVhZGVyIGZvcm1hdFxuICBtYXRjaGVzID0gaGVhZGVyVmFsdWUubWF0Y2goLyhcXGQrfFxcKikvKTtcbiAgaWYgKG1hdGNoZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdW5pdCxcbiAgICAgIGZpcnN0OiBudWxsLFxuICAgICAgbGFzdDogbnVsbCxcbiAgICAgIGxlbmd0aDogbWF0Y2hlc1sxXSA9PT0gJyonID8gbnVsbCA6IHBhcnNlSW50KG1hdGNoZXNbMV0pLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLypcbiAqIFByb21pc2lmaWVkIHdyYXBwZXIgYXJvdW5kICdzZXRUaW1lb3V0JyB0byBhbGxvdyAnYXdhaXQnXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3YWl0KG1pbGxpc2Vjb25kcykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbWlsbGlzZWNvbmRzKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB6aXAoYSwgYikge1xuICBjb25zdCBBID0gQXJyYXkuaXNBcnJheShhKSA/IGEgOiBBcnJheS5mcm9tKGEpO1xuICBjb25zdCBCID0gQXJyYXkuaXNBcnJheShiKSA/IGIgOiBBcnJheS5mcm9tKGIpO1xuICByZXR1cm4gQS5tYXAoKGssIGkpID0+IFtrLCBCW2ldXSk7XG59XG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Vycm9yXG5leHBvcnQgY2xhc3MgQWJvcnRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgLy8gUGFzcyByZW1haW5pbmcgYXJndW1lbnRzIChpbmNsdWRpbmcgdmVuZG9yIHNwZWNpZmljIG9uZXMpIHRvIHBhcmVudCBjb25zdHJ1Y3RvclxuICAgIHN1cGVyKHBhcmFtcyk7XG5cbiAgICAvLyBNYWludGFpbnMgcHJvcGVyIHN0YWNrIHRyYWNlIGZvciB3aGVyZSBvdXIgZXJyb3Igd2FzIHRocm93biAob25seSBhdmFpbGFibGUgb24gVjgpXG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBBYm9ydEVycm9yKTtcbiAgICB9XG5cbiAgICB0aGlzLm5hbWUgPSAnQWJvcnRFcnJvcic7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEN1c3RvbUFnZ3JlZ2F0ZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihlcnJvcnMsIG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMubmFtZSA9ICdBZ2dyZWdhdGVFcnJvcic7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IEFnZ3JlZ2F0ZUVycm9yID0gQ3VzdG9tQWdncmVnYXRlRXJyb3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/geotiff/dist-module/utils.js\n");

/***/ }),

/***/ "./node_modules/quick-lru/index.js":
/*!*****************************************!*\
  !*** ./node_modules/quick-lru/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ QuickLRU)\n/* harmony export */ });\nclass QuickLRU extends Map {\n\tconstructor(options = {}) {\n\t\tsuper();\n\n\t\tif (!(options.maxSize && options.maxSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tif (typeof options.maxAge === 'number' && options.maxAge === 0) {\n\t\t\tthrow new TypeError('`maxAge` must be a number greater than 0');\n\t\t}\n\n\t\t// TODO: Use private class fields when ESLint supports them.\n\t\tthis.maxSize = options.maxSize;\n\t\tthis.maxAge = options.maxAge || Number.POSITIVE_INFINITY;\n\t\tthis.onEviction = options.onEviction;\n\t\tthis.cache = new Map();\n\t\tthis.oldCache = new Map();\n\t\tthis._size = 0;\n\t}\n\n\t// TODO: Use private class methods when targeting Node.js 16.\n\t_emitEvictions(cache) {\n\t\tif (typeof this.onEviction !== 'function') {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const [key, item] of cache) {\n\t\t\tthis.onEviction(key, item.value);\n\t\t}\n\t}\n\n\t_deleteIfExpired(key, item) {\n\t\tif (typeof item.expiry === 'number' && item.expiry <= Date.now()) {\n\t\t\tif (typeof this.onEviction === 'function') {\n\t\t\t\tthis.onEviction(key, item.value);\n\t\t\t}\n\n\t\t\treturn this.delete(key);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t_getOrDeleteIfExpired(key, item) {\n\t\tconst deleted = this._deleteIfExpired(key, item);\n\t\tif (deleted === false) {\n\t\t\treturn item.value;\n\t\t}\n\t}\n\n\t_getItemValue(key, item) {\n\t\treturn item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;\n\t}\n\n\t_peek(key, cache) {\n\t\tconst item = cache.get(key);\n\n\t\treturn this._getItemValue(key, item);\n\t}\n\n\t_set(key, value) {\n\t\tthis.cache.set(key, value);\n\t\tthis._size++;\n\n\t\tif (this._size >= this.maxSize) {\n\t\t\tthis._size = 0;\n\t\t\tthis._emitEvictions(this.oldCache);\n\t\t\tthis.oldCache = this.cache;\n\t\t\tthis.cache = new Map();\n\t\t}\n\t}\n\n\t_moveToRecent(key, item) {\n\t\tthis.oldCache.delete(key);\n\t\tthis._set(key, item);\n\t}\n\n\t* _entriesAscending() {\n\t\tfor (const item of this.oldCache) {\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield item;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const item of this.cache) {\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t}\n\t}\n\n\tget(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\tconst item = this.cache.get(key);\n\n\t\t\treturn this._getItemValue(key, item);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\tconst item = this.oldCache.get(key);\n\t\t\tif (this._deleteIfExpired(key, item) === false) {\n\t\t\t\tthis._moveToRecent(key, item);\n\t\t\t\treturn item.value;\n\t\t\t}\n\t\t}\n\t}\n\n\tset(key, value, {maxAge = this.maxAge} = {}) {\n\t\tconst expiry =\n\t\t\ttypeof maxAge === 'number' && maxAge !== Number.POSITIVE_INFINITY ?\n\t\t\t\tDate.now() + maxAge :\n\t\t\t\tundefined;\n\t\tif (this.cache.has(key)) {\n\t\t\tthis.cache.set(key, {\n\t\t\t\tvalue,\n\t\t\t\texpiry\n\t\t\t});\n\t\t} else {\n\t\t\tthis._set(key, {value, expiry});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\thas(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn !this._deleteIfExpired(key, this.cache.get(key));\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\treturn !this._deleteIfExpired(key, this.oldCache.get(key));\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpeek(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn this._peek(key, this.cache);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\treturn this._peek(key, this.oldCache);\n\t\t}\n\t}\n\n\tdelete(key) {\n\t\tconst deleted = this.cache.delete(key);\n\t\tif (deleted) {\n\t\t\tthis._size--;\n\t\t}\n\n\t\treturn this.oldCache.delete(key) || deleted;\n\t}\n\n\tclear() {\n\t\tthis.cache.clear();\n\t\tthis.oldCache.clear();\n\t\tthis._size = 0;\n\t}\n\n\tresize(newSize) {\n\t\tif (!(newSize && newSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tconst items = [...this._entriesAscending()];\n\t\tconst removeCount = items.length - newSize;\n\t\tif (removeCount < 0) {\n\t\t\tthis.cache = new Map(items);\n\t\t\tthis.oldCache = new Map();\n\t\t\tthis._size = items.length;\n\t\t} else {\n\t\t\tif (removeCount > 0) {\n\t\t\t\tthis._emitEvictions(items.slice(0, removeCount));\n\t\t\t}\n\n\t\t\tthis.oldCache = new Map(items.slice(removeCount));\n\t\t\tthis.cache = new Map();\n\t\t\tthis._size = 0;\n\t\t}\n\n\t\tthis.maxSize = newSize;\n\t}\n\n\t* keys() {\n\t\tfor (const [key] of this) {\n\t\t\tyield key;\n\t\t}\n\t}\n\n\t* values() {\n\t\tfor (const [, value] of this) {\n\t\t\tyield value;\n\t\t}\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tfor (const item of this.cache) {\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield [key, value.value];\n\t\t\t}\n\t\t}\n\n\t\tfor (const item of this.oldCache) {\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield [key, value.value];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t* entriesDescending() {\n\t\tlet items = [...this.cache];\n\t\tfor (let i = items.length - 1; i >= 0; --i) {\n\t\t\tconst item = items[i];\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield [key, value.value];\n\t\t\t}\n\t\t}\n\n\t\titems = [...this.oldCache];\n\t\tfor (let i = items.length - 1; i >= 0; --i) {\n\t\t\tconst item = items[i];\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield [key, value.value];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t* entriesAscending() {\n\t\tfor (const [key, value] of this._entriesAscending()) {\n\t\t\tyield [key, value.value];\n\t\t}\n\t}\n\n\tget size() {\n\t\tif (!this._size) {\n\t\t\treturn this.oldCache.size;\n\t\t}\n\n\t\tlet oldCacheSize = 0;\n\t\tfor (const key of this.oldCache.keys()) {\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\toldCacheSize++;\n\t\t\t}\n\t\t}\n\n\t\treturn Math.min(this._size + oldCacheSize, this.maxSize);\n\t}\n\n\tentries() {\n\t\treturn this.entriesAscending();\n\t}\n\n\tforEach(callbackFunction, thisArgument = this) {\n\t\tfor (const [key, value] of this.entriesAscending()) {\n\t\t\tcallbackFunction.call(thisArgument, value, key, this);\n\t\t}\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn JSON.stringify([...this.entriesAscending()]);\n\t}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcXVpY2stbHJ1L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlcnJpYWpzLW1hcC8uL25vZGVfbW9kdWxlcy9xdWljay1scnUvaW5kZXguanM/NDMzMyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBjbGFzcyBRdWlja0xSVSBleHRlbmRzIE1hcCB7XG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuXHRcdHN1cGVyKCk7XG5cblx0XHRpZiAoIShvcHRpb25zLm1heFNpemUgJiYgb3B0aW9ucy5tYXhTaXplID4gMCkpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ2BtYXhTaXplYCBtdXN0IGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAwJyk7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiBvcHRpb25zLm1heEFnZSA9PT0gJ251bWJlcicgJiYgb3B0aW9ucy5tYXhBZ2UgPT09IDApIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ2BtYXhBZ2VgIG11c3QgYmUgYSBudW1iZXIgZ3JlYXRlciB0aGFuIDAnKTtcblx0XHR9XG5cblx0XHQvLyBUT0RPOiBVc2UgcHJpdmF0ZSBjbGFzcyBmaWVsZHMgd2hlbiBFU0xpbnQgc3VwcG9ydHMgdGhlbS5cblx0XHR0aGlzLm1heFNpemUgPSBvcHRpb25zLm1heFNpemU7XG5cdFx0dGhpcy5tYXhBZ2UgPSBvcHRpb25zLm1heEFnZSB8fCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cdFx0dGhpcy5vbkV2aWN0aW9uID0gb3B0aW9ucy5vbkV2aWN0aW9uO1xuXHRcdHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7XG5cdFx0dGhpcy5vbGRDYWNoZSA9IG5ldyBNYXAoKTtcblx0XHR0aGlzLl9zaXplID0gMDtcblx0fVxuXG5cdC8vIFRPRE86IFVzZSBwcml2YXRlIGNsYXNzIG1ldGhvZHMgd2hlbiB0YXJnZXRpbmcgTm9kZS5qcyAxNi5cblx0X2VtaXRFdmljdGlvbnMoY2FjaGUpIHtcblx0XHRpZiAodHlwZW9mIHRoaXMub25FdmljdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGZvciAoY29uc3QgW2tleSwgaXRlbV0gb2YgY2FjaGUpIHtcblx0XHRcdHRoaXMub25FdmljdGlvbihrZXksIGl0ZW0udmFsdWUpO1xuXHRcdH1cblx0fVxuXG5cdF9kZWxldGVJZkV4cGlyZWQoa2V5LCBpdGVtKSB7XG5cdFx0aWYgKHR5cGVvZiBpdGVtLmV4cGlyeSA9PT0gJ251bWJlcicgJiYgaXRlbS5leHBpcnkgPD0gRGF0ZS5ub3coKSkge1xuXHRcdFx0aWYgKHR5cGVvZiB0aGlzLm9uRXZpY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0dGhpcy5vbkV2aWN0aW9uKGtleSwgaXRlbS52YWx1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLmRlbGV0ZShrZXkpO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdF9nZXRPckRlbGV0ZUlmRXhwaXJlZChrZXksIGl0ZW0pIHtcblx0XHRjb25zdCBkZWxldGVkID0gdGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgaXRlbSk7XG5cdFx0aWYgKGRlbGV0ZWQgPT09IGZhbHNlKSB7XG5cdFx0XHRyZXR1cm4gaXRlbS52YWx1ZTtcblx0XHR9XG5cdH1cblxuXHRfZ2V0SXRlbVZhbHVlKGtleSwgaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLmV4cGlyeSA/IHRoaXMuX2dldE9yRGVsZXRlSWZFeHBpcmVkKGtleSwgaXRlbSkgOiBpdGVtLnZhbHVlO1xuXHR9XG5cblx0X3BlZWsoa2V5LCBjYWNoZSkge1xuXHRcdGNvbnN0IGl0ZW0gPSBjYWNoZS5nZXQoa2V5KTtcblxuXHRcdHJldHVybiB0aGlzLl9nZXRJdGVtVmFsdWUoa2V5LCBpdGVtKTtcblx0fVxuXG5cdF9zZXQoa2V5LCB2YWx1ZSkge1xuXHRcdHRoaXMuY2FjaGUuc2V0KGtleSwgdmFsdWUpO1xuXHRcdHRoaXMuX3NpemUrKztcblxuXHRcdGlmICh0aGlzLl9zaXplID49IHRoaXMubWF4U2l6ZSkge1xuXHRcdFx0dGhpcy5fc2l6ZSA9IDA7XG5cdFx0XHR0aGlzLl9lbWl0RXZpY3Rpb25zKHRoaXMub2xkQ2FjaGUpO1xuXHRcdFx0dGhpcy5vbGRDYWNoZSA9IHRoaXMuY2FjaGU7XG5cdFx0XHR0aGlzLmNhY2hlID0gbmV3IE1hcCgpO1xuXHRcdH1cblx0fVxuXG5cdF9tb3ZlVG9SZWNlbnQoa2V5LCBpdGVtKSB7XG5cdFx0dGhpcy5vbGRDYWNoZS5kZWxldGUoa2V5KTtcblx0XHR0aGlzLl9zZXQoa2V5LCBpdGVtKTtcblx0fVxuXG5cdCogX2VudHJpZXNBc2NlbmRpbmcoKSB7XG5cdFx0Zm9yIChjb25zdCBpdGVtIG9mIHRoaXMub2xkQ2FjaGUpIHtcblx0XHRcdGNvbnN0IFtrZXksIHZhbHVlXSA9IGl0ZW07XG5cdFx0XHRpZiAoIXRoaXMuY2FjaGUuaGFzKGtleSkpIHtcblx0XHRcdFx0Y29uc3QgZGVsZXRlZCA9IHRoaXMuX2RlbGV0ZUlmRXhwaXJlZChrZXksIHZhbHVlKTtcblx0XHRcdFx0aWYgKGRlbGV0ZWQgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0eWllbGQgaXRlbTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLmNhY2hlKSB7XG5cdFx0XHRjb25zdCBba2V5LCB2YWx1ZV0gPSBpdGVtO1xuXHRcdFx0Y29uc3QgZGVsZXRlZCA9IHRoaXMuX2RlbGV0ZUlmRXhwaXJlZChrZXksIHZhbHVlKTtcblx0XHRcdGlmIChkZWxldGVkID09PSBmYWxzZSkge1xuXHRcdFx0XHR5aWVsZCBpdGVtO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGdldChrZXkpIHtcblx0XHRpZiAodGhpcy5jYWNoZS5oYXMoa2V5KSkge1xuXHRcdFx0Y29uc3QgaXRlbSA9IHRoaXMuY2FjaGUuZ2V0KGtleSk7XG5cblx0XHRcdHJldHVybiB0aGlzLl9nZXRJdGVtVmFsdWUoa2V5LCBpdGVtKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vbGRDYWNoZS5oYXMoa2V5KSkge1xuXHRcdFx0Y29uc3QgaXRlbSA9IHRoaXMub2xkQ2FjaGUuZ2V0KGtleSk7XG5cdFx0XHRpZiAodGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgaXRlbSkgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHRoaXMuX21vdmVUb1JlY2VudChrZXksIGl0ZW0pO1xuXHRcdFx0XHRyZXR1cm4gaXRlbS52YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRzZXQoa2V5LCB2YWx1ZSwge21heEFnZSA9IHRoaXMubWF4QWdlfSA9IHt9KSB7XG5cdFx0Y29uc3QgZXhwaXJ5ID1cblx0XHRcdHR5cGVvZiBtYXhBZ2UgPT09ICdudW1iZXInICYmIG1heEFnZSAhPT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZID9cblx0XHRcdFx0RGF0ZS5ub3coKSArIG1heEFnZSA6XG5cdFx0XHRcdHVuZGVmaW5lZDtcblx0XHRpZiAodGhpcy5jYWNoZS5oYXMoa2V5KSkge1xuXHRcdFx0dGhpcy5jYWNoZS5zZXQoa2V5LCB7XG5cdFx0XHRcdHZhbHVlLFxuXHRcdFx0XHRleHBpcnlcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9zZXQoa2V5LCB7dmFsdWUsIGV4cGlyeX0pO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0aGFzKGtleSkge1xuXHRcdGlmICh0aGlzLmNhY2hlLmhhcyhrZXkpKSB7XG5cdFx0XHRyZXR1cm4gIXRoaXMuX2RlbGV0ZUlmRXhwaXJlZChrZXksIHRoaXMuY2FjaGUuZ2V0KGtleSkpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9sZENhY2hlLmhhcyhrZXkpKSB7XG5cdFx0XHRyZXR1cm4gIXRoaXMuX2RlbGV0ZUlmRXhwaXJlZChrZXksIHRoaXMub2xkQ2FjaGUuZ2V0KGtleSkpO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHBlZWsoa2V5KSB7XG5cdFx0aWYgKHRoaXMuY2FjaGUuaGFzKGtleSkpIHtcblx0XHRcdHJldHVybiB0aGlzLl9wZWVrKGtleSwgdGhpcy5jYWNoZSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMub2xkQ2FjaGUuaGFzKGtleSkpIHtcblx0XHRcdHJldHVybiB0aGlzLl9wZWVrKGtleSwgdGhpcy5vbGRDYWNoZSk7XG5cdFx0fVxuXHR9XG5cblx0ZGVsZXRlKGtleSkge1xuXHRcdGNvbnN0IGRlbGV0ZWQgPSB0aGlzLmNhY2hlLmRlbGV0ZShrZXkpO1xuXHRcdGlmIChkZWxldGVkKSB7XG5cdFx0XHR0aGlzLl9zaXplLS07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMub2xkQ2FjaGUuZGVsZXRlKGtleSkgfHwgZGVsZXRlZDtcblx0fVxuXG5cdGNsZWFyKCkge1xuXHRcdHRoaXMuY2FjaGUuY2xlYXIoKTtcblx0XHR0aGlzLm9sZENhY2hlLmNsZWFyKCk7XG5cdFx0dGhpcy5fc2l6ZSA9IDA7XG5cdH1cblxuXHRyZXNpemUobmV3U2l6ZSkge1xuXHRcdGlmICghKG5ld1NpemUgJiYgbmV3U2l6ZSA+IDApKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdgbWF4U2l6ZWAgbXVzdCBiZSBhIG51bWJlciBncmVhdGVyIHRoYW4gMCcpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGl0ZW1zID0gWy4uLnRoaXMuX2VudHJpZXNBc2NlbmRpbmcoKV07XG5cdFx0Y29uc3QgcmVtb3ZlQ291bnQgPSBpdGVtcy5sZW5ndGggLSBuZXdTaXplO1xuXHRcdGlmIChyZW1vdmVDb3VudCA8IDApIHtcblx0XHRcdHRoaXMuY2FjaGUgPSBuZXcgTWFwKGl0ZW1zKTtcblx0XHRcdHRoaXMub2xkQ2FjaGUgPSBuZXcgTWFwKCk7XG5cdFx0XHR0aGlzLl9zaXplID0gaXRlbXMubGVuZ3RoO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAocmVtb3ZlQ291bnQgPiAwKSB7XG5cdFx0XHRcdHRoaXMuX2VtaXRFdmljdGlvbnMoaXRlbXMuc2xpY2UoMCwgcmVtb3ZlQ291bnQpKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5vbGRDYWNoZSA9IG5ldyBNYXAoaXRlbXMuc2xpY2UocmVtb3ZlQ291bnQpKTtcblx0XHRcdHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7XG5cdFx0XHR0aGlzLl9zaXplID0gMDtcblx0XHR9XG5cblx0XHR0aGlzLm1heFNpemUgPSBuZXdTaXplO1xuXHR9XG5cblx0KiBrZXlzKCkge1xuXHRcdGZvciAoY29uc3QgW2tleV0gb2YgdGhpcykge1xuXHRcdFx0eWllbGQga2V5O1xuXHRcdH1cblx0fVxuXG5cdCogdmFsdWVzKCkge1xuXHRcdGZvciAoY29uc3QgWywgdmFsdWVdIG9mIHRoaXMpIHtcblx0XHRcdHlpZWxkIHZhbHVlO1xuXHRcdH1cblx0fVxuXG5cdCogW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG5cdFx0Zm9yIChjb25zdCBpdGVtIG9mIHRoaXMuY2FjaGUpIHtcblx0XHRcdGNvbnN0IFtrZXksIHZhbHVlXSA9IGl0ZW07XG5cdFx0XHRjb25zdCBkZWxldGVkID0gdGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgdmFsdWUpO1xuXHRcdFx0aWYgKGRlbGV0ZWQgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHlpZWxkIFtrZXksIHZhbHVlLnZhbHVlXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5vbGRDYWNoZSkge1xuXHRcdFx0Y29uc3QgW2tleSwgdmFsdWVdID0gaXRlbTtcblx0XHRcdGlmICghdGhpcy5jYWNoZS5oYXMoa2V5KSkge1xuXHRcdFx0XHRjb25zdCBkZWxldGVkID0gdGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgdmFsdWUpO1xuXHRcdFx0XHRpZiAoZGVsZXRlZCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHR5aWVsZCBba2V5LCB2YWx1ZS52YWx1ZV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQqIGVudHJpZXNEZXNjZW5kaW5nKCkge1xuXHRcdGxldCBpdGVtcyA9IFsuLi50aGlzLmNhY2hlXTtcblx0XHRmb3IgKGxldCBpID0gaXRlbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcblx0XHRcdGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcblx0XHRcdGNvbnN0IFtrZXksIHZhbHVlXSA9IGl0ZW07XG5cdFx0XHRjb25zdCBkZWxldGVkID0gdGhpcy5fZGVsZXRlSWZFeHBpcmVkKGtleSwgdmFsdWUpO1xuXHRcdFx0aWYgKGRlbGV0ZWQgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHlpZWxkIFtrZXksIHZhbHVlLnZhbHVlXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpdGVtcyA9IFsuLi50aGlzLm9sZENhY2hlXTtcblx0XHRmb3IgKGxldCBpID0gaXRlbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcblx0XHRcdGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcblx0XHRcdGNvbnN0IFtrZXksIHZhbHVlXSA9IGl0ZW07XG5cdFx0XHRpZiAoIXRoaXMuY2FjaGUuaGFzKGtleSkpIHtcblx0XHRcdFx0Y29uc3QgZGVsZXRlZCA9IHRoaXMuX2RlbGV0ZUlmRXhwaXJlZChrZXksIHZhbHVlKTtcblx0XHRcdFx0aWYgKGRlbGV0ZWQgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0eWllbGQgW2tleSwgdmFsdWUudmFsdWVdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0KiBlbnRyaWVzQXNjZW5kaW5nKCkge1xuXHRcdGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuX2VudHJpZXNBc2NlbmRpbmcoKSkge1xuXHRcdFx0eWllbGQgW2tleSwgdmFsdWUudmFsdWVdO1xuXHRcdH1cblx0fVxuXG5cdGdldCBzaXplKCkge1xuXHRcdGlmICghdGhpcy5fc2l6ZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMub2xkQ2FjaGUuc2l6ZTtcblx0XHR9XG5cblx0XHRsZXQgb2xkQ2FjaGVTaXplID0gMDtcblx0XHRmb3IgKGNvbnN0IGtleSBvZiB0aGlzLm9sZENhY2hlLmtleXMoKSkge1xuXHRcdFx0aWYgKCF0aGlzLmNhY2hlLmhhcyhrZXkpKSB7XG5cdFx0XHRcdG9sZENhY2hlU2l6ZSsrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBNYXRoLm1pbih0aGlzLl9zaXplICsgb2xkQ2FjaGVTaXplLCB0aGlzLm1heFNpemUpO1xuXHR9XG5cblx0ZW50cmllcygpIHtcblx0XHRyZXR1cm4gdGhpcy5lbnRyaWVzQXNjZW5kaW5nKCk7XG5cdH1cblxuXHRmb3JFYWNoKGNhbGxiYWNrRnVuY3Rpb24sIHRoaXNBcmd1bWVudCA9IHRoaXMpIHtcblx0XHRmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLmVudHJpZXNBc2NlbmRpbmcoKSkge1xuXHRcdFx0Y2FsbGJhY2tGdW5jdGlvbi5jYWxsKHRoaXNBcmd1bWVudCwgdmFsdWUsIGtleSwgdGhpcyk7XG5cdFx0fVxuXHR9XG5cblx0Z2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeShbLi4udGhpcy5lbnRyaWVzQXNjZW5kaW5nKCldKTtcblx0fVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/quick-lru/index.js\n");

/***/ }),

/***/ "./node_modules/terriajs-tiff-imagery-provider/dist/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/terriajs-tiff-imagery-provider/dist/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TIFFImageryProvider: () => (/* binding */ TIFFImageryProvider),\n/* harmony export */   colorscales: () => (/* binding */ colorscales),\n/* harmony export */   \"default\": () => (/* binding */ TIFFImageryProvider),\n/* harmony export */   renderColorScaleToCanvas: () => (/* binding */ renderColorScaleToCanvas)\n/* harmony export */ });\n/* harmony import */ var terriajs_cesium__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! terriajs-cesium */ \"./node_modules/terriajs-cesium/Source/Core/Color.js\");\n/* harmony import */ var terriajs_cesium__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! terriajs-cesium */ \"./node_modules/terriajs-cesium/Source/Core/WebMercatorTilingScheme.js\");\n/* harmony import */ var terriajs_cesium__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! terriajs-cesium */ \"./node_modules/terriajs-cesium/Source/Core/Rectangle.js\");\n/* harmony import */ var terriajs_cesium__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! terriajs-cesium */ \"./node_modules/terriajs-cesium/Source/Core/Math.js\");\n/* harmony import */ var terriajs_cesium__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! terriajs-cesium */ \"./node_modules/terriajs-cesium/Source/Core/Cartesian3.js\");\n/* harmony import */ var terriajs_cesium__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! terriajs-cesium */ \"./node_modules/terriajs-cesium/Source/Core/Cartographic.js\");\n/* harmony import */ var terriajs_cesium__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! terriajs-cesium */ \"./node_modules/terriajs-cesium/Source/Core/Credit.js\");\n/* harmony import */ var terriajs_cesium__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! terriajs-cesium */ \"./node_modules/terriajs-cesium/Source/Core/Event.js\");\n/* harmony import */ var terriajs_cesium__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! terriajs-cesium */ \"./node_modules/terriajs-cesium/Source/Core/defined.js\");\n/* harmony import */ var terriajs_cesium__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! terriajs-cesium */ \"./node_modules/terriajs-cesium/Source/Core/Cartesian2.js\");\n/* harmony import */ var terriajs_cesium__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! terriajs-cesium */ \"./node_modules/terriajs-cesium/Source/Core/GeographicTilingScheme.js\");\n/* harmony import */ var terriajs_cesium__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! terriajs-cesium */ \"./node_modules/terriajs-cesium/Source/Core/DeveloperError.js\");\n/* harmony import */ var terriajs_cesium__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! terriajs-cesium */ \"./node_modules/terriajs-cesium/Source/Scene/ImageryLayerFeatureInfo.js\");\n/* harmony import */ var geotiff__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! geotiff */ \"./node_modules/geotiff/dist-module/pool.js\");\n/* harmony import */ var geotiff__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! geotiff */ \"./node_modules/geotiff/dist-module/geotiff.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\n\n\nconst colorscales = {\n  viridis: new Uint8Array([68, 1, 84, 255, 68, 2, 86, 255, 69, 4, 87, 255, 69, 5, 89, 255, 70, 7, 90, 255, 70, 8, 92, 255, 70, 10, 93, 255, 70, 11, 94, 255, 71, 13, 96, 255, 71, 14, 97, 255, 71, 16, 99, 255, 71, 17, 100, 255, 71, 19, 101, 255, 72, 20, 103, 255, 72, 22, 104, 255, 72, 23, 105, 255, 72, 24, 106, 255, 72, 26, 108, 255, 72, 27, 109, 255, 72, 28, 110, 255, 72, 29, 111, 255, 72, 31, 112, 255, 72, 32, 113, 255, 72, 33, 115, 255, 72, 35, 116, 255, 72, 36, 117, 255, 72, 37, 118, 255, 72, 38, 119, 255, 72, 40, 120, 255, 72, 41, 121, 255, 71, 42, 122, 255, 71, 44, 122, 255, 71, 45, 123, 255, 71, 46, 124, 255, 71, 47, 125, 255, 70, 48, 126, 255, 70, 50, 126, 255, 70, 51, 127, 255, 70, 52, 128, 255, 69, 53, 129, 255, 69, 55, 129, 255, 69, 56, 130, 255, 68, 57, 131, 255, 68, 58, 131, 255, 68, 59, 132, 255, 67, 61, 132, 255, 67, 62, 133, 255, 66, 63, 133, 255, 66, 64, 134, 255, 66, 65, 134, 255, 65, 66, 135, 255, 65, 68, 135, 255, 64, 69, 136, 255, 64, 70, 136, 255, 63, 71, 136, 255, 63, 72, 137, 255, 62, 73, 137, 255, 62, 74, 137, 255, 62, 76, 138, 255, 61, 77, 138, 255, 61, 78, 138, 255, 60, 79, 138, 255, 60, 80, 139, 255, 59, 81, 139, 255, 59, 82, 139, 255, 58, 83, 139, 255, 58, 84, 140, 255, 57, 85, 140, 255, 57, 86, 140, 255, 56, 88, 140, 255, 56, 89, 140, 255, 55, 90, 140, 255, 55, 91, 141, 255, 54, 92, 141, 255, 54, 93, 141, 255, 53, 94, 141, 255, 53, 95, 141, 255, 52, 96, 141, 255, 52, 97, 141, 255, 51, 98, 141, 255, 51, 99, 141, 255, 50, 100, 142, 255, 50, 101, 142, 255, 49, 102, 142, 255, 49, 103, 142, 255, 49, 104, 142, 255, 48, 105, 142, 255, 48, 106, 142, 255, 47, 107, 142, 255, 47, 108, 142, 255, 46, 109, 142, 255, 46, 110, 142, 255, 46, 111, 142, 255, 45, 112, 142, 255, 45, 113, 142, 255, 44, 113, 142, 255, 44, 114, 142, 255, 44, 115, 142, 255, 43, 116, 142, 255, 43, 117, 142, 255, 42, 118, 142, 255, 42, 119, 142, 255, 42, 120, 142, 255, 41, 121, 142, 255, 41, 122, 142, 255, 41, 123, 142, 255, 40, 124, 142, 255, 40, 125, 142, 255, 39, 126, 142, 255, 39, 127, 142, 255, 39, 128, 142, 255, 38, 129, 142, 255, 38, 130, 142, 255, 38, 130, 142, 255, 37, 131, 142, 255, 37, 132, 142, 255, 37, 133, 142, 255, 36, 134, 142, 255, 36, 135, 142, 255, 35, 136, 142, 255, 35, 137, 142, 255, 35, 138, 141, 255, 34, 139, 141, 255, 34, 140, 141, 255, 34, 141, 141, 255, 33, 142, 141, 255, 33, 143, 141, 255, 33, 144, 141, 255, 33, 145, 140, 255, 32, 146, 140, 255, 32, 146, 140, 255, 32, 147, 140, 255, 31, 148, 140, 255, 31, 149, 139, 255, 31, 150, 139, 255, 31, 151, 139, 255, 31, 152, 139, 255, 31, 153, 138, 255, 31, 154, 138, 255, 30, 155, 138, 255, 30, 156, 137, 255, 30, 157, 137, 255, 31, 158, 137, 255, 31, 159, 136, 255, 31, 160, 136, 255, 31, 161, 136, 255, 31, 161, 135, 255, 31, 162, 135, 255, 32, 163, 134, 255, 32, 164, 134, 255, 33, 165, 133, 255, 33, 166, 133, 255, 34, 167, 133, 255, 34, 168, 132, 255, 35, 169, 131, 255, 36, 170, 131, 255, 37, 171, 130, 255, 37, 172, 130, 255, 38, 173, 129, 255, 39, 173, 129, 255, 40, 174, 128, 255, 41, 175, 127, 255, 42, 176, 127, 255, 44, 177, 126, 255, 45, 178, 125, 255, 46, 179, 124, 255, 47, 180, 124, 255, 49, 181, 123, 255, 50, 182, 122, 255, 52, 182, 121, 255, 53, 183, 121, 255, 55, 184, 120, 255, 56, 185, 119, 255, 58, 186, 118, 255, 59, 187, 117, 255, 61, 188, 116, 255, 63, 188, 115, 255, 64, 189, 114, 255, 66, 190, 113, 255, 68, 191, 112, 255, 70, 192, 111, 255, 72, 193, 110, 255, 74, 193, 109, 255, 76, 194, 108, 255, 78, 195, 107, 255, 80, 196, 106, 255, 82, 197, 105, 255, 84, 197, 104, 255, 86, 198, 103, 255, 88, 199, 101, 255, 90, 200, 100, 255, 92, 200, 99, 255, 94, 201, 98, 255, 96, 202, 96, 255, 99, 203, 95, 255, 101, 203, 94, 255, 103, 204, 92, 255, 105, 205, 91, 255, 108, 205, 90, 255, 110, 206, 88, 255, 112, 207, 87, 255, 115, 208, 86, 255, 117, 208, 84, 255, 119, 209, 83, 255, 122, 209, 81, 255, 124, 210, 80, 255, 127, 211, 78, 255, 129, 211, 77, 255, 132, 212, 75, 255, 134, 213, 73, 255, 137, 213, 72, 255, 139, 214, 70, 255, 142, 214, 69, 255, 144, 215, 67, 255, 147, 215, 65, 255, 149, 216, 64, 255, 152, 216, 62, 255, 155, 217, 60, 255, 157, 217, 59, 255, 160, 218, 57, 255, 162, 218, 55, 255, 165, 219, 54, 255, 168, 219, 52, 255, 170, 220, 50, 255, 173, 220, 48, 255, 176, 221, 47, 255, 178, 221, 45, 255, 181, 222, 43, 255, 184, 222, 41, 255, 186, 222, 40, 255, 189, 223, 38, 255, 192, 223, 37, 255, 194, 223, 35, 255, 197, 224, 33, 255, 200, 224, 32, 255, 202, 225, 31, 255, 205, 225, 29, 255, 208, 225, 28, 255, 210, 226, 27, 255, 213, 226, 26, 255, 216, 226, 25, 255, 218, 227, 25, 255, 221, 227, 24, 255, 223, 227, 24, 255, 226, 228, 24, 255, 229, 228, 25, 255, 231, 228, 25, 255, 234, 229, 26, 255, 236, 229, 27, 255, 239, 229, 28, 255, 241, 229, 29, 255, 244, 230, 30, 255, 246, 230, 32, 255, 248, 230, 33, 255, 251, 231, 35, 255, 253, 231, 37, 255]),\n  inferno: new Uint8Array([0, 0, 4, 255, 1, 0, 5, 255, 1, 1, 6, 255, 1, 1, 8, 255, 2, 1, 10, 255, 2, 2, 12, 255, 2, 2, 14, 255, 3, 2, 16, 255, 4, 3, 18, 255, 4, 3, 20, 255, 5, 4, 23, 255, 6, 4, 25, 255, 7, 5, 27, 255, 8, 5, 29, 255, 9, 6, 31, 255, 10, 7, 34, 255, 11, 7, 36, 255, 12, 8, 38, 255, 13, 8, 41, 255, 14, 9, 43, 255, 16, 9, 45, 255, 17, 10, 48, 255, 18, 10, 50, 255, 20, 11, 52, 255, 21, 11, 55, 255, 22, 11, 57, 255, 24, 12, 60, 255, 25, 12, 62, 255, 27, 12, 65, 255, 28, 12, 67, 255, 30, 12, 69, 255, 31, 12, 72, 255, 33, 12, 74, 255, 35, 12, 76, 255, 36, 12, 79, 255, 38, 12, 81, 255, 40, 11, 83, 255, 41, 11, 85, 255, 43, 11, 87, 255, 45, 11, 89, 255, 47, 10, 91, 255, 49, 10, 92, 255, 50, 10, 94, 255, 52, 10, 95, 255, 54, 9, 97, 255, 56, 9, 98, 255, 57, 9, 99, 255, 59, 9, 100, 255, 61, 9, 101, 255, 62, 9, 102, 255, 64, 10, 103, 255, 66, 10, 104, 255, 68, 10, 104, 255, 69, 10, 105, 255, 71, 11, 106, 255, 73, 11, 106, 255, 74, 12, 107, 255, 76, 12, 107, 255, 77, 13, 108, 255, 79, 13, 108, 255, 81, 14, 108, 255, 82, 14, 109, 255, 84, 15, 109, 255, 85, 15, 109, 255, 87, 16, 110, 255, 89, 16, 110, 255, 90, 17, 110, 255, 92, 18, 110, 255, 93, 18, 110, 255, 95, 19, 110, 255, 97, 19, 110, 255, 98, 20, 110, 255, 100, 21, 110, 255, 101, 21, 110, 255, 103, 22, 110, 255, 105, 22, 110, 255, 106, 23, 110, 255, 108, 24, 110, 255, 109, 24, 110, 255, 111, 25, 110, 255, 113, 25, 110, 255, 114, 26, 110, 255, 116, 26, 110, 255, 117, 27, 110, 255, 119, 28, 109, 255, 120, 28, 109, 255, 122, 29, 109, 255, 124, 29, 109, 255, 125, 30, 109, 255, 127, 30, 108, 255, 128, 31, 108, 255, 130, 32, 108, 255, 132, 32, 107, 255, 133, 33, 107, 255, 135, 33, 107, 255, 136, 34, 106, 255, 138, 34, 106, 255, 140, 35, 105, 255, 141, 35, 105, 255, 143, 36, 105, 255, 144, 37, 104, 255, 146, 37, 104, 255, 147, 38, 103, 255, 149, 38, 103, 255, 151, 39, 102, 255, 152, 39, 102, 255, 154, 40, 101, 255, 155, 41, 100, 255, 157, 41, 100, 255, 159, 42, 99, 255, 160, 42, 99, 255, 162, 43, 98, 255, 163, 44, 97, 255, 165, 44, 96, 255, 166, 45, 96, 255, 168, 46, 95, 255, 169, 46, 94, 255, 171, 47, 94, 255, 173, 48, 93, 255, 174, 48, 92, 255, 176, 49, 91, 255, 177, 50, 90, 255, 179, 50, 90, 255, 180, 51, 89, 255, 182, 52, 88, 255, 183, 53, 87, 255, 185, 53, 86, 255, 186, 54, 85, 255, 188, 55, 84, 255, 189, 56, 83, 255, 191, 57, 82, 255, 192, 58, 81, 255, 193, 58, 80, 255, 195, 59, 79, 255, 196, 60, 78, 255, 198, 61, 77, 255, 199, 62, 76, 255, 200, 63, 75, 255, 202, 64, 74, 255, 203, 65, 73, 255, 204, 66, 72, 255, 206, 67, 71, 255, 207, 68, 70, 255, 208, 69, 69, 255, 210, 70, 68, 255, 211, 71, 67, 255, 212, 72, 66, 255, 213, 74, 65, 255, 215, 75, 63, 255, 216, 76, 62, 255, 217, 77, 61, 255, 218, 78, 60, 255, 219, 80, 59, 255, 221, 81, 58, 255, 222, 82, 56, 255, 223, 83, 55, 255, 224, 85, 54, 255, 225, 86, 53, 255, 226, 87, 52, 255, 227, 89, 51, 255, 228, 90, 49, 255, 229, 92, 48, 255, 230, 93, 47, 255, 231, 94, 46, 255, 232, 96, 45, 255, 233, 97, 43, 255, 234, 99, 42, 255, 235, 100, 41, 255, 235, 102, 40, 255, 236, 103, 38, 255, 237, 105, 37, 255, 238, 106, 36, 255, 239, 108, 35, 255, 239, 110, 33, 255, 240, 111, 32, 255, 241, 113, 31, 255, 241, 115, 29, 255, 242, 116, 28, 255, 243, 118, 27, 255, 243, 120, 25, 255, 244, 121, 24, 255, 245, 123, 23, 255, 245, 125, 21, 255, 246, 126, 20, 255, 246, 128, 19, 255, 247, 130, 18, 255, 247, 132, 16, 255, 248, 133, 15, 255, 248, 135, 14, 255, 248, 137, 12, 255, 249, 139, 11, 255, 249, 140, 10, 255, 249, 142, 9, 255, 250, 144, 8, 255, 250, 146, 7, 255, 250, 148, 7, 255, 251, 150, 6, 255, 251, 151, 6, 255, 251, 153, 6, 255, 251, 155, 6, 255, 251, 157, 7, 255, 252, 159, 7, 255, 252, 161, 8, 255, 252, 163, 9, 255, 252, 165, 10, 255, 252, 166, 12, 255, 252, 168, 13, 255, 252, 170, 15, 255, 252, 172, 17, 255, 252, 174, 18, 255, 252, 176, 20, 255, 252, 178, 22, 255, 252, 180, 24, 255, 251, 182, 26, 255, 251, 184, 29, 255, 251, 186, 31, 255, 251, 188, 33, 255, 251, 190, 35, 255, 250, 192, 38, 255, 250, 194, 40, 255, 250, 196, 42, 255, 250, 198, 45, 255, 249, 199, 47, 255, 249, 201, 50, 255, 249, 203, 53, 255, 248, 205, 55, 255, 248, 207, 58, 255, 247, 209, 61, 255, 247, 211, 64, 255, 246, 213, 67, 255, 246, 215, 70, 255, 245, 217, 73, 255, 245, 219, 76, 255, 244, 221, 79, 255, 244, 223, 83, 255, 244, 225, 86, 255, 243, 227, 90, 255, 243, 229, 93, 255, 242, 230, 97, 255, 242, 232, 101, 255, 242, 234, 105, 255, 241, 236, 109, 255, 241, 237, 113, 255, 241, 239, 117, 255, 241, 241, 121, 255, 242, 242, 125, 255, 242, 244, 130, 255, 243, 245, 134, 255, 243, 246, 138, 255, 244, 248, 142, 255, 245, 249, 146, 255, 246, 250, 150, 255, 248, 251, 154, 255, 249, 252, 157, 255, 250, 253, 161, 255, 252, 255, 164, 255]),\n  turbo: new Uint8Array([48, 18, 59, 255, 50, 21, 67, 255, 51, 24, 74, 255, 52, 27, 81, 255, 53, 30, 88, 255, 54, 33, 95, 255, 55, 36, 102, 255, 56, 39, 109, 255, 57, 42, 115, 255, 58, 45, 121, 255, 59, 47, 128, 255, 60, 50, 134, 255, 61, 53, 139, 255, 62, 56, 145, 255, 63, 59, 151, 255, 63, 62, 156, 255, 64, 64, 162, 255, 65, 67, 167, 255, 65, 70, 172, 255, 66, 73, 177, 255, 66, 75, 181, 255, 67, 78, 186, 255, 68, 81, 191, 255, 68, 84, 195, 255, 68, 86, 199, 255, 69, 89, 203, 255, 69, 92, 207, 255, 69, 94, 211, 255, 70, 97, 214, 255, 70, 100, 218, 255, 70, 102, 221, 255, 70, 105, 224, 255, 70, 107, 227, 255, 71, 110, 230, 255, 71, 113, 233, 255, 71, 115, 235, 255, 71, 118, 238, 255, 71, 120, 240, 255, 71, 123, 242, 255, 70, 125, 244, 255, 70, 128, 246, 255, 70, 130, 248, 255, 70, 133, 250, 255, 70, 135, 251, 255, 69, 138, 252, 255, 69, 140, 253, 255, 68, 143, 254, 255, 67, 145, 254, 255, 66, 148, 255, 255, 65, 150, 255, 255, 64, 153, 255, 255, 62, 155, 254, 255, 61, 158, 254, 255, 59, 160, 253, 255, 58, 163, 252, 255, 56, 165, 251, 255, 55, 168, 250, 255, 53, 171, 248, 255, 51, 173, 247, 255, 49, 175, 245, 255, 47, 178, 244, 255, 46, 180, 242, 255, 44, 183, 240, 255, 42, 185, 238, 255, 40, 188, 235, 255, 39, 190, 233, 255, 37, 192, 231, 255, 35, 195, 228, 255, 34, 197, 226, 255, 32, 199, 223, 255, 31, 201, 221, 255, 30, 203, 218, 255, 28, 205, 216, 255, 27, 208, 213, 255, 26, 210, 210, 255, 26, 212, 208, 255, 25, 213, 205, 255, 24, 215, 202, 255, 24, 217, 200, 255, 24, 219, 197, 255, 24, 221, 194, 255, 24, 222, 192, 255, 24, 224, 189, 255, 25, 226, 187, 255, 25, 227, 185, 255, 26, 228, 182, 255, 28, 230, 180, 255, 29, 231, 178, 255, 31, 233, 175, 255, 32, 234, 172, 255, 34, 235, 170, 255, 37, 236, 167, 255, 39, 238, 164, 255, 42, 239, 161, 255, 44, 240, 158, 255, 47, 241, 155, 255, 50, 242, 152, 255, 53, 243, 148, 255, 56, 244, 145, 255, 60, 245, 142, 255, 63, 246, 138, 255, 67, 247, 135, 255, 70, 248, 132, 255, 74, 248, 128, 255, 78, 249, 125, 255, 82, 250, 122, 255, 85, 250, 118, 255, 89, 251, 115, 255, 93, 252, 111, 255, 97, 252, 108, 255, 101, 253, 105, 255, 105, 253, 102, 255, 109, 254, 98, 255, 113, 254, 95, 255, 117, 254, 92, 255, 121, 254, 89, 255, 125, 255, 86, 255, 128, 255, 83, 255, 132, 255, 81, 255, 136, 255, 78, 255, 139, 255, 75, 255, 143, 255, 73, 255, 146, 255, 71, 255, 150, 254, 68, 255, 153, 254, 66, 255, 156, 254, 64, 255, 159, 253, 63, 255, 161, 253, 61, 255, 164, 252, 60, 255, 167, 252, 58, 255, 169, 251, 57, 255, 172, 251, 56, 255, 175, 250, 55, 255, 177, 249, 54, 255, 180, 248, 54, 255, 183, 247, 53, 255, 185, 246, 53, 255, 188, 245, 52, 255, 190, 244, 52, 255, 193, 243, 52, 255, 195, 241, 52, 255, 198, 240, 52, 255, 200, 239, 52, 255, 203, 237, 52, 255, 205, 236, 52, 255, 208, 234, 52, 255, 210, 233, 53, 255, 212, 231, 53, 255, 215, 229, 53, 255, 217, 228, 54, 255, 219, 226, 54, 255, 221, 224, 55, 255, 223, 223, 55, 255, 225, 221, 55, 255, 227, 219, 56, 255, 229, 217, 56, 255, 231, 215, 57, 255, 233, 213, 57, 255, 235, 211, 57, 255, 236, 209, 58, 255, 238, 207, 58, 255, 239, 205, 58, 255, 241, 203, 58, 255, 242, 201, 58, 255, 244, 199, 58, 255, 245, 197, 58, 255, 246, 195, 58, 255, 247, 193, 58, 255, 248, 190, 57, 255, 249, 188, 57, 255, 250, 186, 57, 255, 251, 184, 56, 255, 251, 182, 55, 255, 252, 179, 54, 255, 252, 177, 54, 255, 253, 174, 53, 255, 253, 172, 52, 255, 254, 169, 51, 255, 254, 167, 50, 255, 254, 164, 49, 255, 254, 161, 48, 255, 254, 158, 47, 255, 254, 155, 45, 255, 254, 153, 44, 255, 254, 150, 43, 255, 254, 147, 42, 255, 254, 144, 41, 255, 253, 141, 39, 255, 253, 138, 38, 255, 252, 135, 37, 255, 252, 132, 35, 255, 251, 129, 34, 255, 251, 126, 33, 255, 250, 123, 31, 255, 249, 120, 30, 255, 249, 117, 29, 255, 248, 114, 28, 255, 247, 111, 26, 255, 246, 108, 25, 255, 245, 105, 24, 255, 244, 102, 23, 255, 243, 99, 21, 255, 242, 96, 20, 255, 241, 93, 19, 255, 240, 91, 18, 255, 239, 88, 17, 255, 237, 85, 16, 255, 236, 83, 15, 255, 235, 80, 14, 255, 234, 78, 13, 255, 232, 75, 12, 255, 231, 73, 12, 255, 229, 71, 11, 255, 228, 69, 10, 255, 226, 67, 10, 255, 225, 65, 9, 255, 223, 63, 8, 255, 221, 61, 8, 255, 220, 59, 7, 255, 218, 57, 7, 255, 216, 55, 6, 255, 214, 53, 6, 255, 212, 51, 5, 255, 210, 49, 5, 255, 208, 47, 5, 255, 206, 45, 4, 255, 204, 43, 4, 255, 202, 42, 4, 255, 200, 40, 3, 255, 197, 38, 3, 255, 195, 37, 3, 255, 193, 35, 2, 255, 190, 33, 2, 255, 188, 32, 2, 255, 185, 30, 2, 255, 183, 29, 2, 255, 180, 27, 1, 255, 178, 26, 1, 255, 175, 24, 1, 255, 172, 23, 1, 255, 169, 22, 1, 255, 167, 20, 1, 255, 164, 19, 1, 255, 161, 18, 1, 255, 158, 16, 1, 255, 155, 15, 1, 255, 152, 14, 1, 255, 149, 13, 1, 255, 146, 11, 1, 255, 142, 10, 1, 255, 139, 9, 2, 255, 136, 8, 2, 255, 133, 7, 2, 255, 129, 6, 2, 255, 126, 5, 2, 255, 122, 4, 3, 255]),\n  rainbow: {\n    colors: [\"#96005A\", \"#0000C8\", \"#0019FF\", \"#0098FF\", \"#2CFF96\", \"#97FF00\", \"#FFEA00\", \"#FF6F00\", \"#FF0000\"],\n    positions: [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1]\n  },\n  jet: {\n    colors: [\"#000083\", \"#003CAA\", \"#05FFFF\", \"#FFFF00\", \"#FA0000\", \"#800000\"],\n    positions: [0, 0.125, 0.375, 0.625, 0.875, 1]\n  },\n  hsv: {\n    colors: [\"#ff0000\", \"#fdff02\", \"#f7ff02\", \"#00fc04\", \"#00fc0a\", \"#01f9ff\", \"#0200fd\", \"#0800fd\", \"#ff00fb\", \"#ff00f5\", \"#ff0006\"],\n    positions: [0, 0.169, 0.173, 0.337, 0.341, 0.506, 0.671, 0.675, 0.839, 0.843, 1]\n  },\n  hot: {\n    colors: [\"#000000\", \"#e60000\", \"#ffd200\", \"#ffffff\"],\n    positions: [0, 0.3, 0.6, 1]\n  },\n  cool: {\n    colors: [\"#00ffff\", \"#ff00ff\"],\n    positions: [0, 1]\n  },\n  spring: {\n    colors: [\"#ff00ff\", \"#ffff00\"],\n    positions: [0, 1]\n  },\n  summer: {\n    colors: [\"#008066\", \"#ffff66\"],\n    positions: [0, 1]\n  },\n  autumn: {\n    colors: [\"#ff0000\", \"#ffff00\"],\n    positions: [0, 1]\n  },\n  winter: {\n    colors: [\"#0000ff\", \"#00ff80\"],\n    positions: [0, 1]\n  },\n  bone: {\n    colors: [\"#000000\", \"#545474\", \"#a9c8c8\", \"#ffffff\"],\n    positions: [0, 0.376, 0.753, 1]\n  },\n  copper: {\n    colors: [\"#000000\", \"#ffa066\", \"#ffc77f\"],\n    positions: [0, 0.804, 1]\n  },\n  greys: {\n    colors: [\"#000000\", \"#ffffff\"],\n    positions: [0, 1]\n  },\n  ylgnbu: {\n    colors: [\"#081d58\", \"#253494\", \"#225ea8\", \"#1d91c0\", \"#41b6c4\", \"#7fcdbb\", \"#c7e9b4\", \"#edf8d9\", \"#ffffd9\"],\n    positions: [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1]\n  },\n  greens: {\n    colors: [\"#00441b\", \"#006d2c\", \"#238b45\", \"#41ab5d\", \"#74c476\", \"#a1d99b\", \"#c7e9c0\", \"#e5f5e0\", \"#f7fcf5\"],\n    positions: [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1]\n  },\n  ylorrd: {\n    colors: [\"#800026\", \"#bd0026\", \"#e31a1c\", \"#fc4e2a\", \"#fd8d3c\", \"#feb24c\", \"#fed976\", \"#ffeda0\", \"#ffffcc\"],\n    positions: [0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1]\n  },\n  bluered: {\n    colors: [\"#0000ff\", \"#ff0000\"],\n    positions: [0, 1]\n  },\n  rdbu: {\n    colors: [\"#050aac\", \"#6a89f7\", \"#bebebe\", \"#dcaa84\", \"#e6915a\", \"#b20a1c\"],\n    positions: [0, 0.35, 0.5, 0.6, 0.7, 1]\n  },\n  picnic: {\n    colors: [\"#0000ff\", \"#3399ff\", \"#66ccff\", \"#99ccff\", \"#ccccff\", \"#ffffff\", \"#ffccff\", \"#ff99ff\", \"#ff66cc\", \"#ff6666\", \"#ff0000\"],\n    positions: [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]\n  },\n  portland: {\n    colors: [\"#0c3383\", \"#0a88ba\", \"#f2d338\", \"#f28f38\", \"#d91e1e\"],\n    positions: [0, 0.25, 0.5, 0.75, 1]\n  },\n  blackbody: {\n    colors: [\"#000000\", \"#e60000\", \"#e6d200\", \"#ffffff\", \"#a0c8ff\"],\n    positions: [0, 0.2, 0.4, 0.7, 1]\n  },\n  earth: {\n    colors: [\"#000082\", \"#00b4b4\", \"#28d228\", \"#e6e632\", \"#784614\", \"#ffffff\"],\n    positions: [0, 0.1, 0.2, 0.4, 0.6, 1]\n  },\n  electric: {\n    colors: [\"#000000\", \"#1e0064\", \"#780064\", \"#a05a00\", \"#e6c800\", \"#fffadc\"],\n    positions: [0, 0.15, 0.4, 0.6, 0.8, 1]\n  },\n  magma: new Uint8Array([0, 0, 4, 255, 1, 0, 5, 255, 1, 1, 6, 255, 1, 1, 8, 255, 2, 1, 9, 255, 2, 2, 11, 255, 2, 2, 13, 255, 3, 3, 15, 255, 3, 3, 18, 255, 4, 4, 20, 255, 5, 4, 22, 255, 6, 5, 24, 255, 6, 5, 26, 255, 7, 6, 28, 255, 8, 7, 30, 255, 9, 7, 32, 255, 10, 8, 34, 255, 11, 9, 36, 255, 12, 9, 38, 255, 13, 10, 41, 255, 14, 11, 43, 255, 16, 11, 45, 255, 17, 12, 47, 255, 18, 13, 49, 255, 19, 13, 52, 255, 20, 14, 54, 255, 21, 14, 56, 255, 22, 15, 59, 255, 24, 15, 61, 255, 25, 16, 63, 255, 26, 16, 66, 255, 28, 16, 68, 255, 29, 17, 71, 255, 30, 17, 73, 255, 32, 17, 75, 255, 33, 17, 78, 255, 34, 17, 80, 255, 36, 18, 83, 255, 37, 18, 85, 255, 39, 18, 88, 255, 41, 17, 90, 255, 42, 17, 92, 255, 44, 17, 95, 255, 45, 17, 97, 255, 47, 17, 99, 255, 49, 17, 101, 255, 51, 16, 103, 255, 52, 16, 105, 255, 54, 16, 107, 255, 56, 16, 108, 255, 57, 15, 110, 255, 59, 15, 112, 255, 61, 15, 113, 255, 63, 15, 114, 255, 64, 15, 116, 255, 66, 15, 117, 255, 68, 15, 118, 255, 69, 16, 119, 255, 71, 16, 120, 255, 73, 16, 120, 255, 74, 16, 121, 255, 76, 17, 122, 255, 78, 17, 123, 255, 79, 18, 123, 255, 81, 18, 124, 255, 82, 19, 124, 255, 84, 19, 125, 255, 86, 20, 125, 255, 87, 21, 126, 255, 89, 21, 126, 255, 90, 22, 126, 255, 92, 22, 127, 255, 93, 23, 127, 255, 95, 24, 127, 255, 96, 24, 128, 255, 98, 25, 128, 255, 100, 26, 128, 255, 101, 26, 128, 255, 103, 27, 128, 255, 104, 28, 129, 255, 106, 28, 129, 255, 107, 29, 129, 255, 109, 29, 129, 255, 110, 30, 129, 255, 112, 31, 129, 255, 114, 31, 129, 255, 115, 32, 129, 255, 117, 33, 129, 255, 118, 33, 129, 255, 120, 34, 129, 255, 121, 34, 130, 255, 123, 35, 130, 255, 124, 35, 130, 255, 126, 36, 130, 255, 128, 37, 130, 255, 129, 37, 129, 255, 131, 38, 129, 255, 132, 38, 129, 255, 134, 39, 129, 255, 136, 39, 129, 255, 137, 40, 129, 255, 139, 41, 129, 255, 140, 41, 129, 255, 142, 42, 129, 255, 144, 42, 129, 255, 145, 43, 129, 255, 147, 43, 128, 255, 148, 44, 128, 255, 150, 44, 128, 255, 152, 45, 128, 255, 153, 45, 128, 255, 155, 46, 127, 255, 156, 46, 127, 255, 158, 47, 127, 255, 160, 47, 127, 255, 161, 48, 126, 255, 163, 48, 126, 255, 165, 49, 126, 255, 166, 49, 125, 255, 168, 50, 125, 255, 170, 51, 125, 255, 171, 51, 124, 255, 173, 52, 124, 255, 174, 52, 123, 255, 176, 53, 123, 255, 178, 53, 123, 255, 179, 54, 122, 255, 181, 54, 122, 255, 183, 55, 121, 255, 184, 55, 121, 255, 186, 56, 120, 255, 188, 57, 120, 255, 189, 57, 119, 255, 191, 58, 119, 255, 192, 58, 118, 255, 194, 59, 117, 255, 196, 60, 117, 255, 197, 60, 116, 255, 199, 61, 115, 255, 200, 62, 115, 255, 202, 62, 114, 255, 204, 63, 113, 255, 205, 64, 113, 255, 207, 64, 112, 255, 208, 65, 111, 255, 210, 66, 111, 255, 211, 67, 110, 255, 213, 68, 109, 255, 214, 69, 108, 255, 216, 69, 108, 255, 217, 70, 107, 255, 219, 71, 106, 255, 220, 72, 105, 255, 222, 73, 104, 255, 223, 74, 104, 255, 224, 76, 103, 255, 226, 77, 102, 255, 227, 78, 101, 255, 228, 79, 100, 255, 229, 80, 100, 255, 231, 82, 99, 255, 232, 83, 98, 255, 233, 84, 98, 255, 234, 86, 97, 255, 235, 87, 96, 255, 236, 88, 96, 255, 237, 90, 95, 255, 238, 91, 94, 255, 239, 93, 94, 255, 240, 95, 94, 255, 241, 96, 93, 255, 242, 98, 93, 255, 242, 100, 92, 255, 243, 101, 92, 255, 244, 103, 92, 255, 244, 105, 92, 255, 245, 107, 92, 255, 246, 108, 92, 255, 246, 110, 92, 255, 247, 112, 92, 255, 247, 114, 92, 255, 248, 116, 92, 255, 248, 118, 92, 255, 249, 120, 93, 255, 249, 121, 93, 255, 249, 123, 93, 255, 250, 125, 94, 255, 250, 127, 94, 255, 250, 129, 95, 255, 251, 131, 95, 255, 251, 133, 96, 255, 251, 135, 97, 255, 252, 137, 97, 255, 252, 138, 98, 255, 252, 140, 99, 255, 252, 142, 100, 255, 252, 144, 101, 255, 253, 146, 102, 255, 253, 148, 103, 255, 253, 150, 104, 255, 253, 152, 105, 255, 253, 154, 106, 255, 253, 155, 107, 255, 254, 157, 108, 255, 254, 159, 109, 255, 254, 161, 110, 255, 254, 163, 111, 255, 254, 165, 113, 255, 254, 167, 114, 255, 254, 169, 115, 255, 254, 170, 116, 255, 254, 172, 118, 255, 254, 174, 119, 255, 254, 176, 120, 255, 254, 178, 122, 255, 254, 180, 123, 255, 254, 182, 124, 255, 254, 183, 126, 255, 254, 185, 127, 255, 254, 187, 129, 255, 254, 189, 130, 255, 254, 191, 132, 255, 254, 193, 133, 255, 254, 194, 135, 255, 254, 196, 136, 255, 254, 198, 138, 255, 254, 200, 140, 255, 254, 202, 141, 255, 254, 204, 143, 255, 254, 205, 144, 255, 254, 207, 146, 255, 254, 209, 148, 255, 254, 211, 149, 255, 254, 213, 151, 255, 254, 215, 153, 255, 254, 216, 154, 255, 253, 218, 156, 255, 253, 220, 158, 255, 253, 222, 160, 255, 253, 224, 161, 255, 253, 226, 163, 255, 253, 227, 165, 255, 253, 229, 167, 255, 253, 231, 169, 255, 253, 233, 170, 255, 253, 235, 172, 255, 252, 236, 174, 255, 252, 238, 176, 255, 252, 240, 178, 255, 252, 242, 180, 255, 252, 244, 182, 255, 252, 246, 184, 255, 252, 247, 185, 255, 252, 249, 187, 255, 252, 251, 189, 255, 252, 253, 191, 255]),\n  plasma: new Uint8Array([13, 8, 135, 255, 16, 7, 136, 255, 19, 7, 137, 255, 22, 7, 138, 255, 25, 6, 140, 255, 27, 6, 141, 255, 29, 6, 142, 255, 32, 6, 143, 255, 34, 6, 144, 255, 36, 6, 145, 255, 38, 5, 145, 255, 40, 5, 146, 255, 42, 5, 147, 255, 44, 5, 148, 255, 46, 5, 149, 255, 47, 5, 150, 255, 49, 5, 151, 255, 51, 5, 151, 255, 53, 4, 152, 255, 55, 4, 153, 255, 56, 4, 154, 255, 58, 4, 154, 255, 60, 4, 155, 255, 62, 4, 156, 255, 63, 4, 156, 255, 65, 4, 157, 255, 67, 3, 158, 255, 68, 3, 158, 255, 70, 3, 159, 255, 72, 3, 159, 255, 73, 3, 160, 255, 75, 3, 161, 255, 76, 2, 161, 255, 78, 2, 162, 255, 80, 2, 162, 255, 81, 2, 163, 255, 83, 2, 163, 255, 85, 2, 164, 255, 86, 1, 164, 255, 88, 1, 164, 255, 89, 1, 165, 255, 91, 1, 165, 255, 92, 1, 166, 255, 94, 1, 166, 255, 96, 1, 166, 255, 97, 0, 167, 255, 99, 0, 167, 255, 100, 0, 167, 255, 102, 0, 167, 255, 103, 0, 168, 255, 105, 0, 168, 255, 106, 0, 168, 255, 108, 0, 168, 255, 110, 0, 168, 255, 111, 0, 168, 255, 113, 0, 168, 255, 114, 1, 168, 255, 116, 1, 168, 255, 117, 1, 168, 255, 119, 1, 168, 255, 120, 1, 168, 255, 122, 2, 168, 255, 123, 2, 168, 255, 125, 3, 168, 255, 126, 3, 168, 255, 128, 4, 168, 255, 129, 4, 167, 255, 131, 5, 167, 255, 132, 5, 167, 255, 134, 6, 166, 255, 135, 7, 166, 255, 136, 8, 166, 255, 138, 9, 165, 255, 139, 10, 165, 255, 141, 11, 165, 255, 142, 12, 164, 255, 143, 13, 164, 255, 145, 14, 163, 255, 146, 15, 163, 255, 148, 16, 162, 255, 149, 17, 161, 255, 150, 19, 161, 255, 152, 20, 160, 255, 153, 21, 159, 255, 154, 22, 159, 255, 156, 23, 158, 255, 157, 24, 157, 255, 158, 25, 157, 255, 160, 26, 156, 255, 161, 27, 155, 255, 162, 29, 154, 255, 163, 30, 154, 255, 165, 31, 153, 255, 166, 32, 152, 255, 167, 33, 151, 255, 168, 34, 150, 255, 170, 35, 149, 255, 171, 36, 148, 255, 172, 38, 148, 255, 173, 39, 147, 255, 174, 40, 146, 255, 176, 41, 145, 255, 177, 42, 144, 255, 178, 43, 143, 255, 179, 44, 142, 255, 180, 46, 141, 255, 181, 47, 140, 255, 182, 48, 139, 255, 183, 49, 138, 255, 184, 50, 137, 255, 186, 51, 136, 255, 187, 52, 136, 255, 188, 53, 135, 255, 189, 55, 134, 255, 190, 56, 133, 255, 191, 57, 132, 255, 192, 58, 131, 255, 193, 59, 130, 255, 194, 60, 129, 255, 195, 61, 128, 255, 196, 62, 127, 255, 197, 64, 126, 255, 198, 65, 125, 255, 199, 66, 124, 255, 200, 67, 123, 255, 201, 68, 122, 255, 202, 69, 122, 255, 203, 70, 121, 255, 204, 71, 120, 255, 204, 73, 119, 255, 205, 74, 118, 255, 206, 75, 117, 255, 207, 76, 116, 255, 208, 77, 115, 255, 209, 78, 114, 255, 210, 79, 113, 255, 211, 81, 113, 255, 212, 82, 112, 255, 213, 83, 111, 255, 213, 84, 110, 255, 214, 85, 109, 255, 215, 86, 108, 255, 216, 87, 107, 255, 217, 88, 106, 255, 218, 90, 106, 255, 218, 91, 105, 255, 219, 92, 104, 255, 220, 93, 103, 255, 221, 94, 102, 255, 222, 95, 101, 255, 222, 97, 100, 255, 223, 98, 99, 255, 224, 99, 99, 255, 225, 100, 98, 255, 226, 101, 97, 255, 226, 102, 96, 255, 227, 104, 95, 255, 228, 105, 94, 255, 229, 106, 93, 255, 229, 107, 93, 255, 230, 108, 92, 255, 231, 110, 91, 255, 231, 111, 90, 255, 232, 112, 89, 255, 233, 113, 88, 255, 233, 114, 87, 255, 234, 116, 87, 255, 235, 117, 86, 255, 235, 118, 85, 255, 236, 119, 84, 255, 237, 121, 83, 255, 237, 122, 82, 255, 238, 123, 81, 255, 239, 124, 81, 255, 239, 126, 80, 255, 240, 127, 79, 255, 240, 128, 78, 255, 241, 129, 77, 255, 241, 131, 76, 255, 242, 132, 75, 255, 243, 133, 75, 255, 243, 135, 74, 255, 244, 136, 73, 255, 244, 137, 72, 255, 245, 139, 71, 255, 245, 140, 70, 255, 246, 141, 69, 255, 246, 143, 68, 255, 247, 144, 68, 255, 247, 145, 67, 255, 247, 147, 66, 255, 248, 148, 65, 255, 248, 149, 64, 255, 249, 151, 63, 255, 249, 152, 62, 255, 249, 154, 62, 255, 250, 155, 61, 255, 250, 156, 60, 255, 250, 158, 59, 255, 251, 159, 58, 255, 251, 161, 57, 255, 251, 162, 56, 255, 252, 163, 56, 255, 252, 165, 55, 255, 252, 166, 54, 255, 252, 168, 53, 255, 252, 169, 52, 255, 253, 171, 51, 255, 253, 172, 51, 255, 253, 174, 50, 255, 253, 175, 49, 255, 253, 177, 48, 255, 253, 178, 47, 255, 253, 180, 47, 255, 253, 181, 46, 255, 254, 183, 45, 255, 254, 184, 44, 255, 254, 186, 44, 255, 254, 187, 43, 255, 254, 189, 42, 255, 254, 190, 42, 255, 254, 192, 41, 255, 253, 194, 41, 255, 253, 195, 40, 255, 253, 197, 39, 255, 253, 198, 39, 255, 253, 200, 39, 255, 253, 202, 38, 255, 253, 203, 38, 255, 252, 205, 37, 255, 252, 206, 37, 255, 252, 208, 37, 255, 252, 210, 37, 255, 251, 211, 36, 255, 251, 213, 36, 255, 251, 215, 36, 255, 250, 216, 36, 255, 250, 218, 36, 255, 249, 220, 36, 255, 249, 221, 37, 255, 248, 223, 37, 255, 248, 225, 37, 255, 247, 226, 37, 255, 247, 228, 37, 255, 246, 230, 38, 255, 246, 232, 38, 255, 245, 233, 38, 255, 245, 235, 39, 255, 244, 237, 39, 255, 243, 238, 39, 255, 243, 240, 39, 255, 242, 242, 39, 255, 241, 244, 38, 255, 241, 245, 37, 255, 240, 247, 36, 255, 240, 249, 33, 255]),\n  redblue: {\n    colors: [\"#ff0000\", \"#0000ff\"],\n    positions: [0, 1]\n  },\n  coolwarm: {\n    colors: [\"#0000ff\", \"#ffffff\", \"#ff0000\"],\n    positions: [0, 0.5, 1]\n  },\n  diverging_1: {\n    colors: [\"#400040\", \"#3b004d\", \"#36005b\", \"#320068\", \"#2d0076\", \"#290084\", \"#240091\", \"#20009f\", \"#1b00ad\", \"#1600ba\", \"#1200c8\", \"#0d00d6\", \"#0900e3\", \"#0400f1\", \"#0000ff\", \"#0217ff\", \"#042eff\", \"#0645ff\", \"#095cff\", \"#0b73ff\", \"#0d8bff\", \"#10a2ff\", \"#12b9ff\", \"#14d0ff\", \"#17e7ff\", \"#19ffff\", \"#3fffff\", \"#66ffff\", \"#8cffff\", \"#b2ffff\", \"#d8ffff\", \"#ffffff\", \"#ffffd4\", \"#ffffaa\", \"#ffff7f\", \"#ffff54\", \"#ffff2a\", \"#ffff00\", \"#ffed00\", \"#ffdd00\", \"#ffcc00\", \"#ffba00\", \"#ffaa00\", \"#ff9900\", \"#ff8700\", \"#ff7700\", \"#ff6600\", \"#ff5400\", \"#ff4400\", \"#ff3300\", \"#ff2100\", \"#ff1100\", \"#ff0000\", \"#ff0017\", \"#ff002e\", \"#ff0045\", \"#ff005c\", \"#ff0073\", \"#ff008b\", \"#ff00a2\", \"#ff00b9\", \"#ff00d0\", \"#ff00e7\", \"#ff00ff\"],\n    positions: [0, 0.01587301587, 0.03174603174, 0.04761904761, 0.06349206348, 0.07936507935, 0.09523809522, 0.11111111109, 0.12698412696, 0.14285714283, 0.1587301587, 0.17460317457, 0.19047619044, 0.20634920631, 0.22222222218, 0.23809523805, 0.25396825392, 0.26984126979, 0.28571428566, 0.30158730153, 0.3174603174, 0.33333333327, 0.34920634914, 0.36507936501, 0.38095238088, 0.39682539675, 0.41269841262, 0.42857142849, 0.44444444436, 0.46031746023, 0.4761904761, 0.49206349197, 0.50793650784, 0.52380952371, 0.53968253958, 0.55555555545, 0.57142857132, 0.58730158719, 0.60317460306, 0.61904761893, 0.6349206348, 0.65079365067, 0.66666666654, 0.68253968241, 0.69841269828, 0.71428571415, 0.73015873002, 0.74603174589, 0.76190476176, 0.77777777763, 0.7936507935, 0.80952380937, 0.82539682524, 0.84126984111, 0.85714285698, 0.87301587285, 0.88888888872, 0.90476190459, 0.92063492046, 0.93650793633, 0.9523809522, 0.96825396807, 0.98412698394, 1]\n  },\n  diverging_2: {\n    colors: [\"#000000\", \"#030aff\", \"#204aff\", \"#3c8aff\", \"#77c4ff\", \"#f0ffff\", \"#f0ffff\", \"#f2ff7f\", \"#ffff00\", \"#ff831e\", \"#ff083d\", \"#ff00ff\"],\n    positions: [0, 1e-10, 0.1, 0.2, 0.3333, 0.4666, 0.5333, 0.6666, 0.8, 0.9, 0.999999999999, 1]\n  },\n  blackwhite: {\n    colors: [\"#000000\", \"#ffffff\"],\n    positions: [0, 1]\n  },\n  twilight: {\n    colors: [\"#E2D9E2\", \"#E0D9E2\", \"#DDD9E0\", \"#DAD8DF\", \"#D6D7DD\", \"#D2D5DB\", \"#CDD3D8\", \"#C8D0D6\", \"#C2CED4\", \"#BCCBD1\", \"#B6C8CF\", \"#B0C5CD\", \"#AAC2CC\", \"#A4BECA\", \"#9EBBC9\", \"#99B8C8\", \"#93B4C6\", \"#8EB1C5\", \"#89ADC5\", \"#85A9C4\", \"#80A5C3\", \"#7CA2C2\", \"#789EC2\", \"#759AC1\", \"#7196C1\", \"#6E92C0\", \"#6C8EBF\", \"#698ABF\", \"#6786BE\", \"#6682BD\", \"#647DBC\", \"#6379BB\", \"#6275BA\", \"#6170B9\", \"#606CB8\", \"#6067B6\", \"#5F62B4\", \"#5F5EB3\", \"#5F59B1\", \"#5E54AE\", \"#5E4FAC\", \"#5E4BA9\", \"#5E46A6\", \"#5D41A3\", \"#5D3CA0\", \"#5C379C\", \"#5B3298\", \"#5A2E93\", \"#59298E\", \"#572588\", \"#562182\", \"#531E7C\", \"#511A75\", \"#4E186F\", \"#4B1668\", \"#471461\", \"#44135A\", \"#411254\", \"#3D114E\", \"#3A1149\", \"#371144\", \"#351140\", \"#33113C\", \"#311339\", \"#301437\", \"#331237\", \"#351138\", \"#381139\", \"#3B113B\", \"#3F123D\", \"#43123E\", \"#481341\", \"#4D1443\", \"#521545\", \"#571647\", \"#5C1749\", \"#61184B\", \"#67194C\", \"#6C1B4E\", \"#711D4F\", \"#761F4F\", \"#7B2150\", \"#802350\", \"#852650\", \"#8A2950\", \"#8E2C50\", \"#922F50\", \"#963350\", \"#9A3750\", \"#9E3B50\", \"#A13F50\", \"#A54350\", \"#A84750\", \"#AB4B50\", \"#AE5051\", \"#B15452\", \"#B35953\", \"#B65D54\", \"#B86255\", \"#BA6657\", \"#BC6B59\", \"#BE705B\", \"#C0755E\", \"#C27A61\", \"#C37F64\", \"#C58468\", \"#C6896C\", \"#C78E71\", \"#C89275\", \"#C9977B\", \"#CA9C80\", \"#CCA186\", \"#CDA68C\", \"#CEAB92\", \"#CFAF99\", \"#D1B4A0\", \"#D2B8A7\", \"#D4BDAD\", \"#D6C1B4\", \"#D8C5BB\", \"#D9C9C2\", \"#DBCCC8\", \"#DDD0CE\", \"#DED3D3\", \"#DFD5D8\", \"#E0D7DB\", \"#E1D8DF\", \"#E2D9E1\"],\n    positions: [0, 0.0078740157, 0.0157480315, 0.0236220472, 0.031496063, 0.0393700787, 0.0472440945, 0.0551181102, 0.062992126, 0.0708661417, 0.0787401575, 0.0866141732, 0.094488189, 0.1023622047, 0.1102362205, 0.1181102362, 0.125984252, 0.1338582677, 0.1417322835, 0.1496062992, 0.157480315, 0.1653543307, 0.1732283465, 0.1811023622, 0.188976378, 0.1968503937, 0.2047244094, 0.2125984252, 0.2204724409, 0.2283464567, 0.2362204724, 0.2440944882, 0.2519685039, 0.2598425197, 0.2677165354, 0.2755905512, 0.2834645669, 0.2913385827, 0.2992125984, 0.3070866142, 0.3149606299, 0.3228346457, 0.3307086614, 0.3385826772, 0.3464566929, 0.3543307087, 0.3622047244, 0.3700787402, 0.3779527559, 0.3858267717, 0.3937007874, 0.4015748031, 0.4094488189, 0.4173228346, 0.4251968504, 0.4330708661, 0.4409448819, 0.4488188976, 0.4566929134, 0.4645669291, 0.4724409449, 0.4803149606, 0.4881889764, 0.4960629921, 0.5039370079, 0.5118110236, 0.5196850394, 0.5275590551, 0.5354330709, 0.5433070866, 0.5511811024, 0.5590551181, 0.5669291339, 0.5748031496, 0.5826771654, 0.5905511811, 0.5984251969, 0.6062992126, 0.6141732283, 0.6220472441, 0.6299212598, 0.6377952756, 0.6456692913, 0.6535433071, 0.6614173228, 0.6692913386, 0.6771653543, 0.6850393701, 0.6929133858, 0.7007874016, 0.7086614173, 0.7165354331, 0.7244094488, 0.7322834646, 0.7401574803, 0.7480314961, 0.7559055118, 0.7637795276, 0.7716535433, 0.7795275591, 0.7874015748, 0.7952755906, 0.8031496063, 0.811023622, 0.8188976378, 0.8267716535, 0.8346456693, 0.842519685, 0.8503937008, 0.8582677165, 0.8661417323, 0.874015748, 0.8818897638, 0.8897637795, 0.8976377953, 0.905511811, 0.9133858268, 0.9212598425, 0.9291338583, 0.937007874, 0.9448818898, 0.9527559055, 0.9606299213, 0.968503937, 0.9763779528, 0.9842519685, 0.9921259843, 1]\n  },\n  twilight_shifted: {\n    colors: [\"#301437\", \"#32123A\", \"#34113E\", \"#361142\", \"#391146\", \"#3C114B\", \"#3F1251\", \"#421257\", \"#46145E\", \"#491564\", \"#4C176B\", \"#4F1972\", \"#521C79\", \"#551F7F\", \"#572385\", \"#58278B\", \"#5A2B90\", \"#5B3095\", \"#5C359A\", \"#5D3A9E\", \"#5D3EA1\", \"#5E43A5\", \"#5E48A8\", \"#5E4DAB\", \"#5E52AD\", \"#5F57B0\", \"#5F5BB2\", \"#5F60B4\", \"#5F65B5\", \"#6069B7\", \"#606EB8\", \"#6172BA\", \"#6277BB\", \"#637BBC\", \"#657FBD\", \"#6684BD\", \"#6888BE\", \"#6B8CBF\", \"#6D90C0\", \"#7094C0\", \"#7398C1\", \"#769CC1\", \"#7AA0C2\", \"#7EA4C3\", \"#82A7C3\", \"#87ABC4\", \"#8CAFC5\", \"#91B2C6\", \"#96B6C7\", \"#9CB9C8\", \"#A1BDC9\", \"#A7C0CB\", \"#ADC3CD\", \"#B3C6CE\", \"#B9C9D0\", \"#BFCCD3\", \"#C5CFD5\", \"#CBD2D7\", \"#D0D4D9\", \"#D4D6DC\", \"#D8D8DE\", \"#DCD9DF\", \"#DED9E1\", \"#E1D9E2\", \"#E2D9E1\", \"#E1D8DF\", \"#E0D7DB\", \"#DFD5D8\", \"#DED3D3\", \"#DDD0CE\", \"#DBCCC8\", \"#D9C9C2\", \"#D8C5BB\", \"#D6C1B4\", \"#D4BDAD\", \"#D2B8A7\", \"#D1B4A0\", \"#CFAF99\", \"#CEAB92\", \"#CDA68C\", \"#CCA186\", \"#CA9C80\", \"#C9977B\", \"#C89275\", \"#C78E71\", \"#C6896C\", \"#C58468\", \"#C37F64\", \"#C27A61\", \"#C0755E\", \"#BE705B\", \"#BC6B59\", \"#BA6657\", \"#B86255\", \"#B65D54\", \"#B35953\", \"#B15452\", \"#AE5051\", \"#AB4B50\", \"#A84750\", \"#A54350\", \"#A13F50\", \"#9E3B50\", \"#9A3750\", \"#963350\", \"#922F50\", \"#8E2C50\", \"#8A2950\", \"#852650\", \"#802350\", \"#7B2150\", \"#761F4F\", \"#711D4F\", \"#6C1B4E\", \"#67194C\", \"#61184B\", \"#5C1749\", \"#571647\", \"#521545\", \"#4D1443\", \"#481341\", \"#43123E\", \"#3F123D\", \"#3B113B\", \"#381139\", \"#351138\", \"#331237\", \"#301437\"],\n    positions: [0, 0.0078740157, 0.0157480315, 0.0236220472, 0.031496063, 0.0393700787, 0.0472440945, 0.0551181102, 0.062992126, 0.0708661417, 0.0787401575, 0.0866141732, 0.094488189, 0.1023622047, 0.1102362205, 0.1181102362, 0.125984252, 0.1338582677, 0.1417322835, 0.1496062992, 0.157480315, 0.1653543307, 0.1732283465, 0.1811023622, 0.188976378, 0.1968503937, 0.2047244094, 0.2125984252, 0.2204724409, 0.2283464567, 0.2362204724, 0.2440944882, 0.2519685039, 0.2598425197, 0.2677165354, 0.2755905512, 0.2834645669, 0.2913385827, 0.2992125984, 0.3070866142, 0.3149606299, 0.3228346457, 0.3307086614, 0.3385826772, 0.3464566929, 0.3543307087, 0.3622047244, 0.3700787402, 0.3779527559, 0.3858267717, 0.3937007874, 0.4015748031, 0.4094488189, 0.4173228346, 0.4251968504, 0.4330708661, 0.4409448819, 0.4488188976, 0.4566929134, 0.4645669291, 0.4724409449, 0.4803149606, 0.4881889764, 0.4960629921, 0.5039370079, 0.5118110236, 0.5196850394, 0.5275590551, 0.5354330709, 0.5433070866, 0.5511811024, 0.5590551181, 0.5669291339, 0.5748031496, 0.5826771654, 0.5905511811, 0.5984251969, 0.6062992126, 0.6141732283, 0.6220472441, 0.6299212598, 0.6377952756, 0.6456692913, 0.6535433071, 0.6614173228, 0.6692913386, 0.6771653543, 0.6850393701, 0.6929133858, 0.7007874016, 0.7086614173, 0.7165354331, 0.7244094488, 0.7322834646, 0.7401574803, 0.7480314961, 0.7559055118, 0.7637795276, 0.7716535433, 0.7795275591, 0.7874015748, 0.7952755906, 0.8031496063, 0.811023622, 0.8188976378, 0.8267716535, 0.8346456693, 0.842519685, 0.8503937008, 0.8582677165, 0.8661417323, 0.874015748, 0.8818897638, 0.8897637795, 0.8976377953, 0.905511811, 0.9133858268, 0.9212598425, 0.9291338583, 0.937007874, 0.9448818898, 0.9527559055, 0.9606299213, 0.968503937, 0.9763779528, 0.9842519685, 0.9921259843, 1]\n  }\n};\n\nfunction peg$subclass(child, parent) {\n  function C() {\n    this.constructor = child;\n  }\n  C.prototype = parent.prototype;\n  child.prototype = new C();\n}\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message = message;\n  this.expected = expected;\n  this.found = found;\n  this.location = location;\n  this.name = \"SyntaxError\";\n  if (typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\npeg$subclass(peg$SyntaxError, Error);\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n    literal: function(expectation) {\n      return '\"' + literalEscape(expectation.text) + '\"';\n    },\n    class: function(expectation) {\n      var escapedParts = expectation.parts.map(function(part) {\n        return Array.isArray(part) ? classEscape(part[0]) + \"-\" + classEscape(part[1]) : classEscape(part);\n      });\n      return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n    },\n    any: function() {\n      return \"any character\";\n    },\n    end: function() {\n      return \"end of input\";\n    },\n    other: function(expectation) {\n      return expectation.description;\n    },\n    not: function(expectation) {\n      return \"not \" + describeExpectation(expectation.expected);\n    }\n  };\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n  function literalEscape(s) {\n    return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"').replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n      return \"\\\\x0\" + hex(ch);\n    }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n      return \"\\\\x\" + hex(ch);\n    });\n  }\n  function classEscape(s) {\n    return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\]/g, \"\\\\]\").replace(/\\^/g, \"\\\\^\").replace(/-/g, \"\\\\-\").replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function(ch) {\n      return \"\\\\x0\" + hex(ch);\n    }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) {\n      return \"\\\\x\" + hex(ch);\n    });\n  }\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n  function describeExpected(expected2) {\n    var descriptions = expected2.map(describeExpectation);\n    var i, j;\n    descriptions.sort();\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n      default:\n        return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n    }\n  }\n  function describeFound(found2) {\n    return found2 ? '\"' + literalEscape(found2) + '\"' : \"end of input\";\n  }\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\nfunction peg$parse(input, options) {\n  options = options !== void 0 ? options : {};\n  var peg$FAILED = {};\n  var peg$startRuleFunctions = { Expression: peg$parseExpression };\n  var peg$startRuleFunction = peg$parseExpression;\n  var peg$c0 = \"+\";\n  var peg$c1 = \"-\";\n  var peg$c2 = \"*\";\n  var peg$c3 = \"/\";\n  var peg$c4 = \"**\";\n  var peg$c5 = \"(\";\n  var peg$c6 = \")\";\n  var peg$r0 = /^[\\-+]/;\n  var peg$r1 = /^[0-9]/;\n  var peg$r2 = /^[a-zA-Z_$]/;\n  var peg$r3 = /^[a-zA-Z_$0-9]/;\n  var peg$r4 = /^[ \\t\\n\\r]/;\n  var peg$e0 = peg$literalExpectation(\"+\", false);\n  var peg$e1 = peg$literalExpectation(\"-\", false);\n  var peg$e2 = peg$literalExpectation(\"*\", false);\n  var peg$e3 = peg$literalExpectation(\"/\", false);\n  var peg$e4 = peg$literalExpectation(\"**\", false);\n  var peg$e5 = peg$literalExpectation(\"(\", false);\n  var peg$e6 = peg$literalExpectation(\")\", false);\n  var peg$e7 = peg$otherExpectation(\"float\");\n  var peg$e8 = peg$otherExpectation(\"integer\");\n  var peg$e9 = peg$otherExpectation(\"identifier\");\n  var peg$e10 = peg$otherExpectation(\"whitespace\");\n  var peg$f0 = function(head, tail) {\n    var lhs = head;\n    var i, op;\n    for (i = 0; i < tail.length; i++) {\n      op = tail[i][1];\n      lhs = makeNode(lhs, tail[i][3], op);\n    }\n    return lhs;\n  };\n  var peg$f1 = function(head, tail) {\n    var lhs = head;\n    var i, op;\n    for (i = 0; i < tail.length; i++) {\n      op = tail[i][1];\n      lhs = makeNode(lhs, tail[i][3], op);\n    }\n    return lhs;\n  };\n  var peg$f2 = function(expr) {\n    return expr;\n  };\n  var peg$f3 = function(n, e) {\n    return { fn: n, lhs: e };\n  };\n  var peg$f4 = function() {\n    return parseFloat(text(), 10);\n  };\n  var peg$f5 = function() {\n    return parseInt(text(), 10);\n  };\n  var peg$f6 = function() {\n    return text();\n  };\n  var peg$currPos = 0;\n  var peg$savedPos = 0;\n  var peg$posDetailsCache = [{ line: 1, column: 1 }];\n  var peg$expected = [];\n  var peg$silentFails = 0;\n  var peg$result;\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(`Can't start parsing from rule \"` + options.startRule + '\".');\n    }\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n  function peg$literalExpectation(text2, ignoreCase) {\n    return { type: \"literal\", text: text2, ignoreCase };\n  }\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description };\n  }\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos];\n    var p;\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n        p++;\n      }\n      peg$posDetailsCache[pos] = details;\n      return details;\n    }\n  }\n  var peg$VALIDFILENAME = typeof options.filename === \"string\" && options.filename.length > 0;\n  function peg$computeLocation(startPos, endPos) {\n    var loc = {};\n    if (peg$VALIDFILENAME)\n      loc.filename = options.filename;\n    var startPosDetails = peg$computePosDetails(startPos);\n    loc.start = {\n      offset: startPos,\n      line: startPosDetails.line,\n      column: startPosDetails.column\n    };\n    var endPosDetails = peg$computePosDetails(endPos);\n    loc.end = {\n      offset: endPos,\n      line: endPosDetails.line,\n      column: endPosDetails.column\n    };\n    return loc;\n  }\n  function peg$begin() {\n    peg$expected.push({ pos: peg$currPos, variants: [] });\n  }\n  function peg$expect(expected2) {\n    var top = peg$expected[peg$expected.length - 1];\n    if (peg$currPos < top.pos) {\n      return;\n    }\n    if (peg$currPos > top.pos) {\n      top.pos = peg$currPos;\n      top.variants = [];\n    }\n    top.variants.push(expected2);\n  }\n  function peg$buildStructuredError(expected2, found, location2) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected2, found),\n      expected2,\n      found,\n      location2\n    );\n  }\n  function peg$buildError() {\n    var expected2 = peg$expected[0];\n    var failPos = expected2.pos;\n    return peg$buildStructuredError(\n      expected2.variants,\n      failPos < input.length ? input.charAt(failPos) : null,\n      failPos < input.length ? peg$computeLocation(failPos, failPos + 1) : peg$computeLocation(failPos, failPos)\n    );\n  }\n  function peg$parseExpression() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n    var rule$expects = function(expected2) {\n      if (peg$silentFails === 0)\n        peg$expect(expected2);\n    };\n    s0 = peg$currPos;\n    s1 = peg$parseTerm();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse_();\n      rule$expects(peg$e0);\n      if (input.charCodeAt(peg$currPos) === 43) {\n        s5 = peg$c0;\n        peg$currPos++;\n      } else {\n        s5 = peg$FAILED;\n      }\n      if (s5 === peg$FAILED) {\n        rule$expects(peg$e1);\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s5 = peg$c1;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n        }\n      }\n      if (s5 !== peg$FAILED) {\n        s6 = peg$parse_();\n        s7 = peg$parseTerm();\n        if (s7 !== peg$FAILED) {\n          s4 = [s4, s5, s6, s7];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        rule$expects(peg$e0);\n        if (input.charCodeAt(peg$currPos) === 43) {\n          s5 = peg$c0;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n        }\n        if (s5 === peg$FAILED) {\n          rule$expects(peg$e1);\n          if (input.charCodeAt(peg$currPos) === 45) {\n            s5 = peg$c1;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n          }\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse_();\n          s7 = peg$parseTerm();\n          if (s7 !== peg$FAILED) {\n            s4 = [s4, s5, s6, s7];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      peg$savedPos = s0;\n      s0 = peg$f0(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    return s0;\n  }\n  function peg$parseTerm() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n    var rule$expects = function(expected2) {\n      if (peg$silentFails === 0)\n        peg$expect(expected2);\n    };\n    s0 = peg$currPos;\n    s1 = peg$parseExponential();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse_();\n      rule$expects(peg$e2);\n      if (input.charCodeAt(peg$currPos) === 42) {\n        s5 = peg$c2;\n        peg$currPos++;\n      } else {\n        s5 = peg$FAILED;\n      }\n      if (s5 === peg$FAILED) {\n        rule$expects(peg$e3);\n        if (input.charCodeAt(peg$currPos) === 47) {\n          s5 = peg$c3;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n        }\n      }\n      if (s5 !== peg$FAILED) {\n        s6 = peg$parse_();\n        s7 = peg$parseExponential();\n        if (s7 !== peg$FAILED) {\n          s4 = [s4, s5, s6, s7];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        rule$expects(peg$e2);\n        if (input.charCodeAt(peg$currPos) === 42) {\n          s5 = peg$c2;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n        }\n        if (s5 === peg$FAILED) {\n          rule$expects(peg$e3);\n          if (input.charCodeAt(peg$currPos) === 47) {\n            s5 = peg$c3;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n          }\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse_();\n          s7 = peg$parseExponential();\n          if (s7 !== peg$FAILED) {\n            s4 = [s4, s5, s6, s7];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      peg$savedPos = s0;\n      s0 = peg$f1(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    return s0;\n  }\n  function peg$parseExponential() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n    var rule$expects = function(expected2) {\n      if (peg$silentFails === 0)\n        peg$expect(expected2);\n    };\n    s0 = peg$currPos;\n    s1 = peg$parseFactor();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse_();\n      rule$expects(peg$e4);\n      if (input.substr(peg$currPos, 2) === peg$c4) {\n        s5 = peg$c4;\n        peg$currPos += 2;\n      } else {\n        s5 = peg$FAILED;\n      }\n      if (s5 !== peg$FAILED) {\n        s6 = peg$parse_();\n        s7 = peg$parseFactor();\n        if (s7 !== peg$FAILED) {\n          s4 = [s4, s5, s6, s7];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parse_();\n        rule$expects(peg$e4);\n        if (input.substr(peg$currPos, 2) === peg$c4) {\n          s5 = peg$c4;\n          peg$currPos += 2;\n        } else {\n          s5 = peg$FAILED;\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse_();\n          s7 = peg$parseFactor();\n          if (s7 !== peg$FAILED) {\n            s4 = [s4, s5, s6, s7];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      peg$savedPos = s0;\n      s0 = peg$f1(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    return s0;\n  }\n  function peg$parseFactor() {\n    var s0, s1, s2, s3, s4, s5;\n    var rule$expects = function(expected2) {\n      if (peg$silentFails === 0)\n        peg$expect(expected2);\n    };\n    s0 = peg$currPos;\n    rule$expects(peg$e5);\n    if (input.charCodeAt(peg$currPos) === 40) {\n      s1 = peg$c5;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      s3 = peg$parseExpression();\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parse_();\n        rule$expects(peg$e6);\n        if (input.charCodeAt(peg$currPos) === 41) {\n          s5 = peg$c6;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n        }\n        if (s5 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f2(s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseFloat();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseInteger();\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseIdentifier();\n          if (s1 !== peg$FAILED) {\n            rule$expects(peg$e5);\n            if (input.charCodeAt(peg$currPos) === 40) {\n              s2 = peg$c5;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseExpression();\n              if (s3 !== peg$FAILED) {\n                rule$expects(peg$e6);\n                if (input.charCodeAt(peg$currPos) === 41) {\n                  s4 = peg$c6;\n                  peg$currPos++;\n                } else {\n                  s4 = peg$FAILED;\n                }\n                if (s4 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s0 = peg$f3(s1, s3);\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseIdentifier();\n          }\n        }\n      }\n    }\n    return s0;\n  }\n  function peg$parseFloat() {\n    var s0, s1, s2, s3, s4, s5;\n    var rule$expects = function(expected2) {\n      if (peg$silentFails === 0)\n        peg$expect(expected2);\n    };\n    rule$expects(peg$e7);\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$r0.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n    }\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      if (peg$r0.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n      }\n    }\n    s2 = [];\n    if (peg$r1.test(input.charAt(peg$currPos))) {\n      s3 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s3 = peg$FAILED;\n    }\n    if (s3 !== peg$FAILED) {\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        if (peg$r1.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n        }\n      }\n    } else {\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      if (input.length > peg$currPos) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        if (peg$r1.test(input.charAt(peg$currPos))) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n        }\n        if (s5 !== peg$FAILED) {\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            if (peg$r1.test(input.charAt(peg$currPos))) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n            }\n          }\n        } else {\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f4();\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    return s0;\n  }\n  function peg$parseInteger() {\n    var s0, s1, s2, s3;\n    var rule$expects = function(expected2) {\n      if (peg$silentFails === 0)\n        peg$expect(expected2);\n    };\n    rule$expects(peg$e8);\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$r0.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n    }\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      if (peg$r0.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n      }\n    }\n    s2 = [];\n    if (peg$r1.test(input.charAt(peg$currPos))) {\n      s3 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s3 = peg$FAILED;\n    }\n    if (s3 !== peg$FAILED) {\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        if (peg$r1.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n        }\n      }\n    } else {\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s0 = peg$f5();\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    return s0;\n  }\n  function peg$parseIdentifier() {\n    var s0, s1, s2, s3, s4;\n    var rule$expects = function(expected2) {\n      if (peg$silentFails === 0)\n        peg$expect(expected2);\n    };\n    rule$expects(peg$e9);\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$r0.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n    }\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      if (peg$r0.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n      }\n    }\n    if (peg$r2.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = [];\n      if (peg$r3.test(input.charAt(peg$currPos))) {\n        s4 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n      }\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        if (peg$r3.test(input.charAt(peg$currPos))) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n        }\n      }\n      peg$savedPos = s0;\n      s0 = peg$f6();\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    return s0;\n  }\n  function peg$parse_() {\n    var s0, s1;\n    var rule$expects = function(expected2) {\n      if (peg$silentFails === 0)\n        peg$expect(expected2);\n    };\n    rule$expects(peg$e10);\n    peg$silentFails++;\n    s0 = [];\n    if (peg$r4.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      if (peg$r4.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n      }\n    }\n    peg$silentFails--;\n    return s0;\n  }\n  function makeNode(lhs, rhs, op) {\n    if (typeof lhs === \"number\" && typeof rhs === \"number\") {\n      switch (op) {\n        case \"+\":\n          return lhs + rhs;\n        case \"-\":\n          return lhs - rhs;\n        case \"*\":\n          return lhs * rhs;\n        case \"/\":\n          return lhs / rhs;\n        case \"**\":\n          return Math.pow(lhs, rhs);\n      }\n    }\n    return {\n      lhs,\n      rhs,\n      op\n    };\n  }\n  peg$begin();\n  peg$result = peg$startRuleFunction();\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$expect(peg$endExpectation());\n    }\n    throw peg$buildError();\n  }\n}\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\nfunction defaultFor(arg, val) {\n  return typeof arg !== \"undefined\" ? arg : val;\n}\nfunction create3DContext(canvas, optAttribs) {\n  const names = [\"webgl\", \"experimental-webgl\"];\n  let context = null;\n  for (let ii = 0; ii < names.length; ++ii) {\n    try {\n      context = canvas.getContext(names[ii], optAttribs);\n    } catch (e) {\n    }\n    if (context) {\n      break;\n    }\n  }\n  if (!context || !context.getExtension(\"OES_texture_float\")) {\n    return null;\n  }\n  return context;\n}\nfunction createProgram(gl, vertexShaderSource2, fragmentShaderSource2) {\n  const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n  gl.shaderSource(vertexShader, vertexShaderSource2);\n  gl.compileShader(vertexShader);\n  if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n    throw new Error(gl.getShaderInfoLog(vertexShader));\n  }\n  const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n  gl.shaderSource(fragmentShader, fragmentShaderSource2);\n  gl.compileShader(fragmentShader);\n  if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n    throw new Error(gl.getShaderInfoLog(fragmentShader));\n  }\n  const program = gl.createProgram();\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n  return program;\n}\nfunction setRectangle(gl, x, y, width, height) {\n  const x1 = x;\n  const x2 = x + width;\n  const y1 = y;\n  const y2 = y + height;\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n    x1,\n    y1,\n    x2,\n    y1,\n    x1,\n    y2,\n    x1,\n    y2,\n    x2,\n    y1,\n    x2,\n    y2\n  ]), gl.STATIC_DRAW);\n}\nfunction createDataset(gl, id, data, width, height) {\n  let textureData;\n  if (gl) {\n    gl.viewport(0, 0, width, height);\n    textureData = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, textureData);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      0,\n      gl.LUMINANCE,\n      width,\n      height,\n      0,\n      gl.LUMINANCE,\n      gl.FLOAT,\n      new Float32Array(data)\n    );\n  }\n  return { textureData, width, height, data, id };\n}\nfunction destroyDataset(gl, dataset) {\n  if (gl) {\n    gl.deleteTexture(dataset.textureData);\n  }\n}\nfunction addColorScale(name, colors, positions) {\n  if (colors.length !== positions.length) {\n    throw new Error(\"Invalid color scale.\");\n  }\n  colorscales[name] = { colors, positions };\n}\nfunction renderColorScaleToCanvas(name, canvas, type = \"continuous\") {\n  const csDef = colorscales[name];\n  canvas.height = 1;\n  const ctx = canvas.getContext(\"2d\");\n  const width = 8192;\n  if (!ctx) {\n    throw new Error(\"Unable to get canvas context.\");\n  }\n  if (Object.prototype.toString.call(csDef) === \"[object Object]\") {\n    canvas.width = width;\n    if (type === \"continuous\") {\n      const gradient = ctx.createLinearGradient(0, 0, width, 1);\n      for (let i = 0; i < csDef.colors.length; ++i) {\n        gradient.addColorStop(csDef.positions[i], csDef.colors[i]);\n      }\n      ctx.fillStyle = gradient;\n      ctx.fillRect(0, 0, width, 1);\n    } else if (type === \"discrete\") {\n      for (let i = 0; i < csDef.colors.length; ++i) {\n        const nowPos = csDef.positions[i], lastPos = csDef.positions[i + 1];\n        const startPos = nowPos * (width - 10);\n        const endPos = lastPos ? lastPos * (width - 10) : width;\n        ctx.fillStyle = csDef.colors[i];\n        ctx.fillRect(startPos, 0, endPos - startPos, 1);\n      }\n    } else {\n      throw new Error(\"Invalid color scale type.\");\n    }\n  } else if (Object.prototype.toString.call(csDef) === \"[object Uint8Array]\") {\n    canvas.width = width;\n    const imgData = ctx.createImageData(width, 1);\n    imgData.data.set(csDef);\n    ctx.putImageData(imgData, 0, 0);\n  } else {\n    throw new Error(\"Color scale not defined.\");\n  }\n}\nconst vertexShaderSource = `\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nuniform mat3 u_matrix;\nuniform vec2 u_resolution;\nvarying vec2 v_texCoord;\nvoid main() {\n  // apply transformation matrix\n  vec2 position = (u_matrix * vec3(a_position, 1)).xy;\n  // convert the rectangle from pixels to 0.0 to 1.0\n  vec2 zeroToOne = position / u_resolution;\n  // convert from 0->1 to 0->2\n  vec2 zeroToTwo = zeroToOne * 2.0;\n  // convert from 0->2 to -1->+1 (clipspace)\n  vec2 clipSpace = zeroToTwo - 1.0;\n  gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\n  // pass the texCoord to the fragment shader\n  // The GPU will interpolate this value between points.\n  v_texCoord = a_texCoord;\n}`;\nconst fragmentShaderSource = `\nprecision mediump float;\n// our texture\nuniform sampler2D u_textureData;\nuniform sampler2D u_textureScale;\nuniform vec2 u_textureSize;\nuniform vec2 u_domain;\nuniform vec2 u_display_range;\nuniform bool u_apply_display_range;\nuniform float u_noDataValue;\nuniform bool u_clampLow;\nuniform bool u_clampHigh;\n// the texCoords passed in from the vertex shader.\nvarying vec2 v_texCoord;\n\nbool isnan( float val ) {\n  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true;\n}\n\nvoid main() {\n  vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;\n  float value = texture2D(u_textureData, v_texCoord)[0];\n  if(value < -3.402823466e+38) // Check for possible NaN value\n    gl_FragColor = vec4(0.0, 0, 0, 0.0);\n  else if (value == u_noDataValue || isnan(value))\n    gl_FragColor = vec4(0.0, 0, 0, 0.0);\n  else if (u_apply_display_range && (value < u_display_range[0] || value >= u_display_range[1]))\n        gl_FragColor = vec4(0.0, 0, 0, 0.0);\n  else if ((!u_clampLow && value < u_domain[0]) || (!u_clampHigh && value > u_domain[1]))\n    gl_FragColor = vec4(0, 0, 0, 0);\n  else {\n    float normalisedValue = (value - u_domain[0]) / (u_domain[1] - u_domain[0]);\n    gl_FragColor = texture2D(u_textureScale, vec2(normalisedValue, 0));\n  }\n}`;\nclass plot {\n  canvas;\n  currentDataset;\n  datasetCollection;\n  gl;\n  program;\n  texCoordBuffer;\n  ctx;\n  displayRange;\n  applyDisplayRange;\n  matrix;\n  colorScaleImage;\n  domain;\n  colorScaleCanvas;\n  name;\n  clampLow;\n  clampHigh;\n  textureScale;\n  noDataValue;\n  expressionAst;\n  colorType = \"continuous\";\n  positionBuffer;\n  programCache = {};\n  constructor(options) {\n    this.datasetCollection = {};\n    this.currentDataset = null;\n    this.setCanvas(options.canvas);\n    this.setColorType(options.type);\n    if (defaultFor(options.useWebGL, true)) {\n      const gl = create3DContext(this.canvas, { premultipliedAlpha: false });\n      if (gl !== null) {\n        this.gl = gl;\n        this.program = createProgram(gl, vertexShaderSource, fragmentShaderSource);\n        gl.useProgram(this.program);\n        const texCoordLocation = gl.getAttribLocation(this.program, \"a_texCoord\");\n        this.texCoordBuffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n          0,\n          0,\n          1,\n          0,\n          0,\n          1,\n          0,\n          1,\n          1,\n          0,\n          1,\n          1\n        ]), gl.STATIC_DRAW);\n        gl.enableVertexAttribArray(texCoordLocation);\n        gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);\n        this.positionBuffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n          0,\n          0,\n          1,\n          0,\n          0,\n          1,\n          0,\n          1,\n          1,\n          0,\n          1,\n          1\n        ]), gl.STATIC_DRAW);\n        const positionLocation = gl.getAttribLocation(this.program, \"a_position\");\n        gl.enableVertexAttribArray(positionLocation);\n        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n      } else {\n        this.ctx = this.canvas.getContext(\"2d\");\n      }\n    } else {\n      this.ctx = this.canvas.getContext(\"2d\");\n    }\n    if (options.colorScaleImage) {\n      this.setColorScaleImage(options.colorScaleImage);\n    } else {\n      this.setColorScale(defaultFor(options.colorScale, \"viridis\"));\n    }\n    this.setDomain(defaultFor(options.domain, [0, 1]));\n    this.displayRange = defaultFor(options.displayRange, [0, 1]);\n    this.applyDisplayRange = defaultFor(options.applyDisplayRange, false);\n    this.setClamp(defaultFor(options.clampLow, true), options.clampHigh);\n    this.setNoDataValue(options.noDataValue);\n    if (options.data) {\n      const l = options.data.length;\n      this.setData(\n        options.data,\n        defaultFor(options.width, options.data[l - 2]),\n        defaultFor(options.height, options.data[l - 2])\n      );\n    }\n    if (options.datasets) {\n      for (let i = 0; i < options.datasets.length; ++i) {\n        const ds = options.datasets[i];\n        this.addDataset(ds.id, ds.data, ds.width, ds.height);\n      }\n    }\n    if (options.matrix) {\n      this.matrix = options.matrix;\n    } else {\n      this.matrix = [\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      ];\n    }\n  }\n  /**\n   * Get the raw data from the currently selected dataset.\n   * @returns {TypedArray} the data of the currently selected dataset.\n   */\n  getData() {\n    const dataset = this.currentDataset;\n    if (!dataset) {\n      throw new Error(\"No dataset available.\");\n    }\n    return dataset.data;\n  }\n  /**\n   * Query the raw raster data at the specified coordinates.\n   * @param {Number} x the x coordinate\n   * @param {Number} y the y coordinate\n   * @returns {Number} the value at the specified coordinates\n   */\n  atPoint(x, y) {\n    const dataset = this.currentDataset;\n    if (!dataset) {\n      throw new Error(\"No dataset available.\");\n    } else if (x >= dataset.width || y >= dataset.height) {\n      throw new Error(\"Coordinates are outside of image bounds.\");\n    }\n    return dataset.data[y * dataset.width + x];\n  }\n  /**\n   * Set the raw raster data to be rendered. This creates a new unnamed dataset.\n   * @param {TypedArray} data the raw raster data. This can be a typed array of\n   *                          any type, but will be coerced to Float32Array when\n   *                          beeing rendered.\n   * @param {number} width the width of the raster image\n   * @param {number} height the height of the data\n   */\n  setData(data, width, height) {\n    if (this.currentDataset && this.currentDataset.id === null) {\n      destroyDataset(this.gl, this.currentDataset);\n    }\n    this.currentDataset = createDataset(this.gl, null, data, width, height);\n  }\n  /**\n   * Add a new named dataset. The semantics are the same as with @see setData.\n   * @param {string} id the identifier for the dataset.\n   * @param {TypedArray} data the raw raster data. This can be a typed array of\n   *                          any type, but will be coerced to Float32Array when\n   *                          beeing rendered.\n   * @param {number} width the width of the raster image\n   * @param {number} height the height of the data\n   */\n  addDataset(id, data, width, height) {\n    if (this.datasetAvailable(id)) {\n      throw new Error(`There is already a dataset registered with id '${id}'`);\n    }\n    this.datasetCollection[id] = createDataset(this.gl, id, data, width, height);\n    if (!this.currentDataset) {\n      this.currentDataset = this.datasetCollection[id];\n    }\n  }\n  /**\n   * Set the current dataset to be rendered.\n   * @param {string} id the identifier of the dataset to be rendered.\n   */\n  setCurrentDataset(id) {\n    if (!this.datasetAvailable(id)) {\n      throw new Error(`No such dataset registered: '${id}'`);\n    }\n    if (this.currentDataset && this.currentDataset.id === null) {\n      destroyDataset(this.gl, this.currentDataset);\n    }\n    this.currentDataset = this.datasetCollection[id];\n  }\n  /**\n   * Remove the dataset.\n   * @param {string} id the identifier of the dataset to be removed.\n   */\n  removeDataset(id) {\n    const dataset = this.datasetCollection[id];\n    if (!dataset) {\n      throw new Error(`No such dataset registered: '${id}'`);\n    }\n    destroyDataset(this.gl, dataset);\n    if (this.currentDataset === dataset) {\n      this.currentDataset = null;\n    }\n    delete this.datasetCollection[id];\n  }\n  removeAllDataset() {\n    Object.keys(this.datasetCollection).forEach((id) => this.removeDataset(id));\n  }\n  /**\n   * Check if the dataset is available.\n   * @param {string} id the identifier of the dataset to check.\n   * @returns {Boolean} whether or not a dataset with that identifier is defined\n   */\n  datasetAvailable(id) {\n    return hasOwnProperty(this.datasetCollection, id);\n  }\n  /**\n   * Retrieve the rendered color scale image.\n   * @returns {(HTMLCanvasElement|HTMLImageElement)} the canvas or image element\n   *                                                 for the rendered color scale\n   */\n  getColorScaleImage() {\n    return this.colorScaleImage;\n  }\n  /**\n   * Set the canvas to draw to. When no canvas is supplied, a new canvas element\n   * is created.\n   * @param {HTMLCanvasElement | OffscreenCanvas} [canvas] the canvas element to render to.\n   */\n  setCanvas(canvas) {\n    this.canvas = canvas || document.createElement(\"canvas\");\n  }\n  setColorType(type) {\n    this.colorType = type ?? \"continuous\";\n  }\n  /**\n   * Set the new value domain for the rendering.\n   * @param {number[]} domain the value domain range in the form [low, high]\n   */\n  setDomain(domain) {\n    if (!domain || domain.length !== 2) {\n      throw new Error(\"Invalid domain specified.\");\n    }\n    this.domain = domain;\n  }\n  /**\n   * Set the display range that will be rendered, values outside of the range\n   * will not be rendered (transparent)\n   * @param {number[]} displayRange range array in the form [min, max]\n   */\n  setDisplayRange(displayRange) {\n    if (!displayRange || displayRange.length !== 2) {\n      throw new Error(\"Invalid view range specified.\");\n    }\n    this.displayRange = displayRange;\n    this.applyDisplayRange = true;\n  }\n  /**\n   * Get the canvas that is currently rendered to.\n   * @returns {HTMLCanvasElement} the canvas that is currently rendered to.\n   */\n  getCanvas() {\n    return this.canvas;\n  }\n  /**\n   * Set the currently selected color scale.\n   * @param {ColorScaleNames} name the name of the colorscale. Must be registered.\n   */\n  setColorScale(name) {\n    if (!hasOwnProperty(colorscales, name)) {\n      throw new Error(`No such color scale '${name}'`);\n    }\n    if (!this.colorScaleCanvas) {\n      this.colorScaleCanvas = document.createElement(\"canvas\");\n      this.colorScaleCanvas.width = 256;\n      this.colorScaleCanvas.height = 1;\n    }\n    renderColorScaleToCanvas(name, this.colorScaleCanvas, this.colorType);\n    this.name = name;\n    this.setColorScaleImage(this.colorScaleCanvas);\n  }\n  /**\n   * Set the clamping for the lower and the upper border of the values. When\n   * clamping is enabled for either side, the values below or above will be\n   * clamped to the minimum/maximum color.\n   * @param {Boolean} clampLow whether or not the minimum shall be clamped.\n   * @param {Boolean} clampHigh whether or not the maxmimum shall be clamped.\n   *                            defaults to clampMin.\n   */\n  setClamp(clampLow, clampHigh) {\n    this.clampLow = clampLow;\n    this.clampHigh = typeof clampHigh !== \"undefined\" ? clampHigh : clampLow;\n  }\n  /**\n   * Set the currently selected color scale as an image or canvas.\n   * @param {(HTMLCanvasElement|HTMLImageElement)} colorScaleImage the new color\n   *                                                               scale image\n   */\n  setColorScaleImage(colorScaleImage) {\n    this.colorScaleImage = colorScaleImage;\n    const gl = this.gl;\n    if (gl) {\n      if (this.textureScale) {\n        gl.deleteTexture(this.textureScale);\n      }\n      this.textureScale = gl.createTexture();\n      gl.bindTexture(gl.TEXTURE_2D, this.textureScale);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, colorScaleImage);\n    }\n  }\n  /**\n   * Set the no-data-value: a special value that will be rendered transparent.\n   * @param {number} noDataValue the no-data-value. Use null to clear a\n   *                            previously set no-data-value.\n   */\n  setNoDataValue(noDataValue) {\n    this.noDataValue = noDataValue;\n  }\n  /**\n   * Render the map to the specified canvas with the given settings.\n   */\n  render() {\n    const canvas = this.canvas;\n    const dataset = this.currentDataset;\n    canvas.width = dataset.width;\n    canvas.height = dataset.height;\n    let ids = this.getExpressionIds();\n    if (this.gl) {\n      this.renderWebGL(dataset, ids);\n    } else if (this.ctx) {\n      this.render2D(dataset);\n    }\n  }\n  getExpressionIds() {\n    if (!this.expressionAst)\n      return null;\n    const idsSet = /* @__PURE__ */ new Set();\n    const getIds = (node) => {\n      if (typeof node === \"string\") {\n        idsSet.add(node.replace(/[+-]/g, \"\"));\n      }\n      if (typeof node.lhs === \"string\") {\n        idsSet.add(node.lhs.replace(/[+-]/g, \"\"));\n      } else if (typeof node.lhs === \"object\") {\n        getIds(node.lhs);\n      }\n      if (typeof node.rhs === \"string\") {\n        idsSet.add(node.rhs.replace(/[+-]/g, \"\"));\n      } else if (typeof node.rhs === \"object\") {\n        getIds(node.rhs);\n      }\n    };\n    getIds(this.expressionAst);\n    return Array.from(idsSet);\n  }\n  renderWebGL(dataset, ids) {\n    const gl = this.gl;\n    gl.viewport(0, 0, dataset.width, dataset.height);\n    const program = this.getOrCreateProgram(ids);\n    gl.useProgram(program);\n    this.setupTextures(program, ids, dataset);\n    this.setupUniforms(program);\n    this.setupAttributes(program);\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n  }\n  getOrCreateProgram(ids) {\n    if (!this.expressionAst) {\n      return this.program;\n    }\n    const exprKey = JSON.stringify(this.expressionAst);\n    if (this.programCache[exprKey]) {\n      return this.programCache[exprKey];\n    }\n    const vertexShader = this.createVertexShader();\n    const fragmentShader = this.createFragmentShader(ids);\n    const program = createProgram(this.gl, vertexShader, fragmentShader);\n    this.programCache[exprKey] = program;\n    return program;\n  }\n  createVertexShader() {\n    return `\n      attribute vec2 a_position;\n      attribute vec2 a_texCoord;\n      uniform mat3 u_matrix;\n      uniform vec2 u_resolution;\n      varying vec2 v_texCoord;\n      void main() {\n        vec2 position = (u_matrix * vec3(a_position, 1)).xy;\n        vec2 zeroToOne = position / u_resolution;\n        vec2 zeroToTwo = zeroToOne * 2.0;\n        vec2 clipSpace = zeroToTwo - 1.0;\n        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\n        v_texCoord = a_texCoord;\n      }\n    `;\n  }\n  createFragmentShader(ids) {\n    if (!ids) {\n      return fragmentShaderSource;\n    }\n    const expressionReducer = (node) => {\n      if (typeof node === \"object\") {\n        if (node.op === \"**\") {\n          return `pow(${expressionReducer(node.lhs)}, ${expressionReducer(node.rhs)})`;\n        }\n        if (node.fn) {\n          return `(${node.fn}(${expressionReducer(node.lhs)}))`;\n        }\n        return `(${expressionReducer(node.lhs)} ${node.op} ${expressionReducer(node.rhs)})`;\n      } else if (typeof node === \"string\") {\n        return `${node}_value`;\n      }\n      return `float(${node})`;\n    };\n    const compiledExpression = expressionReducer(this.expressionAst);\n    return `\n      precision mediump float;\n      uniform sampler2D u_textureScale;\n      ${ids.map((id) => `uniform sampler2D u_texture_${id};`).join(\"\\n\")}\n      uniform vec2 u_textureSize;\n      uniform vec2 u_domain;\n      uniform vec2 u_display_range;\n      uniform bool u_apply_display_range;\n      uniform float u_noDataValue;\n      uniform bool u_clampLow;\n      uniform bool u_clampHigh;\n      varying vec2 v_texCoord;\n      void main() {\n        ${ids.map((id) => `float ${id}_value = texture2D(u_texture_${id}, v_texCoord)[0];`).join(\"\\n\")}\n        float value = ${compiledExpression};\n\n        if (value == u_noDataValue)\n          gl_FragColor = vec4(0.0, 0, 0, 0.0);\n        else if (u_apply_display_range && (value < u_display_range[0] || value >= u_display_range[1]))\n          gl_FragColor = vec4(0.0, 0, 0, 0.0);\n        else if ((!u_clampLow && value < u_domain[0]) || (!u_clampHigh && value > u_domain[1]))\n          gl_FragColor = vec4(0, 0, 0, 0);\n        else {\n          float normalisedValue = (value - u_domain[0]) / (u_domain[1] - u_domain[0]);\n          gl_FragColor = texture2D(u_textureScale, vec2(normalisedValue, 0));\n        }\n      }\n    `;\n  }\n  setupTextures(program, ids, dataset) {\n    const gl = this.gl;\n    if (ids) {\n      gl.uniform1i(gl.getUniformLocation(program, \"u_textureScale\"), 0);\n      gl.activeTexture(gl.TEXTURE0);\n      gl.bindTexture(gl.TEXTURE_2D, this.textureScale);\n      ids.forEach((id, index) => {\n        const location = index + 1;\n        const ds = this.datasetCollection[id];\n        if (!ds) {\n          throw new Error(`No such dataset registered: '${id}'`);\n        }\n        gl.uniform1i(gl.getUniformLocation(program, `u_texture_${id}`), location);\n        gl.activeTexture(gl[`TEXTURE${location}`]);\n        gl.bindTexture(gl.TEXTURE_2D, ds.textureData);\n      });\n    } else {\n      gl.uniform1i(gl.getUniformLocation(program, \"u_textureData\"), 0);\n      gl.uniform1i(gl.getUniformLocation(program, \"u_textureScale\"), 1);\n      gl.activeTexture(gl.TEXTURE0);\n      gl.bindTexture(gl.TEXTURE_2D, dataset.textureData);\n      gl.activeTexture(gl.TEXTURE1);\n      gl.bindTexture(gl.TEXTURE_2D, this.textureScale);\n    }\n  }\n  setupUniforms(program) {\n    const gl = this.gl;\n    const canvas = this.canvas;\n    gl.uniform2f(gl.getUniformLocation(program, \"u_resolution\"), canvas.width, canvas.height);\n    gl.uniform2fv(gl.getUniformLocation(program, \"u_domain\"), this.domain);\n    gl.uniform2fv(gl.getUniformLocation(program, \"u_display_range\"), this.displayRange);\n    gl.uniform1i(gl.getUniformLocation(program, \"u_apply_display_range\"), +this.applyDisplayRange);\n    gl.uniform1i(gl.getUniformLocation(program, \"u_clampLow\"), +this.clampLow);\n    gl.uniform1i(gl.getUniformLocation(program, \"u_clampHigh\"), +this.clampHigh);\n    gl.uniform1f(gl.getUniformLocation(program, \"u_noDataValue\"), this.noDataValue);\n    gl.uniformMatrix3fv(gl.getUniformLocation(program, \"u_matrix\"), false, this.matrix);\n  }\n  setupAttributes(program) {\n    const gl = this.gl;\n    const canvas = this.canvas;\n    const positionLocation = gl.getAttribLocation(program, \"a_position\");\n    const positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.enableVertexAttribArray(positionLocation);\n    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n    setRectangle(gl, 0, 0, canvas.width, canvas.height);\n  }\n  render2D(dataset) {\n    const ctx = this.ctx;\n    const w = this.canvas.width;\n    const h = this.canvas.height;\n    const imageData = ctx.createImageData(w, h);\n    const trange = this.domain[1] - this.domain[0];\n    const steps = this.colorScaleCanvas.width;\n    const csImageData = this.colorScaleCanvas.getContext(\"2d\").getImageData(0, 0, steps, 1).data;\n    let alpha;\n    const data = dataset.data;\n    for (let y = 0; y < h; y++) {\n      for (let x = 0; x < w; x++) {\n        const i = y * w + x;\n        let c = Math.floor((data[i] - this.domain[0]) / trange * (steps - 1));\n        alpha = 255;\n        if (c < 0) {\n          c = 0;\n          if (!this.clampLow) {\n            alpha = 0;\n          }\n        } else if (c > 255) {\n          c = 255;\n          if (!this.clampHigh) {\n            alpha = 0;\n          }\n        }\n        if (data[i] === this.noDataValue || data[i] !== data[i]) {\n          alpha = 0;\n        } else if (this.applyDisplayRange && (data[i] < this.displayRange[0] || data[i] >= this.displayRange[1])) {\n          alpha = 0;\n        }\n        const index = (y * w + x) * 4;\n        imageData.data[index + 0] = csImageData[c * 4];\n        imageData.data[index + 1] = csImageData[c * 4 + 1];\n        imageData.data[index + 2] = csImageData[c * 4 + 2];\n        imageData.data[index + 3] = Math.min(alpha, csImageData[c * 4 + 3]);\n      }\n    }\n    ctx.putImageData(imageData, 0, 0);\n  }\n  /**\n   * Render the specified dataset with the current settings.\n   * @param {string} id the identifier of the dataset to render.\n   */\n  renderDataset(id) {\n    this.setCurrentDataset(id);\n    return this.render();\n  }\n  /**\n   * Get the color for the specified value.\n   * @param {number} val the value to query the color for.\n   * @returns {Array} the 4-tuple: red, green, blue, alpha in the range 0-255.\n   */\n  getColor(val) {\n    const steps = this.colorScaleCanvas.width;\n    const csImageData = this.colorScaleCanvas.getContext(\"2d\").getImageData(0, 0, steps, 1).data;\n    const trange = this.domain[1] - this.domain[0];\n    let c = Math.round((val - this.domain[0]) / trange * steps);\n    let alpha = 255;\n    if (c < 0) {\n      c = 0;\n      if (!this.clampLow) {\n        alpha = 0;\n      }\n    }\n    if (c > 255) {\n      c = 255;\n      if (!this.clampHigh) {\n        alpha = 0;\n      }\n    }\n    return [\n      csImageData[c * 4],\n      csImageData[c * 4 + 1],\n      csImageData[c * 4 + 2],\n      alpha\n    ];\n  }\n  /**\n   * Sets a mathematical expression to be evaluated on the plot. Expression can contain mathematical operations with integer/float values, dataset identifiers or GLSL supported functions with a single parameter.\n   * Supported mathematical operations are: add '+', subtract '-', multiply '*', divide '/', power '**', unary plus '+a', unary minus '-a'.\n   * Useful GLSL functions are for example: radians, degrees, sin, asin, cos, acos, tan, atan, log2, log, sqrt, exp2, exp, abs, sign, floor, ceil, fract.\n   * @param {string} expression Mathematical expression. Example: '-2 * sin(3.1415 - dataset1) ** 2'\n   */\n  setExpression(expression) {\n    if (!expression || !expression.length) {\n      this.expressionAst = null;\n    } else {\n      this.expressionAst = peg$parse(expression);\n    }\n  }\n  destroy() {\n    var _a;\n    (_a = this.gl) == null ? void 0 : _a.deleteProgram(this.program);\n    this.removeAllDataset();\n  }\n}\n\nfunction getMinMax(data, nodata) {\n  let min, max;\n  for (let j = 0; j < data.length; j += 1) {\n    const val = data[j];\n    if (val === nodata)\n      continue;\n    if (min === void 0 && max === void 0) {\n      min = max = val;\n      continue;\n    }\n    if (val < min) {\n      min = val;\n    } else if (val > max) {\n      max = val;\n    }\n  }\n  return {\n    min,\n    max\n  };\n}\nfunction decimal2rgb(number) {\n  return Math.round(number * 255);\n}\nfunction getRange(bands, opts) {\n  const band = bands[opts.band];\n  if (!band) {\n    throw new Error(`Invalid band${opts.band}`);\n  }\n  const min = (opts == null ? void 0 : opts.min) ?? +band.min;\n  const max = (opts == null ? void 0 : opts.max) ?? +band.max;\n  const range = max - min;\n  return { min, max, range };\n}\nfunction generateColorScale(colors, minMax) {\n  let stops;\n  if (typeof colors[0] === \"string\") {\n    stops = colors.map((color, index) => [index / colors.length, color]);\n  } else {\n    const [min, max] = minMax;\n    stops = colors.map((item) => [(item[0] - min) / (max - min), item[1]]);\n  }\n  stops.sort((a, b) => a[0] - b[0]);\n  let i = stops.length - 1;\n  while (i > 1 && stops[i][0] >= 1 && stops[i - 1][0] >= 1) {\n    stops.pop();\n    i--;\n  }\n  if (stops[0][0] > 0) {\n    stops = [[0, stops[0][1]], ...stops];\n  }\n  const colorScale = {\n    colors: stops.map((stop) => stop[1]),\n    positions: stops.map((stop) => {\n      let s = stop[0];\n      if (s < 0)\n        return 0;\n      if (s > 1)\n        return 1;\n      return s;\n    })\n  };\n  return colorScale;\n}\nfunction findAndSortBandNumbers(str) {\n  const regex = /b(\\d+)/g;\n  const bandNumbers = /* @__PURE__ */ new Set();\n  let match;\n  while ((match = regex.exec(str)) !== null) {\n    bandNumbers.add(parseInt(match[1]) - 1);\n  }\n  return Array.from(bandNumbers).sort((a, b) => a - b);\n}\nfunction stringColorToRgba(color) {\n  const newColor = terriajs_cesium__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromCssColorString(color);\n  const { red, green, blue, alpha } = newColor;\n  return [red, green, blue, alpha].map((val) => Math.round(val * 255));\n}\nfunction reverseArray(options) {\n  const { array, width, height } = options;\n  const reversedArray = [];\n  for (let row = height - 1; row >= 0; row--) {\n    const startIndex = row * width;\n    const endIndex = startIndex + width;\n    const rowArray = array.slice(startIndex, endIndex);\n    reversedArray.push(...rowArray);\n  }\n  return reversedArray;\n}\n\nclass TIFFImageryProviderTilingScheme extends terriajs_cesium__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  nativeRectangle;\n  constructor(options) {\n    super(options);\n    const { project, unproject } = options;\n    this.nativeRectangle = new terriajs_cesium__WEBPACK_IMPORTED_MODULE_2__[\"default\"](options.rectangleSouthwestInMeters.x, options.rectangleSouthwestInMeters.y, options.rectangleNortheastInMeters.x, options.rectangleNortheastInMeters.y);\n    this._projection = {\n      ellipsoid: this.ellipsoid,\n      project(cartographic, result) {\n        const [x, y] = project([cartographic.longitude, cartographic.latitude].map(terriajs_cesium__WEBPACK_IMPORTED_MODULE_3__[\"default\"].toDegrees));\n        const z = cartographic.height;\n        return terriajs_cesium__WEBPACK_IMPORTED_MODULE_4__[\"default\"].fromElements(x, y, z, result);\n      },\n      unproject(cartesian, result) {\n        const [longitude, latitude] = unproject([cartesian.x, cartesian.y]);\n        const height = cartesian.z;\n        return terriajs_cesium__WEBPACK_IMPORTED_MODULE_5__[\"default\"].fromDegrees(longitude, latitude, height, result);\n      }\n    };\n    const swMeters = new terriajs_cesium__WEBPACK_IMPORTED_MODULE_4__[\"default\"]();\n    options.rectangleSouthwestInMeters.clone(swMeters);\n    const neMeters = new terriajs_cesium__WEBPACK_IMPORTED_MODULE_4__[\"default\"]();\n    options.rectangleNortheastInMeters.clone(neMeters);\n    const seMeters = new terriajs_cesium__WEBPACK_IMPORTED_MODULE_4__[\"default\"](neMeters.x, swMeters.y);\n    const nwMeters = new terriajs_cesium__WEBPACK_IMPORTED_MODULE_4__[\"default\"](swMeters.x, neMeters.y);\n    const southwest = this.projection.unproject(swMeters);\n    const southeast = this.projection.unproject(seMeters);\n    const northwest = this.projection.unproject(nwMeters);\n    const northeast = this.projection.unproject(neMeters);\n    this._rectangle = terriajs_cesium__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fromCartographicArray([southwest, southeast, northwest, northeast]);\n  }\n  tileXYToNativeRectangle2(x, y, level) {\n    const rect = this.tileXYToRectangle(x, y, level);\n    const projection = this.projection;\n    const ws = projection.project(new terriajs_cesium__WEBPACK_IMPORTED_MODULE_5__[\"default\"](rect.west, rect.south));\n    const wn = projection.project(new terriajs_cesium__WEBPACK_IMPORTED_MODULE_5__[\"default\"](rect.west, rect.north));\n    const en = projection.project(new terriajs_cesium__WEBPACK_IMPORTED_MODULE_5__[\"default\"](rect.east, rect.north));\n    const es = projection.project(new terriajs_cesium__WEBPACK_IMPORTED_MODULE_5__[\"default\"](rect.east, rect.south));\n    const positions = [ws, wn, en, es];\n    const xx = positions.map((pos) => pos.x);\n    const yy = positions.map((pos) => pos.y);\n    return new terriajs_cesium__WEBPACK_IMPORTED_MODULE_2__[\"default\"](\n      Math.min(...xx),\n      Math.min(...yy),\n      Math.max(...xx),\n      Math.max(...yy)\n    );\n  }\n  tileXYToRectangle(x, y, level) {\n    const rect = this.tileXYToNativeRectangle(x, y, level);\n    const projection = this.projection;\n    const ws = projection.unproject(new terriajs_cesium__WEBPACK_IMPORTED_MODULE_4__[\"default\"](rect.west, rect.south));\n    const wn = projection.unproject(new terriajs_cesium__WEBPACK_IMPORTED_MODULE_4__[\"default\"](rect.west, rect.north));\n    const en = projection.unproject(new terriajs_cesium__WEBPACK_IMPORTED_MODULE_4__[\"default\"](rect.east, rect.north));\n    const es = projection.unproject(new terriajs_cesium__WEBPACK_IMPORTED_MODULE_4__[\"default\"](rect.east, rect.south));\n    const newRect = terriajs_cesium__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fromCartographicArray([ws, wn, en, es]);\n    if (newRect.east < newRect.west) {\n      newRect.east += terriajs_cesium__WEBPACK_IMPORTED_MODULE_3__[\"default\"].TWO_PI;\n    }\n    return newRect;\n  }\n}\n\nfunction resampleNearest(data, options) {\n  const { sourceWidth, sourceHeight, targetWidth, targetHeight, window, buffer = 0 } = options;\n  const [x0, y0, x1, y1] = window;\n  const effectiveSourceWidth = sourceWidth - 2 * buffer;\n  const effectiveSourceHeight = sourceHeight - 2 * buffer;\n  const resampledData = copyNewSize(data, targetWidth, targetHeight);\n  for (let y = 0; y < targetHeight; y++) {\n    for (let x = 0; x < targetWidth; x++) {\n      const col = buffer + (effectiveSourceWidth * (x0 + x / targetWidth * (x1 - x0)) >>> 0);\n      const row = buffer + (effectiveSourceHeight * (y0 + y / targetHeight * (y1 - y0)) >>> 0);\n      resampledData[y * targetWidth + x] = data[row * sourceWidth + col];\n    }\n  }\n  return resampledData;\n}\nfunction resampleData(data, options) {\n  const { method = \"nearest\" } = options;\n  switch (method) {\n    case \"nearest\":\n      return resampleNearest(data, options);\n    case \"bilinear\":\n      return resampleBilinear(data, options);\n  }\n}\nfunction copyNewSize(array, width, height, samplesPerPixel = 1) {\n  return new (Object.getPrototypeOf(array)).constructor(width * height * samplesPerPixel);\n}\nfunction lerp(v0, v1, t) {\n  return (1 - t) * v0 + t * v1;\n}\nfunction resampleBilinear(data, options) {\n  const { sourceWidth, sourceHeight, targetWidth, targetHeight, window, buffer = 0, nodata } = options;\n  const [x0, y0, x1, y1] = window;\n  const windowWidth = x1 - x0;\n  const windowHeight = y1 - y0;\n  const newArray = copyNewSize(data, targetWidth, targetHeight);\n  const effectiveSourceWidth = sourceWidth - 2 * buffer;\n  const effectiveSourceHeight = sourceHeight - 2 * buffer;\n  const invTargetWidth = 1 / targetWidth;\n  const invTargetHeight = 1 / targetHeight;\n  const isNodata = (value) => {\n    if (nodata === void 0)\n      return false;\n    if (nodata === 0)\n      return value === 0;\n    return Math.abs((value - nodata) / nodata) < 1e-6;\n  };\n  for (let y = 0; y < targetHeight; y++) {\n    const yRatio = y * invTargetHeight;\n    const yMapped = y0 + yRatio * windowHeight;\n    const rawY = effectiveSourceHeight * yMapped + buffer;\n    const yl = Math.floor(rawY);\n    const yh = Math.min(Math.ceil(rawY), sourceHeight - buffer - 1);\n    const ty = rawY - yl;\n    for (let x = 0; x < targetWidth; x++) {\n      const xRatio = x * invTargetWidth;\n      const xMapped = x0 + xRatio * windowWidth;\n      const rawX = effectiveSourceWidth * xMapped + buffer;\n      const xl = Math.floor(rawX);\n      const xh = Math.min(Math.ceil(rawX), sourceWidth - buffer - 1);\n      const txFraction = rawX - xl;\n      const center = data[yl * sourceWidth + xl];\n      const neighbors = [\n        data[yl * sourceWidth + xl],\n        data[yl * sourceWidth + xh],\n        data[yh * sourceWidth + xl],\n        data[yh * sourceWidth + xh]\n      ];\n      neighbors.forEach((neighbor, index) => {\n        if (isNodata(neighbor)) {\n          neighbors[index] = center;\n        }\n      });\n      if (isNodata(center)) {\n        newArray[y * targetWidth + x] = nodata;\n        continue;\n      }\n      const [ll, hl, lh, hh] = neighbors;\n      const v0 = lerp(ll, hl, txFraction);\n      const v1 = lerp(lh, hh, txFraction);\n      const value = lerp(v0, v1, ty);\n      newArray[y * targetWidth + x] = value;\n    }\n  }\n  return newArray;\n}\n\nfunction inRange(val, range) {\n  if (val < range[0] && val < range[1] || val > range[0] && val > range[1]) {\n    return false;\n  } else {\n    return true;\n  }\n}\nfunction reprojection(options) {\n  const { data, sourceBBox, targetBBox, project, sourceWidth, sourceHeight, nodata } = options;\n  const { targetWidth = sourceWidth, targetHeight = sourceHeight } = options;\n  const [minX, minY, maxX, maxY] = sourceBBox;\n  const [minLon, minLat, maxLon, maxLat] = targetBBox;\n  const stepX = Math.abs(maxX - minX) / sourceWidth;\n  const stepY = Math.abs(maxY - minY) / sourceHeight;\n  const stepLon = Math.abs(maxLon - minLon) / targetWidth;\n  const stepLat = Math.abs(maxLat - minLat) / targetHeight;\n  const result = copyNewSize(data, targetWidth, targetHeight).fill(nodata);\n  for (let i = 0; i < targetHeight; i++) {\n    for (let j = 0; j < targetWidth; j++) {\n      const lon = minLon + stepLon * (j + 0.5);\n      const lat = maxLat - stepLat * (i + 0.5);\n      const [x, y] = project([lon, lat]);\n      if (!inRange(x, [minX, maxX]) || !inRange(y, [minX, maxY])) {\n        break;\n      }\n      const indexX = ~~((x - minX) / stepX);\n      const indexY = ~~((maxY - y) / stepY);\n      const sourceVal = data[indexY * sourceWidth + indexX];\n      const index = i * targetWidth + j;\n      result[index] = sourceVal;\n    }\n  }\n  return result;\n}\n\nasync function generateImage(opts) {\n  const { data, width, height, renderOptions, bands, noData, colorMapping } = opts;\n  const imageData = new Uint8ClampedArray(width * height * 4);\n  function ifNoDataFunc(...vals) {\n    if (vals.some((val) => isNaN(val) || val === noData))\n      return true;\n    return false;\n  }\n  const { r, g, b } = renderOptions ?? {};\n  const ranges = [r, g, b].map((item) => getRange(bands, item));\n  const redData = data[0];\n  const greenData = data[1];\n  const blueData = data[2];\n  for (let i = 0; i < data[0].length; i++) {\n    let red = decimal2rgb((redData[i] - ranges[0].min) / ranges[0].range);\n    let green = decimal2rgb((greenData[i] - ranges[1].min) / ranges[1].range);\n    let blue = decimal2rgb((blueData[i] - ranges[2].min) / ranges[2].range);\n    let alpha = ifNoDataFunc(redData[i], greenData[i], blueData[i]) ? 0 : 255;\n    colorMapping.map(([colorFrom, colorTo]) => {\n      if (red === colorFrom[0] && green === colorFrom[1] && blue === colorFrom[2]) {\n        red = colorTo[0];\n        green = colorTo[1];\n        blue = colorTo[2];\n        alpha = colorTo[3];\n      }\n    });\n    imageData[i * 4] = red;\n    imageData[i * 4 + 1] = green;\n    imageData[i * 4 + 2] = blue;\n    imageData[i * 4 + 3] = alpha;\n  }\n  const result = new ImageData(imageData, width, height);\n  return result;\n}\n\nfunction createCanavas(width, height) {\n  if (\"OffscreenCanvas\" in window) {\n    return new OffscreenCanvas(width, height);\n  } else {\n    const canv = document.createElement(\"canvas\");\n    canv.width = width;\n    canv.height = height;\n    return canv;\n  }\n}\n\nvar WorkerClass = null;\n\ntry {\n    var WorkerThreads =\n        typeof module !== 'undefined' && typeof module.require === 'function' && module.require('worker_threads') ||\n        typeof require === 'function' && require('worker_threads') ||\n        typeof require === 'function' && require('worker_threads');\n    WorkerClass = WorkerThreads.Worker;\n} catch(e) {} // eslint-disable-line\n\nfunction decodeBase64$1(base64, enableUnicode) {\n    return Buffer.from(base64, 'base64').toString(enableUnicode ? 'utf16' : 'utf8');\n}\n\nfunction createBase64WorkerFactory$2(base64, sourcemapArg, enableUnicodeArg) {\n    var sourcemap = sourcemapArg === undefined ? null : sourcemapArg;\n    var enableUnicode = enableUnicodeArg === undefined ? false : enableUnicodeArg;\n    var source = decodeBase64$1(base64, enableUnicode);\n    var start = source.indexOf('\\n', 10) + 1;\n    var body = source.substring(start) + (sourcemap ? '\\/\\/# sourceMappingURL=' + sourcemap : '');\n    return function WorkerFactory(options) {\n        return new WorkerClass(body, Object.assign({}, options, { eval: true }));\n    };\n}\n\nfunction decodeBase64(base64, enableUnicode) {\n    var binaryString = atob(base64);\n    if (enableUnicode) {\n        var binaryView = new Uint8Array(binaryString.length);\n        for (var i = 0, n = binaryString.length; i < n; ++i) {\n            binaryView[i] = binaryString.charCodeAt(i);\n        }\n        return String.fromCharCode.apply(null, new Uint16Array(binaryView.buffer));\n    }\n    return binaryString;\n}\n\nfunction createURL(base64, sourcemapArg, enableUnicodeArg) {\n    var sourcemap = sourcemapArg === undefined ? null : sourcemapArg;\n    var enableUnicode = enableUnicodeArg === undefined ? false : enableUnicodeArg;\n    var source = decodeBase64(base64, enableUnicode);\n    var start = source.indexOf('\\n', 10) + 1;\n    var body = source.substring(start) + (sourcemap ? '\\/\\/# sourceMappingURL=' + sourcemap : '');\n    var blob = new Blob([body], { type: 'application/javascript' });\n    return URL.createObjectURL(blob);\n}\n\nfunction createBase64WorkerFactory$1(base64, sourcemapArg, enableUnicodeArg) {\n    var url;\n    return function WorkerFactory(options) {\n        url = url || createURL(base64, sourcemapArg, enableUnicodeArg);\n        return new Worker(url, options);\n    };\n}\n\nvar kIsNodeJS = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';\n\nfunction isNodeJS() {\n    return kIsNodeJS;\n}\n\nfunction createBase64WorkerFactory(base64, sourcemapArg, enableUnicodeArg) {\n    if (isNodeJS()) {\n        return createBase64WorkerFactory$2(base64, sourcemapArg, enableUnicodeArg);\n    }\n    return createBase64WorkerFactory$1(base64, sourcemapArg, enableUnicodeArg);\n}\n\nvar WorkerFactory = createBase64WorkerFactory('Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwooZnVuY3Rpb24gKCkgewogICd1c2Ugc3RyaWN0JzsKCiAgZnVuY3Rpb24gcmVzYW1wbGVOZWFyZXN0KGRhdGEsIG9wdGlvbnMpIHsKICAgIGNvbnN0IHsgc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodCwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCwgd2luZG93LCBidWZmZXIgPSAwIH0gPSBvcHRpb25zOwogICAgY29uc3QgW3gwLCB5MCwgeDEsIHkxXSA9IHdpbmRvdzsKICAgIGNvbnN0IGVmZmVjdGl2ZVNvdXJjZVdpZHRoID0gc291cmNlV2lkdGggLSAyICogYnVmZmVyOwogICAgY29uc3QgZWZmZWN0aXZlU291cmNlSGVpZ2h0ID0gc291cmNlSGVpZ2h0IC0gMiAqIGJ1ZmZlcjsKICAgIGNvbnN0IHJlc2FtcGxlZERhdGEgPSBjb3B5TmV3U2l6ZShkYXRhLCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0KTsKICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGFyZ2V0SGVpZ2h0OyB5KyspIHsKICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0YXJnZXRXaWR0aDsgeCsrKSB7CiAgICAgICAgY29uc3QgY29sID0gYnVmZmVyICsgKGVmZmVjdGl2ZVNvdXJjZVdpZHRoICogKHgwICsgeCAvIHRhcmdldFdpZHRoICogKHgxIC0geDApKSA+Pj4gMCk7CiAgICAgICAgY29uc3Qgcm93ID0gYnVmZmVyICsgKGVmZmVjdGl2ZVNvdXJjZUhlaWdodCAqICh5MCArIHkgLyB0YXJnZXRIZWlnaHQgKiAoeTEgLSB5MCkpID4+PiAwKTsKICAgICAgICByZXNhbXBsZWREYXRhW3kgKiB0YXJnZXRXaWR0aCArIHhdID0gZGF0YVtyb3cgKiBzb3VyY2VXaWR0aCArIGNvbF07CiAgICAgIH0KICAgIH0KICAgIHJldHVybiByZXNhbXBsZWREYXRhOwogIH0KICBmdW5jdGlvbiByZXNhbXBsZURhdGEoZGF0YSwgb3B0aW9ucykgewogICAgY29uc3QgeyBtZXRob2QgPSAibmVhcmVzdCIgfSA9IG9wdGlvbnM7CiAgICBzd2l0Y2ggKG1ldGhvZCkgewogICAgICBjYXNlICJuZWFyZXN0IjoKICAgICAgICByZXR1cm4gcmVzYW1wbGVOZWFyZXN0KGRhdGEsIG9wdGlvbnMpOwogICAgICBjYXNlICJiaWxpbmVhciI6CiAgICAgICAgcmV0dXJuIHJlc2FtcGxlQmlsaW5lYXIoZGF0YSwgb3B0aW9ucyk7CiAgICB9CiAgfQogIGZ1bmN0aW9uIGNvcHlOZXdTaXplKGFycmF5LCB3aWR0aCwgaGVpZ2h0LCBzYW1wbGVzUGVyUGl4ZWwgPSAxKSB7CiAgICByZXR1cm4gbmV3IChPYmplY3QuZ2V0UHJvdG90eXBlT2YoYXJyYXkpKS5jb25zdHJ1Y3Rvcih3aWR0aCAqIGhlaWdodCAqIHNhbXBsZXNQZXJQaXhlbCk7CiAgfQogIGZ1bmN0aW9uIGxlcnAodjAsIHYxLCB0KSB7CiAgICByZXR1cm4gKDEgLSB0KSAqIHYwICsgdCAqIHYxOwogIH0KICBmdW5jdGlvbiByZXNhbXBsZUJpbGluZWFyKGRhdGEsIG9wdGlvbnMpIHsKICAgIGNvbnN0IHsgc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodCwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCwgd2luZG93LCBidWZmZXIgPSAwLCBub2RhdGEgfSA9IG9wdGlvbnM7CiAgICBjb25zdCBbeDAsIHkwLCB4MSwgeTFdID0gd2luZG93OwogICAgY29uc3Qgd2luZG93V2lkdGggPSB4MSAtIHgwOwogICAgY29uc3Qgd2luZG93SGVpZ2h0ID0geTEgLSB5MDsKICAgIGNvbnN0IG5ld0FycmF5ID0gY29weU5ld1NpemUoZGF0YSwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCk7CiAgICBjb25zdCBlZmZlY3RpdmVTb3VyY2VXaWR0aCA9IHNvdXJjZVdpZHRoIC0gMiAqIGJ1ZmZlcjsKICAgIGNvbnN0IGVmZmVjdGl2ZVNvdXJjZUhlaWdodCA9IHNvdXJjZUhlaWdodCAtIDIgKiBidWZmZXI7CiAgICBjb25zdCBpbnZUYXJnZXRXaWR0aCA9IDEgLyB0YXJnZXRXaWR0aDsKICAgIGNvbnN0IGludlRhcmdldEhlaWdodCA9IDEgLyB0YXJnZXRIZWlnaHQ7CiAgICBjb25zdCBpc05vZGF0YSA9ICh2YWx1ZSkgPT4gewogICAgICBpZiAobm9kYXRhID09PSB2b2lkIDApCiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICBpZiAobm9kYXRhID09PSAwKQogICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMDsKICAgICAgcmV0dXJuIE1hdGguYWJzKCh2YWx1ZSAtIG5vZGF0YSkgLyBub2RhdGEpIDwgMWUtNjsKICAgIH07CiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRhcmdldEhlaWdodDsgeSsrKSB7CiAgICAgIGNvbnN0IHlSYXRpbyA9IHkgKiBpbnZUYXJnZXRIZWlnaHQ7CiAgICAgIGNvbnN0IHlNYXBwZWQgPSB5MCArIHlSYXRpbyAqIHdpbmRvd0hlaWdodDsKICAgICAgY29uc3QgcmF3WSA9IGVmZmVjdGl2ZVNvdXJjZUhlaWdodCAqIHlNYXBwZWQgKyBidWZmZXI7CiAgICAgIGNvbnN0IHlsID0gTWF0aC5mbG9vcihyYXdZKTsKICAgICAgY29uc3QgeWggPSBNYXRoLm1pbihNYXRoLmNlaWwocmF3WSksIHNvdXJjZUhlaWdodCAtIGJ1ZmZlciAtIDEpOwogICAgICBjb25zdCB0eSA9IHJhd1kgLSB5bDsKICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0YXJnZXRXaWR0aDsgeCsrKSB7CiAgICAgICAgY29uc3QgeFJhdGlvID0geCAqIGludlRhcmdldFdpZHRoOwogICAgICAgIGNvbnN0IHhNYXBwZWQgPSB4MCArIHhSYXRpbyAqIHdpbmRvd1dpZHRoOwogICAgICAgIGNvbnN0IHJhd1ggPSBlZmZlY3RpdmVTb3VyY2VXaWR0aCAqIHhNYXBwZWQgKyBidWZmZXI7CiAgICAgICAgY29uc3QgeGwgPSBNYXRoLmZsb29yKHJhd1gpOwogICAgICAgIGNvbnN0IHhoID0gTWF0aC5taW4oTWF0aC5jZWlsKHJhd1gpLCBzb3VyY2VXaWR0aCAtIGJ1ZmZlciAtIDEpOwogICAgICAgIGNvbnN0IHR4RnJhY3Rpb24gPSByYXdYIC0geGw7CiAgICAgICAgY29uc3QgY2VudGVyID0gZGF0YVt5bCAqIHNvdXJjZVdpZHRoICsgeGxdOwogICAgICAgIGNvbnN0IG5laWdoYm9ycyA9IFsKICAgICAgICAgIGRhdGFbeWwgKiBzb3VyY2VXaWR0aCArIHhsXSwKICAgICAgICAgIGRhdGFbeWwgKiBzb3VyY2VXaWR0aCArIHhoXSwKICAgICAgICAgIGRhdGFbeWggKiBzb3VyY2VXaWR0aCArIHhsXSwKICAgICAgICAgIGRhdGFbeWggKiBzb3VyY2VXaWR0aCArIHhoXQogICAgICAgIF07CiAgICAgICAgbmVpZ2hib3JzLmZvckVhY2goKG5laWdoYm9yLCBpbmRleCkgPT4gewogICAgICAgICAgaWYgKGlzTm9kYXRhKG5laWdoYm9yKSkgewogICAgICAgICAgICBuZWlnaGJvcnNbaW5kZXhdID0gY2VudGVyOwogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICAgIGlmIChpc05vZGF0YShjZW50ZXIpKSB7CiAgICAgICAgICBuZXdBcnJheVt5ICogdGFyZ2V0V2lkdGggKyB4XSA9IG5vZGF0YTsKICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgIH0KICAgICAgICBjb25zdCBbbGwsIGhsLCBsaCwgaGhdID0gbmVpZ2hib3JzOwogICAgICAgIGNvbnN0IHYwID0gbGVycChsbCwgaGwsIHR4RnJhY3Rpb24pOwogICAgICAgIGNvbnN0IHYxID0gbGVycChsaCwgaGgsIHR4RnJhY3Rpb24pOwogICAgICAgIGNvbnN0IHZhbHVlID0gbGVycCh2MCwgdjEsIHR5KTsKICAgICAgICBuZXdBcnJheVt5ICogdGFyZ2V0V2lkdGggKyB4XSA9IHZhbHVlOwogICAgICB9CiAgICB9CiAgICByZXR1cm4gbmV3QXJyYXk7CiAgfQoKICBvbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7CiAgICBjb25zdCB7IGRhdGEsIG9wdGlvbnMsIGlkIH0gPSBlLmRhdGE7CiAgICBjb25zdCByZXN1bHQgPSByZXNhbXBsZURhdGEoZGF0YSwgb3B0aW9ucyk7CiAgICBwb3N0TWVzc2FnZSh7IGRhdGE6IHJlc3VsdCwgaWQgfSk7CiAgfTsKCn0pKCk7Ci8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmtlci5qcy5tYXAKCg==', null, false);\n/* eslint-enable */\n\nconst defaultPoolSize = typeof navigator !== \"undefined\" ? navigator.hardwareConcurrency || 2 : 2;\nclass WorkerPool {\n  workers;\n  size;\n  messageId;\n  /**\n   * @constructor\n   * @param {Number} [size] The size of the pool. Defaults to the number of CPUs\n   *                      available. When this parameter is `null` or 0, then the\n   *                      decoding will be done in the main thread.\n   */\n  constructor(size = defaultPoolSize) {\n    this.workers = null;\n    this.size = size ?? 0;\n    this.messageId = 0;\n    if (size) {\n      this.workers = [];\n      for (let i = 0; i < size; i++) {\n        this.workers.push({ worker: WorkerFactory(), idle: true });\n      }\n    }\n  }\n  async resample(data, options) {\n    return this.size === 0 ? resampleData(data, options) : new Promise((resolve) => {\n      const worker = this.workers.find((candidate) => candidate.idle) || this.workers[Math.floor(Math.random() * this.size)];\n      worker.idle = false;\n      const id = this.messageId++;\n      const onMessage = (e) => {\n        if (e.data.id === id) {\n          worker.idle = true;\n          resolve(e.data.data);\n          worker.worker.removeEventListener(\"message\", onMessage);\n        }\n      };\n      worker.worker.addEventListener(\"message\", onMessage);\n      worker.worker.postMessage({ data, options, id });\n    });\n  }\n  destroy() {\n    if (this.workers) {\n      this.workers.forEach((worker) => {\n        worker.worker.terminate();\n      });\n      this.workers = null;\n    }\n  }\n}\n\nconst canvas = createCanavas(256, 256);\nclass TIFFImageryProvider {\n  constructor(options) {\n    this.options = options;\n    this.hasAlphaChannel = options.hasAlphaChannel ?? true;\n    this.maximumLevel = options.maximumLevel ?? 18;\n    this.minimumLevel = options.minimumLevel ?? 0;\n    this.credit = new terriajs_cesium__WEBPACK_IMPORTED_MODULE_6__[\"default\"](options.credit || \"\", false);\n    this.errorEvent = new terriajs_cesium__WEBPACK_IMPORTED_MODULE_7__[\"default\"]();\n    this._cacheSize = options.cacheSize ?? 100;\n    this.workerPool = new WorkerPool(options.workerPoolSize);\n    this.geotiffWorkerPool = new geotiff__WEBPACK_IMPORTED_MODULE_8__[\"default\"](options.workerPoolSize);\n    this.ready = false;\n    if ((0,terriajs_cesium__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(options.url)) {\n      this.readyPromise = this._build(options.url, options).then(() => {\n        return true;\n      });\n    }\n  }\n  ready;\n  tilingScheme;\n  rectangle;\n  tileSize;\n  tileWidth;\n  tileHeight;\n  maximumLevel;\n  minimumLevel;\n  credit;\n  errorEvent;\n  readyPromise;\n  bands;\n  noData;\n  hasAlphaChannel;\n  plot;\n  renderOptions;\n  readSamples;\n  requestLevels;\n  bbox;\n  _destroyed = false;\n  _source;\n  _imageCount;\n  _images = [];\n  _imagesCache = /* @__PURE__ */ new Map();\n  _cacheSize;\n  _isTiled;\n  _proj;\n  origin;\n  reverseY = false;\n  samples;\n  workerPool;\n  geotiffWorkerPool;\n  get isDestroyed() {\n    return this._destroyed;\n  }\n  async _build(url, options = {}) {\n    var _a, _b;\n    const { tileSize, renderOptions, projFunc, requestOptions } = options;\n    let source = await (url instanceof File || url instanceof Blob ? (0,geotiff__WEBPACK_IMPORTED_MODULE_10__.fromBlob)(url) : (0,geotiff__WEBPACK_IMPORTED_MODULE_10__.fromUrl)(url, requestOptions));\n    let image = await source.getImage();\n    this._isTiled = image.isTiled;\n    if (!this._isTiled && typeof url === \"string\") {\n      source = await (0,geotiff__WEBPACK_IMPORTED_MODULE_10__.fromBlob)(await (await fetch(url)).blob());\n      image = await source.getImage();\n    }\n    this._source = source;\n    this.origin = this._getOrigin(image);\n    this.bbox = image.getBoundingBox();\n    this.reverseY = this._checkIfReversed(image);\n    const [west, south, east, north] = this.bbox;\n    const prjCode = +(image.geoKeys.ProjectedCSTypeGeoKey ?? image.geoKeys.GeographicTypeGeoKey);\n    this._proj = projFunc == null ? void 0 : projFunc(prjCode);\n    if (prjCode === 3857 || prjCode === 900913) {\n      this.tilingScheme = new terriajs_cesium__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n        rectangleNortheastInMeters: new terriajs_cesium__WEBPACK_IMPORTED_MODULE_11__[\"default\"](east, north),\n        rectangleSouthwestInMeters: new terriajs_cesium__WEBPACK_IMPORTED_MODULE_11__[\"default\"](west, south)\n      });\n    } else if (prjCode === 4326) {\n      this.tilingScheme = new terriajs_cesium__WEBPACK_IMPORTED_MODULE_12__[\"default\"]({\n        rectangle: terriajs_cesium__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fromDegrees(...this.bbox),\n        numberOfLevelZeroTilesX: 1,\n        numberOfLevelZeroTilesY: 1\n      });\n    } else if (typeof ((_a = this._proj) == null ? void 0 : _a.project) === \"function\" && typeof ((_b = this._proj) == null ? void 0 : _b.unproject) === \"function\") {\n      console.warn(`[Experimental] Reprojection EPSG:${prjCode}`);\n      this.tilingScheme = new TIFFImageryProviderTilingScheme({\n        rectangleNortheastInMeters: new terriajs_cesium__WEBPACK_IMPORTED_MODULE_11__[\"default\"](east, north),\n        rectangleSouthwestInMeters: new terriajs_cesium__WEBPACK_IMPORTED_MODULE_11__[\"default\"](west, south),\n        ...this._proj\n      });\n    } else {\n      const error = new terriajs_cesium__WEBPACK_IMPORTED_MODULE_13__[\"default\"](`Unspported projection type: EPSG:${prjCode}, please add projFunc parameter to handle projection`);\n      throw error;\n    }\n    this.rectangle = this.tilingScheme.rectangle;\n    if (this.rectangle.east < this.rectangle.west) {\n      this.rectangle.east += terriajs_cesium__WEBPACK_IMPORTED_MODULE_3__[\"default\"].TWO_PI;\n    }\n    this._imageCount = await source.getImageCount();\n    this.tileSize = this.tileWidth = tileSize || (this._isTiled ? image.getTileWidth() : image.getWidth()) || 256;\n    this.tileHeight = tileSize || (this._isTiled ? image.getTileHeight() : image.getHeight()) || 256;\n    console.log(this.tileWidth, this.tileHeight);\n    this.requestLevels = this._isTiled ? await this._getCogLevels() : [0];\n    this._images = new Array(this._imageCount).fill(null);\n    const samples = image.getSamplesPerPixel();\n    this.samples = samples;\n    this.renderOptions = renderOptions ?? {};\n    const noData = image.getGDALNoData();\n    this.noData = this.renderOptions.nodata ?? noData;\n    if (samples < 3 && this.renderOptions.convertToRGB) {\n      const error = new terriajs_cesium__WEBPACK_IMPORTED_MODULE_13__[\"default\"](\"Can not render the image as RGB, please check the convertToRGB parameter\");\n      throw error;\n    }\n    if (!this.renderOptions.single && !this.renderOptions.multi && !this.renderOptions.convertToRGB) {\n      if (samples > 2) {\n        this.renderOptions = {\n          convertToRGB: true,\n          ...this.renderOptions\n        };\n      } else {\n        this.renderOptions = {\n          single: {\n            band: 1\n          },\n          ...this.renderOptions\n        };\n      }\n    }\n    if (this.renderOptions.single) {\n      this.renderOptions.single.band = this.renderOptions.single.band ?? 1;\n    }\n    const { single, multi, convertToRGB } = this.renderOptions;\n    this.readSamples = multi ? [multi.r.band - 1, multi.g.band - 1, multi.b.band - 1] : convertToRGB ? [0, 1, 2] : [single.band - 1];\n    if (single == null ? void 0 : single.expression) {\n      this.readSamples = findAndSortBandNumbers(single.expression);\n    }\n    const bands = {};\n    await Promise.all(this.readSamples.map(async (i) => {\n      const element = image.getGDALMetadata(i);\n      const bandNum = i + 1;\n      if ((element == null ? void 0 : element.STATISTICS_MINIMUM) && (element == null ? void 0 : element.STATISTICS_MAXIMUM)) {\n        bands[bandNum] = {\n          min: +element.STATISTICS_MINIMUM,\n          max: +element.STATISTICS_MAXIMUM\n        };\n      } else {\n        if (convertToRGB) {\n          bands[bandNum] = {\n            min: 0,\n            max: 255\n          };\n        }\n        if (multi) {\n          const inputBand = multi[Object.keys(multi).find((key) => {\n            var _a2;\n            return ((_a2 = multi[key]) == null ? void 0 : _a2.band) === bandNum;\n          })];\n          if ((inputBand == null ? void 0 : inputBand.min) !== void 0 && (inputBand == null ? void 0 : inputBand.max) !== void 0) {\n            const { min, max } = inputBand;\n            bands[bandNum] = {\n              min,\n              max\n            };\n          }\n        }\n        if (single && !single.expression && single.band === bandNum && single.domain) {\n          bands[bandNum] = {\n            min: single.domain[0],\n            max: single.domain[1]\n          };\n        }\n        if (!(single == null ? void 0 : single.expression) && !bands[bandNum]) {\n          console.warn(`Can not get band${bandNum} min/max, try to calculate min/max values, or setting ${single ? \"domain\" : \"min / max\"}`);\n          const previewImage = await source.getImage(this.requestLevels[0]);\n          const data = (await previewImage.readRasters({\n            samples: [i],\n            pool: this.geotiffWorkerPool\n          }))[0].filter((item) => !isNaN(item));\n          bands[bandNum] = getMinMax(data, noData);\n        }\n      }\n    }));\n    this.bands = bands;\n    try {\n      if (this.renderOptions.single) {\n        const band = this.bands[single.band];\n        if (!single.expression && !band) {\n          throw new terriajs_cesium__WEBPACK_IMPORTED_MODULE_13__[\"default\"](`Invalid band${single.band}`);\n        }\n        const domain = single.domain ?? [band.min, band.max];\n        this.plot = new plot({\n          canvas,\n          ...single,\n          domain\n        });\n        this.plot.setNoDataValue(this.noData);\n        const { expression, colors, colorScaleImage } = single;\n        this.plot.setExpression(expression);\n        if (colors) {\n          const colorScale = generateColorScale(colors, (single == null ? void 0 : single.useRealValue) ? domain : [0, 1]);\n          addColorScale(\"temp\", colorScale.colors, colorScale.positions);\n          this.plot.setColorScale(\"temp\");\n        } else if (!colorScaleImage) {\n          this.plot.setColorScale((single == null ? void 0 : single.colorScale) ?? \"blackwhite\");\n        }\n      }\n    } catch (e) {\n      console.error(e);\n      this.errorEvent.raiseEvent(e);\n    }\n    this.readyPromise = Promise.resolve(true);\n    this.ready = true;\n  }\n  static async fromUrl(url, options = {}) {\n    const provider = new TIFFImageryProvider(options);\n    await provider._build(url, {\n      ...options,\n      url: void 0\n    });\n    return provider;\n  }\n  /**\n   * Get the origin of an image.  If the image does not have an affine transform,\n   * the top-left corner of the pixel bounds is returned.\n   * @param {GeoTIFFImage} image The image.\n   * @return {Array<number>} The image origin.\n   */\n  _getOrigin(image) {\n    try {\n      return image.getOrigin().slice(0, 2);\n    } catch (_) {\n      return [0, image.fileDirectory.ImageLength];\n    }\n  }\n  _checkIfReversed(image) {\n    const pixelScale = image.getFileDirectory().ModelPixelScale;\n    if (pixelScale) {\n      const pixelScaleY = pixelScale[1];\n      if (pixelScaleY < 0)\n        return true;\n    }\n    const transformation = image.getFileDirectory().ModelTransformation;\n    if (transformation) {\n      const originX = transformation[3];\n      const originY = transformation[7];\n      if (originY > originX)\n        return true;\n    }\n    return false;\n  }\n  /**\n   * get suitable cog levels\n   */\n  async _getCogLevels() {\n    const levels = [];\n    let maximumLevel = this._imageCount - 1;\n    for (let i = this._imageCount - 1; i >= 0; i--) {\n      const image = this._images[i] = await this._source.getImage(i);\n      const width = image.getWidth();\n      const height = image.getHeight();\n      const size = Math.max(width, height);\n      if (i === this._imageCount - 1) {\n        const firstImageLevel = Math.ceil((size - this.tileSize) / this.tileSize);\n        levels.push(...new Array(firstImageLevel).fill(i));\n      }\n      if (size > this.tileSize * 0.5) {\n        maximumLevel = i;\n        break;\n      }\n    }\n    let nowCogLevel = maximumLevel;\n    while (nowCogLevel >= 0) {\n      levels.push(nowCogLevel--);\n    }\n    return levels;\n  }\n  /**\n   * Get tile data\n   * @param x \n   * @param y \n   * @param z \n   */\n  async _loadTile(reqx, reqy, reqz) {\n    var _a;\n    let x = reqx, y = reqy, z = reqz, startX = reqx, startY = reqy;\n    const maxCogLevel = this.requestLevels.length - 1;\n    if (z > maxCogLevel) {\n      z = maxCogLevel;\n      x = x >> reqz - maxCogLevel;\n      y = y >> reqz - maxCogLevel;\n      startX = x << reqz - z;\n      startY = y << reqz - z;\n    }\n    const index = this.requestLevels[z];\n    let image = this._images[index];\n    if (!image) {\n      image = this._images[index] = await this._source.getImage(index);\n    }\n    const width = image.getWidth();\n    const height = image.getHeight();\n    const tileXNum = this.tilingScheme.getNumberOfXTilesAtLevel(z);\n    const tileYNum = this.tilingScheme.getNumberOfYTilesAtLevel(z);\n    const tilePixel = {\n      xWidth: width / tileXNum,\n      yWidth: height / tileYNum\n    };\n    let window = [\n      Math.round(x * tilePixel.xWidth),\n      Math.round(y * tilePixel.yWidth),\n      Math.round((x + 1) * tilePixel.xWidth),\n      Math.round((y + 1) * tilePixel.yWidth)\n    ];\n    if (this._proj && this.tilingScheme instanceof TIFFImageryProviderTilingScheme) {\n      const targetRect = this.tilingScheme.tileXYToNativeRectangle2(x, y, z);\n      const nativeRect = this.tilingScheme.nativeRectangle;\n      targetRect.west -= nativeRect.width / width;\n      targetRect.east += nativeRect.width / width;\n      targetRect.south -= nativeRect.height / height;\n      targetRect.north += nativeRect.height / height;\n      window = [\n        ~~((targetRect.west - nativeRect.west) / nativeRect.width * width),\n        ~~((nativeRect.north - targetRect.north) / nativeRect.height * height),\n        ~~((targetRect.east - nativeRect.west) / nativeRect.width * width),\n        ~~((nativeRect.north - targetRect.south) / nativeRect.height * height)\n      ];\n    }\n    if (this.reverseY) {\n      window = [window[0], height - window[3], window[2], height - window[1]];\n    }\n    const buffer = 1;\n    window = [window[0] - buffer, window[1] - buffer, window[2] + buffer, window[3] + buffer];\n    const sourceWidth = window[2] - window[0], sourceHeight = window[3] - window[1];\n    const options = {\n      window,\n      pool: this.geotiffWorkerPool,\n      samples: this.readSamples,\n      fillValue: this.noData,\n      interleave: false\n    };\n    let res;\n    try {\n      if (this.renderOptions.convertToRGB) {\n        res = await image.readRGB(options);\n      } else {\n        res = await image.readRasters(options);\n        if (this.reverseY) {\n          res = await Promise.all(res.map((array) => reverseArray({ array, width: res.width, height: res.height })));\n        }\n      }\n      if (((_a = this._proj) == null ? void 0 : _a.project) && this.tilingScheme instanceof TIFFImageryProviderTilingScheme) {\n        const sourceRect = this.tilingScheme.tileXYToNativeRectangle2(x, y, z);\n        const targetRect = this.tilingScheme.tileXYToRectangle(x, y, z);\n        const sourceBBox = [sourceRect.west, sourceRect.south, sourceRect.east, sourceRect.north];\n        const targetBBox = [targetRect.west, targetRect.south, targetRect.east, targetRect.north].map(terriajs_cesium__WEBPACK_IMPORTED_MODULE_3__[\"default\"].toDegrees);\n        const result = [];\n        for (let i = 0; i < res.length; i++) {\n          const prjData = reprojection({\n            data: res[i],\n            sourceWidth,\n            sourceHeight,\n            nodata: this.noData,\n            project: this._proj.project,\n            sourceBBox,\n            targetBBox\n          });\n          result.push(prjData);\n        }\n        res = result;\n      }\n      const tileNum = 1 << reqz - z;\n      const x0 = (reqx - startX) / tileNum;\n      const y0 = (reqy - startY) / tileNum;\n      const step = 1 / (1 << reqz - z);\n      const x1 = x0 + step;\n      const y1 = y0 + step;\n      res = await Promise.all(res.map(async (data) => this.workerPool.resample(data, {\n        sourceWidth,\n        sourceHeight,\n        targetWidth: this.tileWidth,\n        targetHeight: this.tileHeight,\n        window: [x0, y0, x1, y1],\n        method: this.renderOptions.resampleMethod,\n        buffer,\n        nodata: this.noData\n      })));\n      return {\n        data: res,\n        width: this.tileWidth,\n        height: this.tileHeight\n      };\n    } catch (error) {\n      this.errorEvent.raiseEvent(error);\n      throw error;\n    }\n  }\n  async requestImage(x, y, z) {\n    if (!this.ready) {\n      throw new terriajs_cesium__WEBPACK_IMPORTED_MODULE_13__[\"default\"](\n        \"requestImage must not be called before the imagery provider is ready.\"\n      );\n    }\n    if (z < this.minimumLevel || z > this.maximumLevel)\n      return void 0;\n    const cacheKey = `${x}_${y}_${z}`;\n    if (this._imagesCache.has(cacheKey)) {\n      return this._imagesCache.get(cacheKey);\n    }\n    const { single, multi, convertToRGB } = this.renderOptions;\n    try {\n      const { width, height, data } = await this._loadTile(x, y, z);\n      if (this._destroyed || !width || !height) {\n        return void 0;\n      }\n      let result;\n      if (multi || convertToRGB) {\n        const opts = {\n          data,\n          width,\n          height,\n          renderOptions: multi ?? [\"r\", \"g\", \"b\"].reduce((pre, val, index) => ({\n            ...pre,\n            [val]: {\n              band: index + 1,\n              min: 0,\n              max: 255\n            }\n          }), {}),\n          bands: this.bands,\n          noData: this.noData,\n          colorMapping: Object.entries(this.renderOptions.colorMapping ?? { \"black\": \"transparent\" }).map((val) => val.map(stringColorToRgba))\n        };\n        result = await generateImage(opts);\n      } else if (single && this.plot) {\n        const { band = 1 } = single;\n        this.plot.removeAllDataset();\n        this.readSamples.forEach((sample, index) => {\n          this.plot.addDataset(`b${sample + 1}`, data[index], width, height);\n        });\n        if (single.expression) {\n          this.plot.render();\n        } else {\n          this.plot.renderDataset(`b${band}`);\n        }\n        const canv = createCanavas(this.tileWidth, this.tileHeight);\n        const ctx = canv.getContext(\"2d\");\n        ctx.drawImage(this.plot.canvas, 0, 0);\n        result = canv;\n      }\n      if (result) {\n        if (this._imagesCache.size >= this._cacheSize) {\n          const oldestKey = this._imagesCache.keys().next().value;\n          this._imagesCache.delete(oldestKey);\n        }\n        this._imagesCache.set(cacheKey, result);\n      }\n      return result;\n    } catch (e) {\n      console.error(e);\n      this.errorEvent.raiseEvent(e);\n      throw e;\n    }\n  }\n  async pickFeatures(x, y, zoom, longitude, latitude) {\n    if (!this.options.enablePickFeatures)\n      return void 0;\n    const z = zoom > this.maximumLevel ? this.maximumLevel : zoom;\n    const index = this.requestLevels[z];\n    let image = this._images[index];\n    if (!image) {\n      image = this._images[index] = await this._source.getImage(index);\n    }\n    const width = image.getWidth();\n    const height = image.getHeight();\n    let posX, posY, window;\n    const { west, south, north, width: lonWidth } = this.rectangle;\n    let lonGap = longitude - west;\n    if (longitude < west) {\n      lonGap += terriajs_cesium__WEBPACK_IMPORTED_MODULE_3__[\"default\"].TWO_PI;\n    }\n    posX = ~~(Math.abs(lonGap / lonWidth) * width);\n    posY = ~~(Math.abs((north - latitude) / (north - south)) * height);\n    window = [posX, posY, posX + 1, posY + 1];\n    if (this.reverseY) {\n      posY = height - posY;\n      window = [posX, posY - 1, posX + 1, posY];\n    }\n    const options = {\n      window,\n      height: 1,\n      width: 1,\n      pool: this.geotiffWorkerPool,\n      interleave: false\n    };\n    let res;\n    if (this.renderOptions.convertToRGB) {\n      res = await image.readRGB(options);\n    } else {\n      res = await image.readRasters(options);\n    }\n    const featureInfo = new terriajs_cesium__WEBPACK_IMPORTED_MODULE_14__[\"default\"]();\n    featureInfo.name = `lon:${(longitude / Math.PI * 180).toFixed(6)}, lat:${(latitude / Math.PI * 180).toFixed(6)}`;\n    const data = {};\n    res == null ? void 0 : res.forEach((item, index2) => {\n      data[index2] = item == null ? void 0 : item[0];\n    });\n    featureInfo.data = data;\n    if (res) {\n      featureInfo.configureDescriptionFromProperties(data);\n    }\n    return [featureInfo];\n  }\n  destroy() {\n    var _a;\n    if (this._imagesCache) {\n      for (const key in this._imagesCache) {\n        delete this._imagesCache[key];\n      }\n      this._imagesCache.clear();\n    }\n    if (this.workerPool) {\n      this.workerPool.destroy();\n    }\n    if (this.plot && this.plot.gl) {\n      for (const programKey in this.plot.programCache) {\n        this.plot.gl.deleteProgram(this.plot.programCache[programKey]);\n      }\n      this.plot.gl.deleteBuffer(this.plot.positionBuffer);\n    }\n    (_a = this.plot) == null ? void 0 : _a.destroy();\n    this._images = [];\n    this._source = void 0;\n    this._destroyed = true;\n  }\n}\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGVycmlhanMtdGlmZi1pbWFnZXJ5LXByb3ZpZGVyL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVycmlhanMtbWFwLy4vbm9kZV9tb2R1bGVzL3RlcnJpYWpzLXRpZmYtaW1hZ2VyeS1wcm92aWRlci9kaXN0L2luZGV4LmpzPzM0YzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29sb3IsIFdlYk1lcmNhdG9yVGlsaW5nU2NoZW1lLCBSZWN0YW5nbGUsIE1hdGggYXMgTWF0aCQxLCBDYXJ0ZXNpYW4zLCBDYXJ0b2dyYXBoaWMsIENyZWRpdCwgRXZlbnQsIGRlZmluZWQsIENhcnRlc2lhbjIsIEdlb2dyYXBoaWNUaWxpbmdTY2hlbWUsIERldmVsb3BlckVycm9yLCBJbWFnZXJ5TGF5ZXJGZWF0dXJlSW5mbyB9IGZyb20gJ3RlcnJpYWpzLWNlc2l1bSc7XG5pbXBvcnQgeyBQb29sLCBmcm9tQmxvYiwgZnJvbVVybCB9IGZyb20gJ2dlb3RpZmYnO1xuXG5jb25zdCBjb2xvcnNjYWxlcyA9IHtcbiAgdmlyaWRpczogbmV3IFVpbnQ4QXJyYXkoWzY4LCAxLCA4NCwgMjU1LCA2OCwgMiwgODYsIDI1NSwgNjksIDQsIDg3LCAyNTUsIDY5LCA1LCA4OSwgMjU1LCA3MCwgNywgOTAsIDI1NSwgNzAsIDgsIDkyLCAyNTUsIDcwLCAxMCwgOTMsIDI1NSwgNzAsIDExLCA5NCwgMjU1LCA3MSwgMTMsIDk2LCAyNTUsIDcxLCAxNCwgOTcsIDI1NSwgNzEsIDE2LCA5OSwgMjU1LCA3MSwgMTcsIDEwMCwgMjU1LCA3MSwgMTksIDEwMSwgMjU1LCA3MiwgMjAsIDEwMywgMjU1LCA3MiwgMjIsIDEwNCwgMjU1LCA3MiwgMjMsIDEwNSwgMjU1LCA3MiwgMjQsIDEwNiwgMjU1LCA3MiwgMjYsIDEwOCwgMjU1LCA3MiwgMjcsIDEwOSwgMjU1LCA3MiwgMjgsIDExMCwgMjU1LCA3MiwgMjksIDExMSwgMjU1LCA3MiwgMzEsIDExMiwgMjU1LCA3MiwgMzIsIDExMywgMjU1LCA3MiwgMzMsIDExNSwgMjU1LCA3MiwgMzUsIDExNiwgMjU1LCA3MiwgMzYsIDExNywgMjU1LCA3MiwgMzcsIDExOCwgMjU1LCA3MiwgMzgsIDExOSwgMjU1LCA3MiwgNDAsIDEyMCwgMjU1LCA3MiwgNDEsIDEyMSwgMjU1LCA3MSwgNDIsIDEyMiwgMjU1LCA3MSwgNDQsIDEyMiwgMjU1LCA3MSwgNDUsIDEyMywgMjU1LCA3MSwgNDYsIDEyNCwgMjU1LCA3MSwgNDcsIDEyNSwgMjU1LCA3MCwgNDgsIDEyNiwgMjU1LCA3MCwgNTAsIDEyNiwgMjU1LCA3MCwgNTEsIDEyNywgMjU1LCA3MCwgNTIsIDEyOCwgMjU1LCA2OSwgNTMsIDEyOSwgMjU1LCA2OSwgNTUsIDEyOSwgMjU1LCA2OSwgNTYsIDEzMCwgMjU1LCA2OCwgNTcsIDEzMSwgMjU1LCA2OCwgNTgsIDEzMSwgMjU1LCA2OCwgNTksIDEzMiwgMjU1LCA2NywgNjEsIDEzMiwgMjU1LCA2NywgNjIsIDEzMywgMjU1LCA2NiwgNjMsIDEzMywgMjU1LCA2NiwgNjQsIDEzNCwgMjU1LCA2NiwgNjUsIDEzNCwgMjU1LCA2NSwgNjYsIDEzNSwgMjU1LCA2NSwgNjgsIDEzNSwgMjU1LCA2NCwgNjksIDEzNiwgMjU1LCA2NCwgNzAsIDEzNiwgMjU1LCA2MywgNzEsIDEzNiwgMjU1LCA2MywgNzIsIDEzNywgMjU1LCA2MiwgNzMsIDEzNywgMjU1LCA2MiwgNzQsIDEzNywgMjU1LCA2MiwgNzYsIDEzOCwgMjU1LCA2MSwgNzcsIDEzOCwgMjU1LCA2MSwgNzgsIDEzOCwgMjU1LCA2MCwgNzksIDEzOCwgMjU1LCA2MCwgODAsIDEzOSwgMjU1LCA1OSwgODEsIDEzOSwgMjU1LCA1OSwgODIsIDEzOSwgMjU1LCA1OCwgODMsIDEzOSwgMjU1LCA1OCwgODQsIDE0MCwgMjU1LCA1NywgODUsIDE0MCwgMjU1LCA1NywgODYsIDE0MCwgMjU1LCA1NiwgODgsIDE0MCwgMjU1LCA1NiwgODksIDE0MCwgMjU1LCA1NSwgOTAsIDE0MCwgMjU1LCA1NSwgOTEsIDE0MSwgMjU1LCA1NCwgOTIsIDE0MSwgMjU1LCA1NCwgOTMsIDE0MSwgMjU1LCA1MywgOTQsIDE0MSwgMjU1LCA1MywgOTUsIDE0MSwgMjU1LCA1MiwgOTYsIDE0MSwgMjU1LCA1MiwgOTcsIDE0MSwgMjU1LCA1MSwgOTgsIDE0MSwgMjU1LCA1MSwgOTksIDE0MSwgMjU1LCA1MCwgMTAwLCAxNDIsIDI1NSwgNTAsIDEwMSwgMTQyLCAyNTUsIDQ5LCAxMDIsIDE0MiwgMjU1LCA0OSwgMTAzLCAxNDIsIDI1NSwgNDksIDEwNCwgMTQyLCAyNTUsIDQ4LCAxMDUsIDE0MiwgMjU1LCA0OCwgMTA2LCAxNDIsIDI1NSwgNDcsIDEwNywgMTQyLCAyNTUsIDQ3LCAxMDgsIDE0MiwgMjU1LCA0NiwgMTA5LCAxNDIsIDI1NSwgNDYsIDExMCwgMTQyLCAyNTUsIDQ2LCAxMTEsIDE0MiwgMjU1LCA0NSwgMTEyLCAxNDIsIDI1NSwgNDUsIDExMywgMTQyLCAyNTUsIDQ0LCAxMTMsIDE0MiwgMjU1LCA0NCwgMTE0LCAxNDIsIDI1NSwgNDQsIDExNSwgMTQyLCAyNTUsIDQzLCAxMTYsIDE0MiwgMjU1LCA0MywgMTE3LCAxNDIsIDI1NSwgNDIsIDExOCwgMTQyLCAyNTUsIDQyLCAxMTksIDE0MiwgMjU1LCA0MiwgMTIwLCAxNDIsIDI1NSwgNDEsIDEyMSwgMTQyLCAyNTUsIDQxLCAxMjIsIDE0MiwgMjU1LCA0MSwgMTIzLCAxNDIsIDI1NSwgNDAsIDEyNCwgMTQyLCAyNTUsIDQwLCAxMjUsIDE0MiwgMjU1LCAzOSwgMTI2LCAxNDIsIDI1NSwgMzksIDEyNywgMTQyLCAyNTUsIDM5LCAxMjgsIDE0MiwgMjU1LCAzOCwgMTI5LCAxNDIsIDI1NSwgMzgsIDEzMCwgMTQyLCAyNTUsIDM4LCAxMzAsIDE0MiwgMjU1LCAzNywgMTMxLCAxNDIsIDI1NSwgMzcsIDEzMiwgMTQyLCAyNTUsIDM3LCAxMzMsIDE0MiwgMjU1LCAzNiwgMTM0LCAxNDIsIDI1NSwgMzYsIDEzNSwgMTQyLCAyNTUsIDM1LCAxMzYsIDE0MiwgMjU1LCAzNSwgMTM3LCAxNDIsIDI1NSwgMzUsIDEzOCwgMTQxLCAyNTUsIDM0LCAxMzksIDE0MSwgMjU1LCAzNCwgMTQwLCAxNDEsIDI1NSwgMzQsIDE0MSwgMTQxLCAyNTUsIDMzLCAxNDIsIDE0MSwgMjU1LCAzMywgMTQzLCAxNDEsIDI1NSwgMzMsIDE0NCwgMTQxLCAyNTUsIDMzLCAxNDUsIDE0MCwgMjU1LCAzMiwgMTQ2LCAxNDAsIDI1NSwgMzIsIDE0NiwgMTQwLCAyNTUsIDMyLCAxNDcsIDE0MCwgMjU1LCAzMSwgMTQ4LCAxNDAsIDI1NSwgMzEsIDE0OSwgMTM5LCAyNTUsIDMxLCAxNTAsIDEzOSwgMjU1LCAzMSwgMTUxLCAxMzksIDI1NSwgMzEsIDE1MiwgMTM5LCAyNTUsIDMxLCAxNTMsIDEzOCwgMjU1LCAzMSwgMTU0LCAxMzgsIDI1NSwgMzAsIDE1NSwgMTM4LCAyNTUsIDMwLCAxNTYsIDEzNywgMjU1LCAzMCwgMTU3LCAxMzcsIDI1NSwgMzEsIDE1OCwgMTM3LCAyNTUsIDMxLCAxNTksIDEzNiwgMjU1LCAzMSwgMTYwLCAxMzYsIDI1NSwgMzEsIDE2MSwgMTM2LCAyNTUsIDMxLCAxNjEsIDEzNSwgMjU1LCAzMSwgMTYyLCAxMzUsIDI1NSwgMzIsIDE2MywgMTM0LCAyNTUsIDMyLCAxNjQsIDEzNCwgMjU1LCAzMywgMTY1LCAxMzMsIDI1NSwgMzMsIDE2NiwgMTMzLCAyNTUsIDM0LCAxNjcsIDEzMywgMjU1LCAzNCwgMTY4LCAxMzIsIDI1NSwgMzUsIDE2OSwgMTMxLCAyNTUsIDM2LCAxNzAsIDEzMSwgMjU1LCAzNywgMTcxLCAxMzAsIDI1NSwgMzcsIDE3MiwgMTMwLCAyNTUsIDM4LCAxNzMsIDEyOSwgMjU1LCAzOSwgMTczLCAxMjksIDI1NSwgNDAsIDE3NCwgMTI4LCAyNTUsIDQxLCAxNzUsIDEyNywgMjU1LCA0MiwgMTc2LCAxMjcsIDI1NSwgNDQsIDE3NywgMTI2LCAyNTUsIDQ1LCAxNzgsIDEyNSwgMjU1LCA0NiwgMTc5LCAxMjQsIDI1NSwgNDcsIDE4MCwgMTI0LCAyNTUsIDQ5LCAxODEsIDEyMywgMjU1LCA1MCwgMTgyLCAxMjIsIDI1NSwgNTIsIDE4MiwgMTIxLCAyNTUsIDUzLCAxODMsIDEyMSwgMjU1LCA1NSwgMTg0LCAxMjAsIDI1NSwgNTYsIDE4NSwgMTE5LCAyNTUsIDU4LCAxODYsIDExOCwgMjU1LCA1OSwgMTg3LCAxMTcsIDI1NSwgNjEsIDE4OCwgMTE2LCAyNTUsIDYzLCAxODgsIDExNSwgMjU1LCA2NCwgMTg5LCAxMTQsIDI1NSwgNjYsIDE5MCwgMTEzLCAyNTUsIDY4LCAxOTEsIDExMiwgMjU1LCA3MCwgMTkyLCAxMTEsIDI1NSwgNzIsIDE5MywgMTEwLCAyNTUsIDc0LCAxOTMsIDEwOSwgMjU1LCA3NiwgMTk0LCAxMDgsIDI1NSwgNzgsIDE5NSwgMTA3LCAyNTUsIDgwLCAxOTYsIDEwNiwgMjU1LCA4MiwgMTk3LCAxMDUsIDI1NSwgODQsIDE5NywgMTA0LCAyNTUsIDg2LCAxOTgsIDEwMywgMjU1LCA4OCwgMTk5LCAxMDEsIDI1NSwgOTAsIDIwMCwgMTAwLCAyNTUsIDkyLCAyMDAsIDk5LCAyNTUsIDk0LCAyMDEsIDk4LCAyNTUsIDk2LCAyMDIsIDk2LCAyNTUsIDk5LCAyMDMsIDk1LCAyNTUsIDEwMSwgMjAzLCA5NCwgMjU1LCAxMDMsIDIwNCwgOTIsIDI1NSwgMTA1LCAyMDUsIDkxLCAyNTUsIDEwOCwgMjA1LCA5MCwgMjU1LCAxMTAsIDIwNiwgODgsIDI1NSwgMTEyLCAyMDcsIDg3LCAyNTUsIDExNSwgMjA4LCA4NiwgMjU1LCAxMTcsIDIwOCwgODQsIDI1NSwgMTE5LCAyMDksIDgzLCAyNTUsIDEyMiwgMjA5LCA4MSwgMjU1LCAxMjQsIDIxMCwgODAsIDI1NSwgMTI3LCAyMTEsIDc4LCAyNTUsIDEyOSwgMjExLCA3NywgMjU1LCAxMzIsIDIxMiwgNzUsIDI1NSwgMTM0LCAyMTMsIDczLCAyNTUsIDEzNywgMjEzLCA3MiwgMjU1LCAxMzksIDIxNCwgNzAsIDI1NSwgMTQyLCAyMTQsIDY5LCAyNTUsIDE0NCwgMjE1LCA2NywgMjU1LCAxNDcsIDIxNSwgNjUsIDI1NSwgMTQ5LCAyMTYsIDY0LCAyNTUsIDE1MiwgMjE2LCA2MiwgMjU1LCAxNTUsIDIxNywgNjAsIDI1NSwgMTU3LCAyMTcsIDU5LCAyNTUsIDE2MCwgMjE4LCA1NywgMjU1LCAxNjIsIDIxOCwgNTUsIDI1NSwgMTY1LCAyMTksIDU0LCAyNTUsIDE2OCwgMjE5LCA1MiwgMjU1LCAxNzAsIDIyMCwgNTAsIDI1NSwgMTczLCAyMjAsIDQ4LCAyNTUsIDE3NiwgMjIxLCA0NywgMjU1LCAxNzgsIDIyMSwgNDUsIDI1NSwgMTgxLCAyMjIsIDQzLCAyNTUsIDE4NCwgMjIyLCA0MSwgMjU1LCAxODYsIDIyMiwgNDAsIDI1NSwgMTg5LCAyMjMsIDM4LCAyNTUsIDE5MiwgMjIzLCAzNywgMjU1LCAxOTQsIDIyMywgMzUsIDI1NSwgMTk3LCAyMjQsIDMzLCAyNTUsIDIwMCwgMjI0LCAzMiwgMjU1LCAyMDIsIDIyNSwgMzEsIDI1NSwgMjA1LCAyMjUsIDI5LCAyNTUsIDIwOCwgMjI1LCAyOCwgMjU1LCAyMTAsIDIyNiwgMjcsIDI1NSwgMjEzLCAyMjYsIDI2LCAyNTUsIDIxNiwgMjI2LCAyNSwgMjU1LCAyMTgsIDIyNywgMjUsIDI1NSwgMjIxLCAyMjcsIDI0LCAyNTUsIDIyMywgMjI3LCAyNCwgMjU1LCAyMjYsIDIyOCwgMjQsIDI1NSwgMjI5LCAyMjgsIDI1LCAyNTUsIDIzMSwgMjI4LCAyNSwgMjU1LCAyMzQsIDIyOSwgMjYsIDI1NSwgMjM2LCAyMjksIDI3LCAyNTUsIDIzOSwgMjI5LCAyOCwgMjU1LCAyNDEsIDIyOSwgMjksIDI1NSwgMjQ0LCAyMzAsIDMwLCAyNTUsIDI0NiwgMjMwLCAzMiwgMjU1LCAyNDgsIDIzMCwgMzMsIDI1NSwgMjUxLCAyMzEsIDM1LCAyNTUsIDI1MywgMjMxLCAzNywgMjU1XSksXG4gIGluZmVybm86IG5ldyBVaW50OEFycmF5KFswLCAwLCA0LCAyNTUsIDEsIDAsIDUsIDI1NSwgMSwgMSwgNiwgMjU1LCAxLCAxLCA4LCAyNTUsIDIsIDEsIDEwLCAyNTUsIDIsIDIsIDEyLCAyNTUsIDIsIDIsIDE0LCAyNTUsIDMsIDIsIDE2LCAyNTUsIDQsIDMsIDE4LCAyNTUsIDQsIDMsIDIwLCAyNTUsIDUsIDQsIDIzLCAyNTUsIDYsIDQsIDI1LCAyNTUsIDcsIDUsIDI3LCAyNTUsIDgsIDUsIDI5LCAyNTUsIDksIDYsIDMxLCAyNTUsIDEwLCA3LCAzNCwgMjU1LCAxMSwgNywgMzYsIDI1NSwgMTIsIDgsIDM4LCAyNTUsIDEzLCA4LCA0MSwgMjU1LCAxNCwgOSwgNDMsIDI1NSwgMTYsIDksIDQ1LCAyNTUsIDE3LCAxMCwgNDgsIDI1NSwgMTgsIDEwLCA1MCwgMjU1LCAyMCwgMTEsIDUyLCAyNTUsIDIxLCAxMSwgNTUsIDI1NSwgMjIsIDExLCA1NywgMjU1LCAyNCwgMTIsIDYwLCAyNTUsIDI1LCAxMiwgNjIsIDI1NSwgMjcsIDEyLCA2NSwgMjU1LCAyOCwgMTIsIDY3LCAyNTUsIDMwLCAxMiwgNjksIDI1NSwgMzEsIDEyLCA3MiwgMjU1LCAzMywgMTIsIDc0LCAyNTUsIDM1LCAxMiwgNzYsIDI1NSwgMzYsIDEyLCA3OSwgMjU1LCAzOCwgMTIsIDgxLCAyNTUsIDQwLCAxMSwgODMsIDI1NSwgNDEsIDExLCA4NSwgMjU1LCA0MywgMTEsIDg3LCAyNTUsIDQ1LCAxMSwgODksIDI1NSwgNDcsIDEwLCA5MSwgMjU1LCA0OSwgMTAsIDkyLCAyNTUsIDUwLCAxMCwgOTQsIDI1NSwgNTIsIDEwLCA5NSwgMjU1LCA1NCwgOSwgOTcsIDI1NSwgNTYsIDksIDk4LCAyNTUsIDU3LCA5LCA5OSwgMjU1LCA1OSwgOSwgMTAwLCAyNTUsIDYxLCA5LCAxMDEsIDI1NSwgNjIsIDksIDEwMiwgMjU1LCA2NCwgMTAsIDEwMywgMjU1LCA2NiwgMTAsIDEwNCwgMjU1LCA2OCwgMTAsIDEwNCwgMjU1LCA2OSwgMTAsIDEwNSwgMjU1LCA3MSwgMTEsIDEwNiwgMjU1LCA3MywgMTEsIDEwNiwgMjU1LCA3NCwgMTIsIDEwNywgMjU1LCA3NiwgMTIsIDEwNywgMjU1LCA3NywgMTMsIDEwOCwgMjU1LCA3OSwgMTMsIDEwOCwgMjU1LCA4MSwgMTQsIDEwOCwgMjU1LCA4MiwgMTQsIDEwOSwgMjU1LCA4NCwgMTUsIDEwOSwgMjU1LCA4NSwgMTUsIDEwOSwgMjU1LCA4NywgMTYsIDExMCwgMjU1LCA4OSwgMTYsIDExMCwgMjU1LCA5MCwgMTcsIDExMCwgMjU1LCA5MiwgMTgsIDExMCwgMjU1LCA5MywgMTgsIDExMCwgMjU1LCA5NSwgMTksIDExMCwgMjU1LCA5NywgMTksIDExMCwgMjU1LCA5OCwgMjAsIDExMCwgMjU1LCAxMDAsIDIxLCAxMTAsIDI1NSwgMTAxLCAyMSwgMTEwLCAyNTUsIDEwMywgMjIsIDExMCwgMjU1LCAxMDUsIDIyLCAxMTAsIDI1NSwgMTA2LCAyMywgMTEwLCAyNTUsIDEwOCwgMjQsIDExMCwgMjU1LCAxMDksIDI0LCAxMTAsIDI1NSwgMTExLCAyNSwgMTEwLCAyNTUsIDExMywgMjUsIDExMCwgMjU1LCAxMTQsIDI2LCAxMTAsIDI1NSwgMTE2LCAyNiwgMTEwLCAyNTUsIDExNywgMjcsIDExMCwgMjU1LCAxMTksIDI4LCAxMDksIDI1NSwgMTIwLCAyOCwgMTA5LCAyNTUsIDEyMiwgMjksIDEwOSwgMjU1LCAxMjQsIDI5LCAxMDksIDI1NSwgMTI1LCAzMCwgMTA5LCAyNTUsIDEyNywgMzAsIDEwOCwgMjU1LCAxMjgsIDMxLCAxMDgsIDI1NSwgMTMwLCAzMiwgMTA4LCAyNTUsIDEzMiwgMzIsIDEwNywgMjU1LCAxMzMsIDMzLCAxMDcsIDI1NSwgMTM1LCAzMywgMTA3LCAyNTUsIDEzNiwgMzQsIDEwNiwgMjU1LCAxMzgsIDM0LCAxMDYsIDI1NSwgMTQwLCAzNSwgMTA1LCAyNTUsIDE0MSwgMzUsIDEwNSwgMjU1LCAxNDMsIDM2LCAxMDUsIDI1NSwgMTQ0LCAzNywgMTA0LCAyNTUsIDE0NiwgMzcsIDEwNCwgMjU1LCAxNDcsIDM4LCAxMDMsIDI1NSwgMTQ5LCAzOCwgMTAzLCAyNTUsIDE1MSwgMzksIDEwMiwgMjU1LCAxNTIsIDM5LCAxMDIsIDI1NSwgMTU0LCA0MCwgMTAxLCAyNTUsIDE1NSwgNDEsIDEwMCwgMjU1LCAxNTcsIDQxLCAxMDAsIDI1NSwgMTU5LCA0MiwgOTksIDI1NSwgMTYwLCA0MiwgOTksIDI1NSwgMTYyLCA0MywgOTgsIDI1NSwgMTYzLCA0NCwgOTcsIDI1NSwgMTY1LCA0NCwgOTYsIDI1NSwgMTY2LCA0NSwgOTYsIDI1NSwgMTY4LCA0NiwgOTUsIDI1NSwgMTY5LCA0NiwgOTQsIDI1NSwgMTcxLCA0NywgOTQsIDI1NSwgMTczLCA0OCwgOTMsIDI1NSwgMTc0LCA0OCwgOTIsIDI1NSwgMTc2LCA0OSwgOTEsIDI1NSwgMTc3LCA1MCwgOTAsIDI1NSwgMTc5LCA1MCwgOTAsIDI1NSwgMTgwLCA1MSwgODksIDI1NSwgMTgyLCA1MiwgODgsIDI1NSwgMTgzLCA1MywgODcsIDI1NSwgMTg1LCA1MywgODYsIDI1NSwgMTg2LCA1NCwgODUsIDI1NSwgMTg4LCA1NSwgODQsIDI1NSwgMTg5LCA1NiwgODMsIDI1NSwgMTkxLCA1NywgODIsIDI1NSwgMTkyLCA1OCwgODEsIDI1NSwgMTkzLCA1OCwgODAsIDI1NSwgMTk1LCA1OSwgNzksIDI1NSwgMTk2LCA2MCwgNzgsIDI1NSwgMTk4LCA2MSwgNzcsIDI1NSwgMTk5LCA2MiwgNzYsIDI1NSwgMjAwLCA2MywgNzUsIDI1NSwgMjAyLCA2NCwgNzQsIDI1NSwgMjAzLCA2NSwgNzMsIDI1NSwgMjA0LCA2NiwgNzIsIDI1NSwgMjA2LCA2NywgNzEsIDI1NSwgMjA3LCA2OCwgNzAsIDI1NSwgMjA4LCA2OSwgNjksIDI1NSwgMjEwLCA3MCwgNjgsIDI1NSwgMjExLCA3MSwgNjcsIDI1NSwgMjEyLCA3MiwgNjYsIDI1NSwgMjEzLCA3NCwgNjUsIDI1NSwgMjE1LCA3NSwgNjMsIDI1NSwgMjE2LCA3NiwgNjIsIDI1NSwgMjE3LCA3NywgNjEsIDI1NSwgMjE4LCA3OCwgNjAsIDI1NSwgMjE5LCA4MCwgNTksIDI1NSwgMjIxLCA4MSwgNTgsIDI1NSwgMjIyLCA4MiwgNTYsIDI1NSwgMjIzLCA4MywgNTUsIDI1NSwgMjI0LCA4NSwgNTQsIDI1NSwgMjI1LCA4NiwgNTMsIDI1NSwgMjI2LCA4NywgNTIsIDI1NSwgMjI3LCA4OSwgNTEsIDI1NSwgMjI4LCA5MCwgNDksIDI1NSwgMjI5LCA5MiwgNDgsIDI1NSwgMjMwLCA5MywgNDcsIDI1NSwgMjMxLCA5NCwgNDYsIDI1NSwgMjMyLCA5NiwgNDUsIDI1NSwgMjMzLCA5NywgNDMsIDI1NSwgMjM0LCA5OSwgNDIsIDI1NSwgMjM1LCAxMDAsIDQxLCAyNTUsIDIzNSwgMTAyLCA0MCwgMjU1LCAyMzYsIDEwMywgMzgsIDI1NSwgMjM3LCAxMDUsIDM3LCAyNTUsIDIzOCwgMTA2LCAzNiwgMjU1LCAyMzksIDEwOCwgMzUsIDI1NSwgMjM5LCAxMTAsIDMzLCAyNTUsIDI0MCwgMTExLCAzMiwgMjU1LCAyNDEsIDExMywgMzEsIDI1NSwgMjQxLCAxMTUsIDI5LCAyNTUsIDI0MiwgMTE2LCAyOCwgMjU1LCAyNDMsIDExOCwgMjcsIDI1NSwgMjQzLCAxMjAsIDI1LCAyNTUsIDI0NCwgMTIxLCAyNCwgMjU1LCAyNDUsIDEyMywgMjMsIDI1NSwgMjQ1LCAxMjUsIDIxLCAyNTUsIDI0NiwgMTI2LCAyMCwgMjU1LCAyNDYsIDEyOCwgMTksIDI1NSwgMjQ3LCAxMzAsIDE4LCAyNTUsIDI0NywgMTMyLCAxNiwgMjU1LCAyNDgsIDEzMywgMTUsIDI1NSwgMjQ4LCAxMzUsIDE0LCAyNTUsIDI0OCwgMTM3LCAxMiwgMjU1LCAyNDksIDEzOSwgMTEsIDI1NSwgMjQ5LCAxNDAsIDEwLCAyNTUsIDI0OSwgMTQyLCA5LCAyNTUsIDI1MCwgMTQ0LCA4LCAyNTUsIDI1MCwgMTQ2LCA3LCAyNTUsIDI1MCwgMTQ4LCA3LCAyNTUsIDI1MSwgMTUwLCA2LCAyNTUsIDI1MSwgMTUxLCA2LCAyNTUsIDI1MSwgMTUzLCA2LCAyNTUsIDI1MSwgMTU1LCA2LCAyNTUsIDI1MSwgMTU3LCA3LCAyNTUsIDI1MiwgMTU5LCA3LCAyNTUsIDI1MiwgMTYxLCA4LCAyNTUsIDI1MiwgMTYzLCA5LCAyNTUsIDI1MiwgMTY1LCAxMCwgMjU1LCAyNTIsIDE2NiwgMTIsIDI1NSwgMjUyLCAxNjgsIDEzLCAyNTUsIDI1MiwgMTcwLCAxNSwgMjU1LCAyNTIsIDE3MiwgMTcsIDI1NSwgMjUyLCAxNzQsIDE4LCAyNTUsIDI1MiwgMTc2LCAyMCwgMjU1LCAyNTIsIDE3OCwgMjIsIDI1NSwgMjUyLCAxODAsIDI0LCAyNTUsIDI1MSwgMTgyLCAyNiwgMjU1LCAyNTEsIDE4NCwgMjksIDI1NSwgMjUxLCAxODYsIDMxLCAyNTUsIDI1MSwgMTg4LCAzMywgMjU1LCAyNTEsIDE5MCwgMzUsIDI1NSwgMjUwLCAxOTIsIDM4LCAyNTUsIDI1MCwgMTk0LCA0MCwgMjU1LCAyNTAsIDE5NiwgNDIsIDI1NSwgMjUwLCAxOTgsIDQ1LCAyNTUsIDI0OSwgMTk5LCA0NywgMjU1LCAyNDksIDIwMSwgNTAsIDI1NSwgMjQ5LCAyMDMsIDUzLCAyNTUsIDI0OCwgMjA1LCA1NSwgMjU1LCAyNDgsIDIwNywgNTgsIDI1NSwgMjQ3LCAyMDksIDYxLCAyNTUsIDI0NywgMjExLCA2NCwgMjU1LCAyNDYsIDIxMywgNjcsIDI1NSwgMjQ2LCAyMTUsIDcwLCAyNTUsIDI0NSwgMjE3LCA3MywgMjU1LCAyNDUsIDIxOSwgNzYsIDI1NSwgMjQ0LCAyMjEsIDc5LCAyNTUsIDI0NCwgMjIzLCA4MywgMjU1LCAyNDQsIDIyNSwgODYsIDI1NSwgMjQzLCAyMjcsIDkwLCAyNTUsIDI0MywgMjI5LCA5MywgMjU1LCAyNDIsIDIzMCwgOTcsIDI1NSwgMjQyLCAyMzIsIDEwMSwgMjU1LCAyNDIsIDIzNCwgMTA1LCAyNTUsIDI0MSwgMjM2LCAxMDksIDI1NSwgMjQxLCAyMzcsIDExMywgMjU1LCAyNDEsIDIzOSwgMTE3LCAyNTUsIDI0MSwgMjQxLCAxMjEsIDI1NSwgMjQyLCAyNDIsIDEyNSwgMjU1LCAyNDIsIDI0NCwgMTMwLCAyNTUsIDI0MywgMjQ1LCAxMzQsIDI1NSwgMjQzLCAyNDYsIDEzOCwgMjU1LCAyNDQsIDI0OCwgMTQyLCAyNTUsIDI0NSwgMjQ5LCAxNDYsIDI1NSwgMjQ2LCAyNTAsIDE1MCwgMjU1LCAyNDgsIDI1MSwgMTU0LCAyNTUsIDI0OSwgMjUyLCAxNTcsIDI1NSwgMjUwLCAyNTMsIDE2MSwgMjU1LCAyNTIsIDI1NSwgMTY0LCAyNTVdKSxcbiAgdHVyYm86IG5ldyBVaW50OEFycmF5KFs0OCwgMTgsIDU5LCAyNTUsIDUwLCAyMSwgNjcsIDI1NSwgNTEsIDI0LCA3NCwgMjU1LCA1MiwgMjcsIDgxLCAyNTUsIDUzLCAzMCwgODgsIDI1NSwgNTQsIDMzLCA5NSwgMjU1LCA1NSwgMzYsIDEwMiwgMjU1LCA1NiwgMzksIDEwOSwgMjU1LCA1NywgNDIsIDExNSwgMjU1LCA1OCwgNDUsIDEyMSwgMjU1LCA1OSwgNDcsIDEyOCwgMjU1LCA2MCwgNTAsIDEzNCwgMjU1LCA2MSwgNTMsIDEzOSwgMjU1LCA2MiwgNTYsIDE0NSwgMjU1LCA2MywgNTksIDE1MSwgMjU1LCA2MywgNjIsIDE1NiwgMjU1LCA2NCwgNjQsIDE2MiwgMjU1LCA2NSwgNjcsIDE2NywgMjU1LCA2NSwgNzAsIDE3MiwgMjU1LCA2NiwgNzMsIDE3NywgMjU1LCA2NiwgNzUsIDE4MSwgMjU1LCA2NywgNzgsIDE4NiwgMjU1LCA2OCwgODEsIDE5MSwgMjU1LCA2OCwgODQsIDE5NSwgMjU1LCA2OCwgODYsIDE5OSwgMjU1LCA2OSwgODksIDIwMywgMjU1LCA2OSwgOTIsIDIwNywgMjU1LCA2OSwgOTQsIDIxMSwgMjU1LCA3MCwgOTcsIDIxNCwgMjU1LCA3MCwgMTAwLCAyMTgsIDI1NSwgNzAsIDEwMiwgMjIxLCAyNTUsIDcwLCAxMDUsIDIyNCwgMjU1LCA3MCwgMTA3LCAyMjcsIDI1NSwgNzEsIDExMCwgMjMwLCAyNTUsIDcxLCAxMTMsIDIzMywgMjU1LCA3MSwgMTE1LCAyMzUsIDI1NSwgNzEsIDExOCwgMjM4LCAyNTUsIDcxLCAxMjAsIDI0MCwgMjU1LCA3MSwgMTIzLCAyNDIsIDI1NSwgNzAsIDEyNSwgMjQ0LCAyNTUsIDcwLCAxMjgsIDI0NiwgMjU1LCA3MCwgMTMwLCAyNDgsIDI1NSwgNzAsIDEzMywgMjUwLCAyNTUsIDcwLCAxMzUsIDI1MSwgMjU1LCA2OSwgMTM4LCAyNTIsIDI1NSwgNjksIDE0MCwgMjUzLCAyNTUsIDY4LCAxNDMsIDI1NCwgMjU1LCA2NywgMTQ1LCAyNTQsIDI1NSwgNjYsIDE0OCwgMjU1LCAyNTUsIDY1LCAxNTAsIDI1NSwgMjU1LCA2NCwgMTUzLCAyNTUsIDI1NSwgNjIsIDE1NSwgMjU0LCAyNTUsIDYxLCAxNTgsIDI1NCwgMjU1LCA1OSwgMTYwLCAyNTMsIDI1NSwgNTgsIDE2MywgMjUyLCAyNTUsIDU2LCAxNjUsIDI1MSwgMjU1LCA1NSwgMTY4LCAyNTAsIDI1NSwgNTMsIDE3MSwgMjQ4LCAyNTUsIDUxLCAxNzMsIDI0NywgMjU1LCA0OSwgMTc1LCAyNDUsIDI1NSwgNDcsIDE3OCwgMjQ0LCAyNTUsIDQ2LCAxODAsIDI0MiwgMjU1LCA0NCwgMTgzLCAyNDAsIDI1NSwgNDIsIDE4NSwgMjM4LCAyNTUsIDQwLCAxODgsIDIzNSwgMjU1LCAzOSwgMTkwLCAyMzMsIDI1NSwgMzcsIDE5MiwgMjMxLCAyNTUsIDM1LCAxOTUsIDIyOCwgMjU1LCAzNCwgMTk3LCAyMjYsIDI1NSwgMzIsIDE5OSwgMjIzLCAyNTUsIDMxLCAyMDEsIDIyMSwgMjU1LCAzMCwgMjAzLCAyMTgsIDI1NSwgMjgsIDIwNSwgMjE2LCAyNTUsIDI3LCAyMDgsIDIxMywgMjU1LCAyNiwgMjEwLCAyMTAsIDI1NSwgMjYsIDIxMiwgMjA4LCAyNTUsIDI1LCAyMTMsIDIwNSwgMjU1LCAyNCwgMjE1LCAyMDIsIDI1NSwgMjQsIDIxNywgMjAwLCAyNTUsIDI0LCAyMTksIDE5NywgMjU1LCAyNCwgMjIxLCAxOTQsIDI1NSwgMjQsIDIyMiwgMTkyLCAyNTUsIDI0LCAyMjQsIDE4OSwgMjU1LCAyNSwgMjI2LCAxODcsIDI1NSwgMjUsIDIyNywgMTg1LCAyNTUsIDI2LCAyMjgsIDE4MiwgMjU1LCAyOCwgMjMwLCAxODAsIDI1NSwgMjksIDIzMSwgMTc4LCAyNTUsIDMxLCAyMzMsIDE3NSwgMjU1LCAzMiwgMjM0LCAxNzIsIDI1NSwgMzQsIDIzNSwgMTcwLCAyNTUsIDM3LCAyMzYsIDE2NywgMjU1LCAzOSwgMjM4LCAxNjQsIDI1NSwgNDIsIDIzOSwgMTYxLCAyNTUsIDQ0LCAyNDAsIDE1OCwgMjU1LCA0NywgMjQxLCAxNTUsIDI1NSwgNTAsIDI0MiwgMTUyLCAyNTUsIDUzLCAyNDMsIDE0OCwgMjU1LCA1NiwgMjQ0LCAxNDUsIDI1NSwgNjAsIDI0NSwgMTQyLCAyNTUsIDYzLCAyNDYsIDEzOCwgMjU1LCA2NywgMjQ3LCAxMzUsIDI1NSwgNzAsIDI0OCwgMTMyLCAyNTUsIDc0LCAyNDgsIDEyOCwgMjU1LCA3OCwgMjQ5LCAxMjUsIDI1NSwgODIsIDI1MCwgMTIyLCAyNTUsIDg1LCAyNTAsIDExOCwgMjU1LCA4OSwgMjUxLCAxMTUsIDI1NSwgOTMsIDI1MiwgMTExLCAyNTUsIDk3LCAyNTIsIDEwOCwgMjU1LCAxMDEsIDI1MywgMTA1LCAyNTUsIDEwNSwgMjUzLCAxMDIsIDI1NSwgMTA5LCAyNTQsIDk4LCAyNTUsIDExMywgMjU0LCA5NSwgMjU1LCAxMTcsIDI1NCwgOTIsIDI1NSwgMTIxLCAyNTQsIDg5LCAyNTUsIDEyNSwgMjU1LCA4NiwgMjU1LCAxMjgsIDI1NSwgODMsIDI1NSwgMTMyLCAyNTUsIDgxLCAyNTUsIDEzNiwgMjU1LCA3OCwgMjU1LCAxMzksIDI1NSwgNzUsIDI1NSwgMTQzLCAyNTUsIDczLCAyNTUsIDE0NiwgMjU1LCA3MSwgMjU1LCAxNTAsIDI1NCwgNjgsIDI1NSwgMTUzLCAyNTQsIDY2LCAyNTUsIDE1NiwgMjU0LCA2NCwgMjU1LCAxNTksIDI1MywgNjMsIDI1NSwgMTYxLCAyNTMsIDYxLCAyNTUsIDE2NCwgMjUyLCA2MCwgMjU1LCAxNjcsIDI1MiwgNTgsIDI1NSwgMTY5LCAyNTEsIDU3LCAyNTUsIDE3MiwgMjUxLCA1NiwgMjU1LCAxNzUsIDI1MCwgNTUsIDI1NSwgMTc3LCAyNDksIDU0LCAyNTUsIDE4MCwgMjQ4LCA1NCwgMjU1LCAxODMsIDI0NywgNTMsIDI1NSwgMTg1LCAyNDYsIDUzLCAyNTUsIDE4OCwgMjQ1LCA1MiwgMjU1LCAxOTAsIDI0NCwgNTIsIDI1NSwgMTkzLCAyNDMsIDUyLCAyNTUsIDE5NSwgMjQxLCA1MiwgMjU1LCAxOTgsIDI0MCwgNTIsIDI1NSwgMjAwLCAyMzksIDUyLCAyNTUsIDIwMywgMjM3LCA1MiwgMjU1LCAyMDUsIDIzNiwgNTIsIDI1NSwgMjA4LCAyMzQsIDUyLCAyNTUsIDIxMCwgMjMzLCA1MywgMjU1LCAyMTIsIDIzMSwgNTMsIDI1NSwgMjE1LCAyMjksIDUzLCAyNTUsIDIxNywgMjI4LCA1NCwgMjU1LCAyMTksIDIyNiwgNTQsIDI1NSwgMjIxLCAyMjQsIDU1LCAyNTUsIDIyMywgMjIzLCA1NSwgMjU1LCAyMjUsIDIyMSwgNTUsIDI1NSwgMjI3LCAyMTksIDU2LCAyNTUsIDIyOSwgMjE3LCA1NiwgMjU1LCAyMzEsIDIxNSwgNTcsIDI1NSwgMjMzLCAyMTMsIDU3LCAyNTUsIDIzNSwgMjExLCA1NywgMjU1LCAyMzYsIDIwOSwgNTgsIDI1NSwgMjM4LCAyMDcsIDU4LCAyNTUsIDIzOSwgMjA1LCA1OCwgMjU1LCAyNDEsIDIwMywgNTgsIDI1NSwgMjQyLCAyMDEsIDU4LCAyNTUsIDI0NCwgMTk5LCA1OCwgMjU1LCAyNDUsIDE5NywgNTgsIDI1NSwgMjQ2LCAxOTUsIDU4LCAyNTUsIDI0NywgMTkzLCA1OCwgMjU1LCAyNDgsIDE5MCwgNTcsIDI1NSwgMjQ5LCAxODgsIDU3LCAyNTUsIDI1MCwgMTg2LCA1NywgMjU1LCAyNTEsIDE4NCwgNTYsIDI1NSwgMjUxLCAxODIsIDU1LCAyNTUsIDI1MiwgMTc5LCA1NCwgMjU1LCAyNTIsIDE3NywgNTQsIDI1NSwgMjUzLCAxNzQsIDUzLCAyNTUsIDI1MywgMTcyLCA1MiwgMjU1LCAyNTQsIDE2OSwgNTEsIDI1NSwgMjU0LCAxNjcsIDUwLCAyNTUsIDI1NCwgMTY0LCA0OSwgMjU1LCAyNTQsIDE2MSwgNDgsIDI1NSwgMjU0LCAxNTgsIDQ3LCAyNTUsIDI1NCwgMTU1LCA0NSwgMjU1LCAyNTQsIDE1MywgNDQsIDI1NSwgMjU0LCAxNTAsIDQzLCAyNTUsIDI1NCwgMTQ3LCA0MiwgMjU1LCAyNTQsIDE0NCwgNDEsIDI1NSwgMjUzLCAxNDEsIDM5LCAyNTUsIDI1MywgMTM4LCAzOCwgMjU1LCAyNTIsIDEzNSwgMzcsIDI1NSwgMjUyLCAxMzIsIDM1LCAyNTUsIDI1MSwgMTI5LCAzNCwgMjU1LCAyNTEsIDEyNiwgMzMsIDI1NSwgMjUwLCAxMjMsIDMxLCAyNTUsIDI0OSwgMTIwLCAzMCwgMjU1LCAyNDksIDExNywgMjksIDI1NSwgMjQ4LCAxMTQsIDI4LCAyNTUsIDI0NywgMTExLCAyNiwgMjU1LCAyNDYsIDEwOCwgMjUsIDI1NSwgMjQ1LCAxMDUsIDI0LCAyNTUsIDI0NCwgMTAyLCAyMywgMjU1LCAyNDMsIDk5LCAyMSwgMjU1LCAyNDIsIDk2LCAyMCwgMjU1LCAyNDEsIDkzLCAxOSwgMjU1LCAyNDAsIDkxLCAxOCwgMjU1LCAyMzksIDg4LCAxNywgMjU1LCAyMzcsIDg1LCAxNiwgMjU1LCAyMzYsIDgzLCAxNSwgMjU1LCAyMzUsIDgwLCAxNCwgMjU1LCAyMzQsIDc4LCAxMywgMjU1LCAyMzIsIDc1LCAxMiwgMjU1LCAyMzEsIDczLCAxMiwgMjU1LCAyMjksIDcxLCAxMSwgMjU1LCAyMjgsIDY5LCAxMCwgMjU1LCAyMjYsIDY3LCAxMCwgMjU1LCAyMjUsIDY1LCA5LCAyNTUsIDIyMywgNjMsIDgsIDI1NSwgMjIxLCA2MSwgOCwgMjU1LCAyMjAsIDU5LCA3LCAyNTUsIDIxOCwgNTcsIDcsIDI1NSwgMjE2LCA1NSwgNiwgMjU1LCAyMTQsIDUzLCA2LCAyNTUsIDIxMiwgNTEsIDUsIDI1NSwgMjEwLCA0OSwgNSwgMjU1LCAyMDgsIDQ3LCA1LCAyNTUsIDIwNiwgNDUsIDQsIDI1NSwgMjA0LCA0MywgNCwgMjU1LCAyMDIsIDQyLCA0LCAyNTUsIDIwMCwgNDAsIDMsIDI1NSwgMTk3LCAzOCwgMywgMjU1LCAxOTUsIDM3LCAzLCAyNTUsIDE5MywgMzUsIDIsIDI1NSwgMTkwLCAzMywgMiwgMjU1LCAxODgsIDMyLCAyLCAyNTUsIDE4NSwgMzAsIDIsIDI1NSwgMTgzLCAyOSwgMiwgMjU1LCAxODAsIDI3LCAxLCAyNTUsIDE3OCwgMjYsIDEsIDI1NSwgMTc1LCAyNCwgMSwgMjU1LCAxNzIsIDIzLCAxLCAyNTUsIDE2OSwgMjIsIDEsIDI1NSwgMTY3LCAyMCwgMSwgMjU1LCAxNjQsIDE5LCAxLCAyNTUsIDE2MSwgMTgsIDEsIDI1NSwgMTU4LCAxNiwgMSwgMjU1LCAxNTUsIDE1LCAxLCAyNTUsIDE1MiwgMTQsIDEsIDI1NSwgMTQ5LCAxMywgMSwgMjU1LCAxNDYsIDExLCAxLCAyNTUsIDE0MiwgMTAsIDEsIDI1NSwgMTM5LCA5LCAyLCAyNTUsIDEzNiwgOCwgMiwgMjU1LCAxMzMsIDcsIDIsIDI1NSwgMTI5LCA2LCAyLCAyNTUsIDEyNiwgNSwgMiwgMjU1LCAxMjIsIDQsIDMsIDI1NV0pLFxuICByYWluYm93OiB7XG4gICAgY29sb3JzOiBbXCIjOTYwMDVBXCIsIFwiIzAwMDBDOFwiLCBcIiMwMDE5RkZcIiwgXCIjMDA5OEZGXCIsIFwiIzJDRkY5NlwiLCBcIiM5N0ZGMDBcIiwgXCIjRkZFQTAwXCIsIFwiI0ZGNkYwMFwiLCBcIiNGRjAwMDBcIl0sXG4gICAgcG9zaXRpb25zOiBbMCwgMC4xMjUsIDAuMjUsIDAuMzc1LCAwLjUsIDAuNjI1LCAwLjc1LCAwLjg3NSwgMV1cbiAgfSxcbiAgamV0OiB7XG4gICAgY29sb3JzOiBbXCIjMDAwMDgzXCIsIFwiIzAwM0NBQVwiLCBcIiMwNUZGRkZcIiwgXCIjRkZGRjAwXCIsIFwiI0ZBMDAwMFwiLCBcIiM4MDAwMDBcIl0sXG4gICAgcG9zaXRpb25zOiBbMCwgMC4xMjUsIDAuMzc1LCAwLjYyNSwgMC44NzUsIDFdXG4gIH0sXG4gIGhzdjoge1xuICAgIGNvbG9yczogW1wiI2ZmMDAwMFwiLCBcIiNmZGZmMDJcIiwgXCIjZjdmZjAyXCIsIFwiIzAwZmMwNFwiLCBcIiMwMGZjMGFcIiwgXCIjMDFmOWZmXCIsIFwiIzAyMDBmZFwiLCBcIiMwODAwZmRcIiwgXCIjZmYwMGZiXCIsIFwiI2ZmMDBmNVwiLCBcIiNmZjAwMDZcIl0sXG4gICAgcG9zaXRpb25zOiBbMCwgMC4xNjksIDAuMTczLCAwLjMzNywgMC4zNDEsIDAuNTA2LCAwLjY3MSwgMC42NzUsIDAuODM5LCAwLjg0MywgMV1cbiAgfSxcbiAgaG90OiB7XG4gICAgY29sb3JzOiBbXCIjMDAwMDAwXCIsIFwiI2U2MDAwMFwiLCBcIiNmZmQyMDBcIiwgXCIjZmZmZmZmXCJdLFxuICAgIHBvc2l0aW9uczogWzAsIDAuMywgMC42LCAxXVxuICB9LFxuICBjb29sOiB7XG4gICAgY29sb3JzOiBbXCIjMDBmZmZmXCIsIFwiI2ZmMDBmZlwiXSxcbiAgICBwb3NpdGlvbnM6IFswLCAxXVxuICB9LFxuICBzcHJpbmc6IHtcbiAgICBjb2xvcnM6IFtcIiNmZjAwZmZcIiwgXCIjZmZmZjAwXCJdLFxuICAgIHBvc2l0aW9uczogWzAsIDFdXG4gIH0sXG4gIHN1bW1lcjoge1xuICAgIGNvbG9yczogW1wiIzAwODA2NlwiLCBcIiNmZmZmNjZcIl0sXG4gICAgcG9zaXRpb25zOiBbMCwgMV1cbiAgfSxcbiAgYXV0dW1uOiB7XG4gICAgY29sb3JzOiBbXCIjZmYwMDAwXCIsIFwiI2ZmZmYwMFwiXSxcbiAgICBwb3NpdGlvbnM6IFswLCAxXVxuICB9LFxuICB3aW50ZXI6IHtcbiAgICBjb2xvcnM6IFtcIiMwMDAwZmZcIiwgXCIjMDBmZjgwXCJdLFxuICAgIHBvc2l0aW9uczogWzAsIDFdXG4gIH0sXG4gIGJvbmU6IHtcbiAgICBjb2xvcnM6IFtcIiMwMDAwMDBcIiwgXCIjNTQ1NDc0XCIsIFwiI2E5YzhjOFwiLCBcIiNmZmZmZmZcIl0sXG4gICAgcG9zaXRpb25zOiBbMCwgMC4zNzYsIDAuNzUzLCAxXVxuICB9LFxuICBjb3BwZXI6IHtcbiAgICBjb2xvcnM6IFtcIiMwMDAwMDBcIiwgXCIjZmZhMDY2XCIsIFwiI2ZmYzc3ZlwiXSxcbiAgICBwb3NpdGlvbnM6IFswLCAwLjgwNCwgMV1cbiAgfSxcbiAgZ3JleXM6IHtcbiAgICBjb2xvcnM6IFtcIiMwMDAwMDBcIiwgXCIjZmZmZmZmXCJdLFxuICAgIHBvc2l0aW9uczogWzAsIDFdXG4gIH0sXG4gIHlsZ25idToge1xuICAgIGNvbG9yczogW1wiIzA4MWQ1OFwiLCBcIiMyNTM0OTRcIiwgXCIjMjI1ZWE4XCIsIFwiIzFkOTFjMFwiLCBcIiM0MWI2YzRcIiwgXCIjN2ZjZGJiXCIsIFwiI2M3ZTliNFwiLCBcIiNlZGY4ZDlcIiwgXCIjZmZmZmQ5XCJdLFxuICAgIHBvc2l0aW9uczogWzAsIDAuMTI1LCAwLjI1LCAwLjM3NSwgMC41LCAwLjYyNSwgMC43NSwgMC44NzUsIDFdXG4gIH0sXG4gIGdyZWVuczoge1xuICAgIGNvbG9yczogW1wiIzAwNDQxYlwiLCBcIiMwMDZkMmNcIiwgXCIjMjM4YjQ1XCIsIFwiIzQxYWI1ZFwiLCBcIiM3NGM0NzZcIiwgXCIjYTFkOTliXCIsIFwiI2M3ZTljMFwiLCBcIiNlNWY1ZTBcIiwgXCIjZjdmY2Y1XCJdLFxuICAgIHBvc2l0aW9uczogWzAsIDAuMTI1LCAwLjI1LCAwLjM3NSwgMC41LCAwLjYyNSwgMC43NSwgMC44NzUsIDFdXG4gIH0sXG4gIHlsb3JyZDoge1xuICAgIGNvbG9yczogW1wiIzgwMDAyNlwiLCBcIiNiZDAwMjZcIiwgXCIjZTMxYTFjXCIsIFwiI2ZjNGUyYVwiLCBcIiNmZDhkM2NcIiwgXCIjZmViMjRjXCIsIFwiI2ZlZDk3NlwiLCBcIiNmZmVkYTBcIiwgXCIjZmZmZmNjXCJdLFxuICAgIHBvc2l0aW9uczogWzAsIDAuMTI1LCAwLjI1LCAwLjM3NSwgMC41LCAwLjYyNSwgMC43NSwgMC44NzUsIDFdXG4gIH0sXG4gIGJsdWVyZWQ6IHtcbiAgICBjb2xvcnM6IFtcIiMwMDAwZmZcIiwgXCIjZmYwMDAwXCJdLFxuICAgIHBvc2l0aW9uczogWzAsIDFdXG4gIH0sXG4gIHJkYnU6IHtcbiAgICBjb2xvcnM6IFtcIiMwNTBhYWNcIiwgXCIjNmE4OWY3XCIsIFwiI2JlYmViZVwiLCBcIiNkY2FhODRcIiwgXCIjZTY5MTVhXCIsIFwiI2IyMGExY1wiXSxcbiAgICBwb3NpdGlvbnM6IFswLCAwLjM1LCAwLjUsIDAuNiwgMC43LCAxXVxuICB9LFxuICBwaWNuaWM6IHtcbiAgICBjb2xvcnM6IFtcIiMwMDAwZmZcIiwgXCIjMzM5OWZmXCIsIFwiIzY2Y2NmZlwiLCBcIiM5OWNjZmZcIiwgXCIjY2NjY2ZmXCIsIFwiI2ZmZmZmZlwiLCBcIiNmZmNjZmZcIiwgXCIjZmY5OWZmXCIsIFwiI2ZmNjZjY1wiLCBcIiNmZjY2NjZcIiwgXCIjZmYwMDAwXCJdLFxuICAgIHBvc2l0aW9uczogWzAsIDAuMSwgMC4yLCAwLjMsIDAuNCwgMC41LCAwLjYsIDAuNywgMC44LCAwLjksIDFdXG4gIH0sXG4gIHBvcnRsYW5kOiB7XG4gICAgY29sb3JzOiBbXCIjMGMzMzgzXCIsIFwiIzBhODhiYVwiLCBcIiNmMmQzMzhcIiwgXCIjZjI4ZjM4XCIsIFwiI2Q5MWUxZVwiXSxcbiAgICBwb3NpdGlvbnM6IFswLCAwLjI1LCAwLjUsIDAuNzUsIDFdXG4gIH0sXG4gIGJsYWNrYm9keToge1xuICAgIGNvbG9yczogW1wiIzAwMDAwMFwiLCBcIiNlNjAwMDBcIiwgXCIjZTZkMjAwXCIsIFwiI2ZmZmZmZlwiLCBcIiNhMGM4ZmZcIl0sXG4gICAgcG9zaXRpb25zOiBbMCwgMC4yLCAwLjQsIDAuNywgMV1cbiAgfSxcbiAgZWFydGg6IHtcbiAgICBjb2xvcnM6IFtcIiMwMDAwODJcIiwgXCIjMDBiNGI0XCIsIFwiIzI4ZDIyOFwiLCBcIiNlNmU2MzJcIiwgXCIjNzg0NjE0XCIsIFwiI2ZmZmZmZlwiXSxcbiAgICBwb3NpdGlvbnM6IFswLCAwLjEsIDAuMiwgMC40LCAwLjYsIDFdXG4gIH0sXG4gIGVsZWN0cmljOiB7XG4gICAgY29sb3JzOiBbXCIjMDAwMDAwXCIsIFwiIzFlMDA2NFwiLCBcIiM3ODAwNjRcIiwgXCIjYTA1YTAwXCIsIFwiI2U2YzgwMFwiLCBcIiNmZmZhZGNcIl0sXG4gICAgcG9zaXRpb25zOiBbMCwgMC4xNSwgMC40LCAwLjYsIDAuOCwgMV1cbiAgfSxcbiAgbWFnbWE6IG5ldyBVaW50OEFycmF5KFswLCAwLCA0LCAyNTUsIDEsIDAsIDUsIDI1NSwgMSwgMSwgNiwgMjU1LCAxLCAxLCA4LCAyNTUsIDIsIDEsIDksIDI1NSwgMiwgMiwgMTEsIDI1NSwgMiwgMiwgMTMsIDI1NSwgMywgMywgMTUsIDI1NSwgMywgMywgMTgsIDI1NSwgNCwgNCwgMjAsIDI1NSwgNSwgNCwgMjIsIDI1NSwgNiwgNSwgMjQsIDI1NSwgNiwgNSwgMjYsIDI1NSwgNywgNiwgMjgsIDI1NSwgOCwgNywgMzAsIDI1NSwgOSwgNywgMzIsIDI1NSwgMTAsIDgsIDM0LCAyNTUsIDExLCA5LCAzNiwgMjU1LCAxMiwgOSwgMzgsIDI1NSwgMTMsIDEwLCA0MSwgMjU1LCAxNCwgMTEsIDQzLCAyNTUsIDE2LCAxMSwgNDUsIDI1NSwgMTcsIDEyLCA0NywgMjU1LCAxOCwgMTMsIDQ5LCAyNTUsIDE5LCAxMywgNTIsIDI1NSwgMjAsIDE0LCA1NCwgMjU1LCAyMSwgMTQsIDU2LCAyNTUsIDIyLCAxNSwgNTksIDI1NSwgMjQsIDE1LCA2MSwgMjU1LCAyNSwgMTYsIDYzLCAyNTUsIDI2LCAxNiwgNjYsIDI1NSwgMjgsIDE2LCA2OCwgMjU1LCAyOSwgMTcsIDcxLCAyNTUsIDMwLCAxNywgNzMsIDI1NSwgMzIsIDE3LCA3NSwgMjU1LCAzMywgMTcsIDc4LCAyNTUsIDM0LCAxNywgODAsIDI1NSwgMzYsIDE4LCA4MywgMjU1LCAzNywgMTgsIDg1LCAyNTUsIDM5LCAxOCwgODgsIDI1NSwgNDEsIDE3LCA5MCwgMjU1LCA0MiwgMTcsIDkyLCAyNTUsIDQ0LCAxNywgOTUsIDI1NSwgNDUsIDE3LCA5NywgMjU1LCA0NywgMTcsIDk5LCAyNTUsIDQ5LCAxNywgMTAxLCAyNTUsIDUxLCAxNiwgMTAzLCAyNTUsIDUyLCAxNiwgMTA1LCAyNTUsIDU0LCAxNiwgMTA3LCAyNTUsIDU2LCAxNiwgMTA4LCAyNTUsIDU3LCAxNSwgMTEwLCAyNTUsIDU5LCAxNSwgMTEyLCAyNTUsIDYxLCAxNSwgMTEzLCAyNTUsIDYzLCAxNSwgMTE0LCAyNTUsIDY0LCAxNSwgMTE2LCAyNTUsIDY2LCAxNSwgMTE3LCAyNTUsIDY4LCAxNSwgMTE4LCAyNTUsIDY5LCAxNiwgMTE5LCAyNTUsIDcxLCAxNiwgMTIwLCAyNTUsIDczLCAxNiwgMTIwLCAyNTUsIDc0LCAxNiwgMTIxLCAyNTUsIDc2LCAxNywgMTIyLCAyNTUsIDc4LCAxNywgMTIzLCAyNTUsIDc5LCAxOCwgMTIzLCAyNTUsIDgxLCAxOCwgMTI0LCAyNTUsIDgyLCAxOSwgMTI0LCAyNTUsIDg0LCAxOSwgMTI1LCAyNTUsIDg2LCAyMCwgMTI1LCAyNTUsIDg3LCAyMSwgMTI2LCAyNTUsIDg5LCAyMSwgMTI2LCAyNTUsIDkwLCAyMiwgMTI2LCAyNTUsIDkyLCAyMiwgMTI3LCAyNTUsIDkzLCAyMywgMTI3LCAyNTUsIDk1LCAyNCwgMTI3LCAyNTUsIDk2LCAyNCwgMTI4LCAyNTUsIDk4LCAyNSwgMTI4LCAyNTUsIDEwMCwgMjYsIDEyOCwgMjU1LCAxMDEsIDI2LCAxMjgsIDI1NSwgMTAzLCAyNywgMTI4LCAyNTUsIDEwNCwgMjgsIDEyOSwgMjU1LCAxMDYsIDI4LCAxMjksIDI1NSwgMTA3LCAyOSwgMTI5LCAyNTUsIDEwOSwgMjksIDEyOSwgMjU1LCAxMTAsIDMwLCAxMjksIDI1NSwgMTEyLCAzMSwgMTI5LCAyNTUsIDExNCwgMzEsIDEyOSwgMjU1LCAxMTUsIDMyLCAxMjksIDI1NSwgMTE3LCAzMywgMTI5LCAyNTUsIDExOCwgMzMsIDEyOSwgMjU1LCAxMjAsIDM0LCAxMjksIDI1NSwgMTIxLCAzNCwgMTMwLCAyNTUsIDEyMywgMzUsIDEzMCwgMjU1LCAxMjQsIDM1LCAxMzAsIDI1NSwgMTI2LCAzNiwgMTMwLCAyNTUsIDEyOCwgMzcsIDEzMCwgMjU1LCAxMjksIDM3LCAxMjksIDI1NSwgMTMxLCAzOCwgMTI5LCAyNTUsIDEzMiwgMzgsIDEyOSwgMjU1LCAxMzQsIDM5LCAxMjksIDI1NSwgMTM2LCAzOSwgMTI5LCAyNTUsIDEzNywgNDAsIDEyOSwgMjU1LCAxMzksIDQxLCAxMjksIDI1NSwgMTQwLCA0MSwgMTI5LCAyNTUsIDE0MiwgNDIsIDEyOSwgMjU1LCAxNDQsIDQyLCAxMjksIDI1NSwgMTQ1LCA0MywgMTI5LCAyNTUsIDE0NywgNDMsIDEyOCwgMjU1LCAxNDgsIDQ0LCAxMjgsIDI1NSwgMTUwLCA0NCwgMTI4LCAyNTUsIDE1MiwgNDUsIDEyOCwgMjU1LCAxNTMsIDQ1LCAxMjgsIDI1NSwgMTU1LCA0NiwgMTI3LCAyNTUsIDE1NiwgNDYsIDEyNywgMjU1LCAxNTgsIDQ3LCAxMjcsIDI1NSwgMTYwLCA0NywgMTI3LCAyNTUsIDE2MSwgNDgsIDEyNiwgMjU1LCAxNjMsIDQ4LCAxMjYsIDI1NSwgMTY1LCA0OSwgMTI2LCAyNTUsIDE2NiwgNDksIDEyNSwgMjU1LCAxNjgsIDUwLCAxMjUsIDI1NSwgMTcwLCA1MSwgMTI1LCAyNTUsIDE3MSwgNTEsIDEyNCwgMjU1LCAxNzMsIDUyLCAxMjQsIDI1NSwgMTc0LCA1MiwgMTIzLCAyNTUsIDE3NiwgNTMsIDEyMywgMjU1LCAxNzgsIDUzLCAxMjMsIDI1NSwgMTc5LCA1NCwgMTIyLCAyNTUsIDE4MSwgNTQsIDEyMiwgMjU1LCAxODMsIDU1LCAxMjEsIDI1NSwgMTg0LCA1NSwgMTIxLCAyNTUsIDE4NiwgNTYsIDEyMCwgMjU1LCAxODgsIDU3LCAxMjAsIDI1NSwgMTg5LCA1NywgMTE5LCAyNTUsIDE5MSwgNTgsIDExOSwgMjU1LCAxOTIsIDU4LCAxMTgsIDI1NSwgMTk0LCA1OSwgMTE3LCAyNTUsIDE5NiwgNjAsIDExNywgMjU1LCAxOTcsIDYwLCAxMTYsIDI1NSwgMTk5LCA2MSwgMTE1LCAyNTUsIDIwMCwgNjIsIDExNSwgMjU1LCAyMDIsIDYyLCAxMTQsIDI1NSwgMjA0LCA2MywgMTEzLCAyNTUsIDIwNSwgNjQsIDExMywgMjU1LCAyMDcsIDY0LCAxMTIsIDI1NSwgMjA4LCA2NSwgMTExLCAyNTUsIDIxMCwgNjYsIDExMSwgMjU1LCAyMTEsIDY3LCAxMTAsIDI1NSwgMjEzLCA2OCwgMTA5LCAyNTUsIDIxNCwgNjksIDEwOCwgMjU1LCAyMTYsIDY5LCAxMDgsIDI1NSwgMjE3LCA3MCwgMTA3LCAyNTUsIDIxOSwgNzEsIDEwNiwgMjU1LCAyMjAsIDcyLCAxMDUsIDI1NSwgMjIyLCA3MywgMTA0LCAyNTUsIDIyMywgNzQsIDEwNCwgMjU1LCAyMjQsIDc2LCAxMDMsIDI1NSwgMjI2LCA3NywgMTAyLCAyNTUsIDIyNywgNzgsIDEwMSwgMjU1LCAyMjgsIDc5LCAxMDAsIDI1NSwgMjI5LCA4MCwgMTAwLCAyNTUsIDIzMSwgODIsIDk5LCAyNTUsIDIzMiwgODMsIDk4LCAyNTUsIDIzMywgODQsIDk4LCAyNTUsIDIzNCwgODYsIDk3LCAyNTUsIDIzNSwgODcsIDk2LCAyNTUsIDIzNiwgODgsIDk2LCAyNTUsIDIzNywgOTAsIDk1LCAyNTUsIDIzOCwgOTEsIDk0LCAyNTUsIDIzOSwgOTMsIDk0LCAyNTUsIDI0MCwgOTUsIDk0LCAyNTUsIDI0MSwgOTYsIDkzLCAyNTUsIDI0MiwgOTgsIDkzLCAyNTUsIDI0MiwgMTAwLCA5MiwgMjU1LCAyNDMsIDEwMSwgOTIsIDI1NSwgMjQ0LCAxMDMsIDkyLCAyNTUsIDI0NCwgMTA1LCA5MiwgMjU1LCAyNDUsIDEwNywgOTIsIDI1NSwgMjQ2LCAxMDgsIDkyLCAyNTUsIDI0NiwgMTEwLCA5MiwgMjU1LCAyNDcsIDExMiwgOTIsIDI1NSwgMjQ3LCAxMTQsIDkyLCAyNTUsIDI0OCwgMTE2LCA5MiwgMjU1LCAyNDgsIDExOCwgOTIsIDI1NSwgMjQ5LCAxMjAsIDkzLCAyNTUsIDI0OSwgMTIxLCA5MywgMjU1LCAyNDksIDEyMywgOTMsIDI1NSwgMjUwLCAxMjUsIDk0LCAyNTUsIDI1MCwgMTI3LCA5NCwgMjU1LCAyNTAsIDEyOSwgOTUsIDI1NSwgMjUxLCAxMzEsIDk1LCAyNTUsIDI1MSwgMTMzLCA5NiwgMjU1LCAyNTEsIDEzNSwgOTcsIDI1NSwgMjUyLCAxMzcsIDk3LCAyNTUsIDI1MiwgMTM4LCA5OCwgMjU1LCAyNTIsIDE0MCwgOTksIDI1NSwgMjUyLCAxNDIsIDEwMCwgMjU1LCAyNTIsIDE0NCwgMTAxLCAyNTUsIDI1MywgMTQ2LCAxMDIsIDI1NSwgMjUzLCAxNDgsIDEwMywgMjU1LCAyNTMsIDE1MCwgMTA0LCAyNTUsIDI1MywgMTUyLCAxMDUsIDI1NSwgMjUzLCAxNTQsIDEwNiwgMjU1LCAyNTMsIDE1NSwgMTA3LCAyNTUsIDI1NCwgMTU3LCAxMDgsIDI1NSwgMjU0LCAxNTksIDEwOSwgMjU1LCAyNTQsIDE2MSwgMTEwLCAyNTUsIDI1NCwgMTYzLCAxMTEsIDI1NSwgMjU0LCAxNjUsIDExMywgMjU1LCAyNTQsIDE2NywgMTE0LCAyNTUsIDI1NCwgMTY5LCAxMTUsIDI1NSwgMjU0LCAxNzAsIDExNiwgMjU1LCAyNTQsIDE3MiwgMTE4LCAyNTUsIDI1NCwgMTc0LCAxMTksIDI1NSwgMjU0LCAxNzYsIDEyMCwgMjU1LCAyNTQsIDE3OCwgMTIyLCAyNTUsIDI1NCwgMTgwLCAxMjMsIDI1NSwgMjU0LCAxODIsIDEyNCwgMjU1LCAyNTQsIDE4MywgMTI2LCAyNTUsIDI1NCwgMTg1LCAxMjcsIDI1NSwgMjU0LCAxODcsIDEyOSwgMjU1LCAyNTQsIDE4OSwgMTMwLCAyNTUsIDI1NCwgMTkxLCAxMzIsIDI1NSwgMjU0LCAxOTMsIDEzMywgMjU1LCAyNTQsIDE5NCwgMTM1LCAyNTUsIDI1NCwgMTk2LCAxMzYsIDI1NSwgMjU0LCAxOTgsIDEzOCwgMjU1LCAyNTQsIDIwMCwgMTQwLCAyNTUsIDI1NCwgMjAyLCAxNDEsIDI1NSwgMjU0LCAyMDQsIDE0MywgMjU1LCAyNTQsIDIwNSwgMTQ0LCAyNTUsIDI1NCwgMjA3LCAxNDYsIDI1NSwgMjU0LCAyMDksIDE0OCwgMjU1LCAyNTQsIDIxMSwgMTQ5LCAyNTUsIDI1NCwgMjEzLCAxNTEsIDI1NSwgMjU0LCAyMTUsIDE1MywgMjU1LCAyNTQsIDIxNiwgMTU0LCAyNTUsIDI1MywgMjE4LCAxNTYsIDI1NSwgMjUzLCAyMjAsIDE1OCwgMjU1LCAyNTMsIDIyMiwgMTYwLCAyNTUsIDI1MywgMjI0LCAxNjEsIDI1NSwgMjUzLCAyMjYsIDE2MywgMjU1LCAyNTMsIDIyNywgMTY1LCAyNTUsIDI1MywgMjI5LCAxNjcsIDI1NSwgMjUzLCAyMzEsIDE2OSwgMjU1LCAyNTMsIDIzMywgMTcwLCAyNTUsIDI1MywgMjM1LCAxNzIsIDI1NSwgMjUyLCAyMzYsIDE3NCwgMjU1LCAyNTIsIDIzOCwgMTc2LCAyNTUsIDI1MiwgMjQwLCAxNzgsIDI1NSwgMjUyLCAyNDIsIDE4MCwgMjU1LCAyNTIsIDI0NCwgMTgyLCAyNTUsIDI1MiwgMjQ2LCAxODQsIDI1NSwgMjUyLCAyNDcsIDE4NSwgMjU1LCAyNTIsIDI0OSwgMTg3LCAyNTUsIDI1MiwgMjUxLCAxODksIDI1NSwgMjUyLCAyNTMsIDE5MSwgMjU1XSksXG4gIHBsYXNtYTogbmV3IFVpbnQ4QXJyYXkoWzEzLCA4LCAxMzUsIDI1NSwgMTYsIDcsIDEzNiwgMjU1LCAxOSwgNywgMTM3LCAyNTUsIDIyLCA3LCAxMzgsIDI1NSwgMjUsIDYsIDE0MCwgMjU1LCAyNywgNiwgMTQxLCAyNTUsIDI5LCA2LCAxNDIsIDI1NSwgMzIsIDYsIDE0MywgMjU1LCAzNCwgNiwgMTQ0LCAyNTUsIDM2LCA2LCAxNDUsIDI1NSwgMzgsIDUsIDE0NSwgMjU1LCA0MCwgNSwgMTQ2LCAyNTUsIDQyLCA1LCAxNDcsIDI1NSwgNDQsIDUsIDE0OCwgMjU1LCA0NiwgNSwgMTQ5LCAyNTUsIDQ3LCA1LCAxNTAsIDI1NSwgNDksIDUsIDE1MSwgMjU1LCA1MSwgNSwgMTUxLCAyNTUsIDUzLCA0LCAxNTIsIDI1NSwgNTUsIDQsIDE1MywgMjU1LCA1NiwgNCwgMTU0LCAyNTUsIDU4LCA0LCAxNTQsIDI1NSwgNjAsIDQsIDE1NSwgMjU1LCA2MiwgNCwgMTU2LCAyNTUsIDYzLCA0LCAxNTYsIDI1NSwgNjUsIDQsIDE1NywgMjU1LCA2NywgMywgMTU4LCAyNTUsIDY4LCAzLCAxNTgsIDI1NSwgNzAsIDMsIDE1OSwgMjU1LCA3MiwgMywgMTU5LCAyNTUsIDczLCAzLCAxNjAsIDI1NSwgNzUsIDMsIDE2MSwgMjU1LCA3NiwgMiwgMTYxLCAyNTUsIDc4LCAyLCAxNjIsIDI1NSwgODAsIDIsIDE2MiwgMjU1LCA4MSwgMiwgMTYzLCAyNTUsIDgzLCAyLCAxNjMsIDI1NSwgODUsIDIsIDE2NCwgMjU1LCA4NiwgMSwgMTY0LCAyNTUsIDg4LCAxLCAxNjQsIDI1NSwgODksIDEsIDE2NSwgMjU1LCA5MSwgMSwgMTY1LCAyNTUsIDkyLCAxLCAxNjYsIDI1NSwgOTQsIDEsIDE2NiwgMjU1LCA5NiwgMSwgMTY2LCAyNTUsIDk3LCAwLCAxNjcsIDI1NSwgOTksIDAsIDE2NywgMjU1LCAxMDAsIDAsIDE2NywgMjU1LCAxMDIsIDAsIDE2NywgMjU1LCAxMDMsIDAsIDE2OCwgMjU1LCAxMDUsIDAsIDE2OCwgMjU1LCAxMDYsIDAsIDE2OCwgMjU1LCAxMDgsIDAsIDE2OCwgMjU1LCAxMTAsIDAsIDE2OCwgMjU1LCAxMTEsIDAsIDE2OCwgMjU1LCAxMTMsIDAsIDE2OCwgMjU1LCAxMTQsIDEsIDE2OCwgMjU1LCAxMTYsIDEsIDE2OCwgMjU1LCAxMTcsIDEsIDE2OCwgMjU1LCAxMTksIDEsIDE2OCwgMjU1LCAxMjAsIDEsIDE2OCwgMjU1LCAxMjIsIDIsIDE2OCwgMjU1LCAxMjMsIDIsIDE2OCwgMjU1LCAxMjUsIDMsIDE2OCwgMjU1LCAxMjYsIDMsIDE2OCwgMjU1LCAxMjgsIDQsIDE2OCwgMjU1LCAxMjksIDQsIDE2NywgMjU1LCAxMzEsIDUsIDE2NywgMjU1LCAxMzIsIDUsIDE2NywgMjU1LCAxMzQsIDYsIDE2NiwgMjU1LCAxMzUsIDcsIDE2NiwgMjU1LCAxMzYsIDgsIDE2NiwgMjU1LCAxMzgsIDksIDE2NSwgMjU1LCAxMzksIDEwLCAxNjUsIDI1NSwgMTQxLCAxMSwgMTY1LCAyNTUsIDE0MiwgMTIsIDE2NCwgMjU1LCAxNDMsIDEzLCAxNjQsIDI1NSwgMTQ1LCAxNCwgMTYzLCAyNTUsIDE0NiwgMTUsIDE2MywgMjU1LCAxNDgsIDE2LCAxNjIsIDI1NSwgMTQ5LCAxNywgMTYxLCAyNTUsIDE1MCwgMTksIDE2MSwgMjU1LCAxNTIsIDIwLCAxNjAsIDI1NSwgMTUzLCAyMSwgMTU5LCAyNTUsIDE1NCwgMjIsIDE1OSwgMjU1LCAxNTYsIDIzLCAxNTgsIDI1NSwgMTU3LCAyNCwgMTU3LCAyNTUsIDE1OCwgMjUsIDE1NywgMjU1LCAxNjAsIDI2LCAxNTYsIDI1NSwgMTYxLCAyNywgMTU1LCAyNTUsIDE2MiwgMjksIDE1NCwgMjU1LCAxNjMsIDMwLCAxNTQsIDI1NSwgMTY1LCAzMSwgMTUzLCAyNTUsIDE2NiwgMzIsIDE1MiwgMjU1LCAxNjcsIDMzLCAxNTEsIDI1NSwgMTY4LCAzNCwgMTUwLCAyNTUsIDE3MCwgMzUsIDE0OSwgMjU1LCAxNzEsIDM2LCAxNDgsIDI1NSwgMTcyLCAzOCwgMTQ4LCAyNTUsIDE3MywgMzksIDE0NywgMjU1LCAxNzQsIDQwLCAxNDYsIDI1NSwgMTc2LCA0MSwgMTQ1LCAyNTUsIDE3NywgNDIsIDE0NCwgMjU1LCAxNzgsIDQzLCAxNDMsIDI1NSwgMTc5LCA0NCwgMTQyLCAyNTUsIDE4MCwgNDYsIDE0MSwgMjU1LCAxODEsIDQ3LCAxNDAsIDI1NSwgMTgyLCA0OCwgMTM5LCAyNTUsIDE4MywgNDksIDEzOCwgMjU1LCAxODQsIDUwLCAxMzcsIDI1NSwgMTg2LCA1MSwgMTM2LCAyNTUsIDE4NywgNTIsIDEzNiwgMjU1LCAxODgsIDUzLCAxMzUsIDI1NSwgMTg5LCA1NSwgMTM0LCAyNTUsIDE5MCwgNTYsIDEzMywgMjU1LCAxOTEsIDU3LCAxMzIsIDI1NSwgMTkyLCA1OCwgMTMxLCAyNTUsIDE5MywgNTksIDEzMCwgMjU1LCAxOTQsIDYwLCAxMjksIDI1NSwgMTk1LCA2MSwgMTI4LCAyNTUsIDE5NiwgNjIsIDEyNywgMjU1LCAxOTcsIDY0LCAxMjYsIDI1NSwgMTk4LCA2NSwgMTI1LCAyNTUsIDE5OSwgNjYsIDEyNCwgMjU1LCAyMDAsIDY3LCAxMjMsIDI1NSwgMjAxLCA2OCwgMTIyLCAyNTUsIDIwMiwgNjksIDEyMiwgMjU1LCAyMDMsIDcwLCAxMjEsIDI1NSwgMjA0LCA3MSwgMTIwLCAyNTUsIDIwNCwgNzMsIDExOSwgMjU1LCAyMDUsIDc0LCAxMTgsIDI1NSwgMjA2LCA3NSwgMTE3LCAyNTUsIDIwNywgNzYsIDExNiwgMjU1LCAyMDgsIDc3LCAxMTUsIDI1NSwgMjA5LCA3OCwgMTE0LCAyNTUsIDIxMCwgNzksIDExMywgMjU1LCAyMTEsIDgxLCAxMTMsIDI1NSwgMjEyLCA4MiwgMTEyLCAyNTUsIDIxMywgODMsIDExMSwgMjU1LCAyMTMsIDg0LCAxMTAsIDI1NSwgMjE0LCA4NSwgMTA5LCAyNTUsIDIxNSwgODYsIDEwOCwgMjU1LCAyMTYsIDg3LCAxMDcsIDI1NSwgMjE3LCA4OCwgMTA2LCAyNTUsIDIxOCwgOTAsIDEwNiwgMjU1LCAyMTgsIDkxLCAxMDUsIDI1NSwgMjE5LCA5MiwgMTA0LCAyNTUsIDIyMCwgOTMsIDEwMywgMjU1LCAyMjEsIDk0LCAxMDIsIDI1NSwgMjIyLCA5NSwgMTAxLCAyNTUsIDIyMiwgOTcsIDEwMCwgMjU1LCAyMjMsIDk4LCA5OSwgMjU1LCAyMjQsIDk5LCA5OSwgMjU1LCAyMjUsIDEwMCwgOTgsIDI1NSwgMjI2LCAxMDEsIDk3LCAyNTUsIDIyNiwgMTAyLCA5NiwgMjU1LCAyMjcsIDEwNCwgOTUsIDI1NSwgMjI4LCAxMDUsIDk0LCAyNTUsIDIyOSwgMTA2LCA5MywgMjU1LCAyMjksIDEwNywgOTMsIDI1NSwgMjMwLCAxMDgsIDkyLCAyNTUsIDIzMSwgMTEwLCA5MSwgMjU1LCAyMzEsIDExMSwgOTAsIDI1NSwgMjMyLCAxMTIsIDg5LCAyNTUsIDIzMywgMTEzLCA4OCwgMjU1LCAyMzMsIDExNCwgODcsIDI1NSwgMjM0LCAxMTYsIDg3LCAyNTUsIDIzNSwgMTE3LCA4NiwgMjU1LCAyMzUsIDExOCwgODUsIDI1NSwgMjM2LCAxMTksIDg0LCAyNTUsIDIzNywgMTIxLCA4MywgMjU1LCAyMzcsIDEyMiwgODIsIDI1NSwgMjM4LCAxMjMsIDgxLCAyNTUsIDIzOSwgMTI0LCA4MSwgMjU1LCAyMzksIDEyNiwgODAsIDI1NSwgMjQwLCAxMjcsIDc5LCAyNTUsIDI0MCwgMTI4LCA3OCwgMjU1LCAyNDEsIDEyOSwgNzcsIDI1NSwgMjQxLCAxMzEsIDc2LCAyNTUsIDI0MiwgMTMyLCA3NSwgMjU1LCAyNDMsIDEzMywgNzUsIDI1NSwgMjQzLCAxMzUsIDc0LCAyNTUsIDI0NCwgMTM2LCA3MywgMjU1LCAyNDQsIDEzNywgNzIsIDI1NSwgMjQ1LCAxMzksIDcxLCAyNTUsIDI0NSwgMTQwLCA3MCwgMjU1LCAyNDYsIDE0MSwgNjksIDI1NSwgMjQ2LCAxNDMsIDY4LCAyNTUsIDI0NywgMTQ0LCA2OCwgMjU1LCAyNDcsIDE0NSwgNjcsIDI1NSwgMjQ3LCAxNDcsIDY2LCAyNTUsIDI0OCwgMTQ4LCA2NSwgMjU1LCAyNDgsIDE0OSwgNjQsIDI1NSwgMjQ5LCAxNTEsIDYzLCAyNTUsIDI0OSwgMTUyLCA2MiwgMjU1LCAyNDksIDE1NCwgNjIsIDI1NSwgMjUwLCAxNTUsIDYxLCAyNTUsIDI1MCwgMTU2LCA2MCwgMjU1LCAyNTAsIDE1OCwgNTksIDI1NSwgMjUxLCAxNTksIDU4LCAyNTUsIDI1MSwgMTYxLCA1NywgMjU1LCAyNTEsIDE2MiwgNTYsIDI1NSwgMjUyLCAxNjMsIDU2LCAyNTUsIDI1MiwgMTY1LCA1NSwgMjU1LCAyNTIsIDE2NiwgNTQsIDI1NSwgMjUyLCAxNjgsIDUzLCAyNTUsIDI1MiwgMTY5LCA1MiwgMjU1LCAyNTMsIDE3MSwgNTEsIDI1NSwgMjUzLCAxNzIsIDUxLCAyNTUsIDI1MywgMTc0LCA1MCwgMjU1LCAyNTMsIDE3NSwgNDksIDI1NSwgMjUzLCAxNzcsIDQ4LCAyNTUsIDI1MywgMTc4LCA0NywgMjU1LCAyNTMsIDE4MCwgNDcsIDI1NSwgMjUzLCAxODEsIDQ2LCAyNTUsIDI1NCwgMTgzLCA0NSwgMjU1LCAyNTQsIDE4NCwgNDQsIDI1NSwgMjU0LCAxODYsIDQ0LCAyNTUsIDI1NCwgMTg3LCA0MywgMjU1LCAyNTQsIDE4OSwgNDIsIDI1NSwgMjU0LCAxOTAsIDQyLCAyNTUsIDI1NCwgMTkyLCA0MSwgMjU1LCAyNTMsIDE5NCwgNDEsIDI1NSwgMjUzLCAxOTUsIDQwLCAyNTUsIDI1MywgMTk3LCAzOSwgMjU1LCAyNTMsIDE5OCwgMzksIDI1NSwgMjUzLCAyMDAsIDM5LCAyNTUsIDI1MywgMjAyLCAzOCwgMjU1LCAyNTMsIDIwMywgMzgsIDI1NSwgMjUyLCAyMDUsIDM3LCAyNTUsIDI1MiwgMjA2LCAzNywgMjU1LCAyNTIsIDIwOCwgMzcsIDI1NSwgMjUyLCAyMTAsIDM3LCAyNTUsIDI1MSwgMjExLCAzNiwgMjU1LCAyNTEsIDIxMywgMzYsIDI1NSwgMjUxLCAyMTUsIDM2LCAyNTUsIDI1MCwgMjE2LCAzNiwgMjU1LCAyNTAsIDIxOCwgMzYsIDI1NSwgMjQ5LCAyMjAsIDM2LCAyNTUsIDI0OSwgMjIxLCAzNywgMjU1LCAyNDgsIDIyMywgMzcsIDI1NSwgMjQ4LCAyMjUsIDM3LCAyNTUsIDI0NywgMjI2LCAzNywgMjU1LCAyNDcsIDIyOCwgMzcsIDI1NSwgMjQ2LCAyMzAsIDM4LCAyNTUsIDI0NiwgMjMyLCAzOCwgMjU1LCAyNDUsIDIzMywgMzgsIDI1NSwgMjQ1LCAyMzUsIDM5LCAyNTUsIDI0NCwgMjM3LCAzOSwgMjU1LCAyNDMsIDIzOCwgMzksIDI1NSwgMjQzLCAyNDAsIDM5LCAyNTUsIDI0MiwgMjQyLCAzOSwgMjU1LCAyNDEsIDI0NCwgMzgsIDI1NSwgMjQxLCAyNDUsIDM3LCAyNTUsIDI0MCwgMjQ3LCAzNiwgMjU1LCAyNDAsIDI0OSwgMzMsIDI1NV0pLFxuICByZWRibHVlOiB7XG4gICAgY29sb3JzOiBbXCIjZmYwMDAwXCIsIFwiIzAwMDBmZlwiXSxcbiAgICBwb3NpdGlvbnM6IFswLCAxXVxuICB9LFxuICBjb29sd2FybToge1xuICAgIGNvbG9yczogW1wiIzAwMDBmZlwiLCBcIiNmZmZmZmZcIiwgXCIjZmYwMDAwXCJdLFxuICAgIHBvc2l0aW9uczogWzAsIDAuNSwgMV1cbiAgfSxcbiAgZGl2ZXJnaW5nXzE6IHtcbiAgICBjb2xvcnM6IFtcIiM0MDAwNDBcIiwgXCIjM2IwMDRkXCIsIFwiIzM2MDA1YlwiLCBcIiMzMjAwNjhcIiwgXCIjMmQwMDc2XCIsIFwiIzI5MDA4NFwiLCBcIiMyNDAwOTFcIiwgXCIjMjAwMDlmXCIsIFwiIzFiMDBhZFwiLCBcIiMxNjAwYmFcIiwgXCIjMTIwMGM4XCIsIFwiIzBkMDBkNlwiLCBcIiMwOTAwZTNcIiwgXCIjMDQwMGYxXCIsIFwiIzAwMDBmZlwiLCBcIiMwMjE3ZmZcIiwgXCIjMDQyZWZmXCIsIFwiIzA2NDVmZlwiLCBcIiMwOTVjZmZcIiwgXCIjMGI3M2ZmXCIsIFwiIzBkOGJmZlwiLCBcIiMxMGEyZmZcIiwgXCIjMTJiOWZmXCIsIFwiIzE0ZDBmZlwiLCBcIiMxN2U3ZmZcIiwgXCIjMTlmZmZmXCIsIFwiIzNmZmZmZlwiLCBcIiM2NmZmZmZcIiwgXCIjOGNmZmZmXCIsIFwiI2IyZmZmZlwiLCBcIiNkOGZmZmZcIiwgXCIjZmZmZmZmXCIsIFwiI2ZmZmZkNFwiLCBcIiNmZmZmYWFcIiwgXCIjZmZmZjdmXCIsIFwiI2ZmZmY1NFwiLCBcIiNmZmZmMmFcIiwgXCIjZmZmZjAwXCIsIFwiI2ZmZWQwMFwiLCBcIiNmZmRkMDBcIiwgXCIjZmZjYzAwXCIsIFwiI2ZmYmEwMFwiLCBcIiNmZmFhMDBcIiwgXCIjZmY5OTAwXCIsIFwiI2ZmODcwMFwiLCBcIiNmZjc3MDBcIiwgXCIjZmY2NjAwXCIsIFwiI2ZmNTQwMFwiLCBcIiNmZjQ0MDBcIiwgXCIjZmYzMzAwXCIsIFwiI2ZmMjEwMFwiLCBcIiNmZjExMDBcIiwgXCIjZmYwMDAwXCIsIFwiI2ZmMDAxN1wiLCBcIiNmZjAwMmVcIiwgXCIjZmYwMDQ1XCIsIFwiI2ZmMDA1Y1wiLCBcIiNmZjAwNzNcIiwgXCIjZmYwMDhiXCIsIFwiI2ZmMDBhMlwiLCBcIiNmZjAwYjlcIiwgXCIjZmYwMGQwXCIsIFwiI2ZmMDBlN1wiLCBcIiNmZjAwZmZcIl0sXG4gICAgcG9zaXRpb25zOiBbMCwgMC4wMTU4NzMwMTU4NywgMC4wMzE3NDYwMzE3NCwgMC4wNDc2MTkwNDc2MSwgMC4wNjM0OTIwNjM0OCwgMC4wNzkzNjUwNzkzNSwgMC4wOTUyMzgwOTUyMiwgMC4xMTExMTExMTEwOSwgMC4xMjY5ODQxMjY5NiwgMC4xNDI4NTcxNDI4MywgMC4xNTg3MzAxNTg3LCAwLjE3NDYwMzE3NDU3LCAwLjE5MDQ3NjE5MDQ0LCAwLjIwNjM0OTIwNjMxLCAwLjIyMjIyMjIyMjE4LCAwLjIzODA5NTIzODA1LCAwLjI1Mzk2ODI1MzkyLCAwLjI2OTg0MTI2OTc5LCAwLjI4NTcxNDI4NTY2LCAwLjMwMTU4NzMwMTUzLCAwLjMxNzQ2MDMxNzQsIDAuMzMzMzMzMzMzMjcsIDAuMzQ5MjA2MzQ5MTQsIDAuMzY1MDc5MzY1MDEsIDAuMzgwOTUyMzgwODgsIDAuMzk2ODI1Mzk2NzUsIDAuNDEyNjk4NDEyNjIsIDAuNDI4NTcxNDI4NDksIDAuNDQ0NDQ0NDQ0MzYsIDAuNDYwMzE3NDYwMjMsIDAuNDc2MTkwNDc2MSwgMC40OTIwNjM0OTE5NywgMC41MDc5MzY1MDc4NCwgMC41MjM4MDk1MjM3MSwgMC41Mzk2ODI1Mzk1OCwgMC41NTU1NTU1NTU0NSwgMC41NzE0Mjg1NzEzMiwgMC41ODczMDE1ODcxOSwgMC42MDMxNzQ2MDMwNiwgMC42MTkwNDc2MTg5MywgMC42MzQ5MjA2MzQ4LCAwLjY1MDc5MzY1MDY3LCAwLjY2NjY2NjY2NjU0LCAwLjY4MjUzOTY4MjQxLCAwLjY5ODQxMjY5ODI4LCAwLjcxNDI4NTcxNDE1LCAwLjczMDE1ODczMDAyLCAwLjc0NjAzMTc0NTg5LCAwLjc2MTkwNDc2MTc2LCAwLjc3Nzc3Nzc3NzYzLCAwLjc5MzY1MDc5MzUsIDAuODA5NTIzODA5MzcsIDAuODI1Mzk2ODI1MjQsIDAuODQxMjY5ODQxMTEsIDAuODU3MTQyODU2OTgsIDAuODczMDE1ODcyODUsIDAuODg4ODg4ODg4NzIsIDAuOTA0NzYxOTA0NTksIDAuOTIwNjM0OTIwNDYsIDAuOTM2NTA3OTM2MzMsIDAuOTUyMzgwOTUyMiwgMC45NjgyNTM5NjgwNywgMC45ODQxMjY5ODM5NCwgMV1cbiAgfSxcbiAgZGl2ZXJnaW5nXzI6IHtcbiAgICBjb2xvcnM6IFtcIiMwMDAwMDBcIiwgXCIjMDMwYWZmXCIsIFwiIzIwNGFmZlwiLCBcIiMzYzhhZmZcIiwgXCIjNzdjNGZmXCIsIFwiI2YwZmZmZlwiLCBcIiNmMGZmZmZcIiwgXCIjZjJmZjdmXCIsIFwiI2ZmZmYwMFwiLCBcIiNmZjgzMWVcIiwgXCIjZmYwODNkXCIsIFwiI2ZmMDBmZlwiXSxcbiAgICBwb3NpdGlvbnM6IFswLCAxZS0xMCwgMC4xLCAwLjIsIDAuMzMzMywgMC40NjY2LCAwLjUzMzMsIDAuNjY2NiwgMC44LCAwLjksIDAuOTk5OTk5OTk5OTk5LCAxXVxuICB9LFxuICBibGFja3doaXRlOiB7XG4gICAgY29sb3JzOiBbXCIjMDAwMDAwXCIsIFwiI2ZmZmZmZlwiXSxcbiAgICBwb3NpdGlvbnM6IFswLCAxXVxuICB9LFxuICB0d2lsaWdodDoge1xuICAgIGNvbG9yczogW1wiI0UyRDlFMlwiLCBcIiNFMEQ5RTJcIiwgXCIjREREOUUwXCIsIFwiI0RBRDhERlwiLCBcIiNENkQ3RERcIiwgXCIjRDJENURCXCIsIFwiI0NERDNEOFwiLCBcIiNDOEQwRDZcIiwgXCIjQzJDRUQ0XCIsIFwiI0JDQ0JEMVwiLCBcIiNCNkM4Q0ZcIiwgXCIjQjBDNUNEXCIsIFwiI0FBQzJDQ1wiLCBcIiNBNEJFQ0FcIiwgXCIjOUVCQkM5XCIsIFwiIzk5QjhDOFwiLCBcIiM5M0I0QzZcIiwgXCIjOEVCMUM1XCIsIFwiIzg5QURDNVwiLCBcIiM4NUE5QzRcIiwgXCIjODBBNUMzXCIsIFwiIzdDQTJDMlwiLCBcIiM3ODlFQzJcIiwgXCIjNzU5QUMxXCIsIFwiIzcxOTZDMVwiLCBcIiM2RTkyQzBcIiwgXCIjNkM4RUJGXCIsIFwiIzY5OEFCRlwiLCBcIiM2Nzg2QkVcIiwgXCIjNjY4MkJEXCIsIFwiIzY0N0RCQ1wiLCBcIiM2Mzc5QkJcIiwgXCIjNjI3NUJBXCIsIFwiIzYxNzBCOVwiLCBcIiM2MDZDQjhcIiwgXCIjNjA2N0I2XCIsIFwiIzVGNjJCNFwiLCBcIiM1RjVFQjNcIiwgXCIjNUY1OUIxXCIsIFwiIzVFNTRBRVwiLCBcIiM1RTRGQUNcIiwgXCIjNUU0QkE5XCIsIFwiIzVFNDZBNlwiLCBcIiM1RDQxQTNcIiwgXCIjNUQzQ0EwXCIsIFwiIzVDMzc5Q1wiLCBcIiM1QjMyOThcIiwgXCIjNUEyRTkzXCIsIFwiIzU5Mjk4RVwiLCBcIiM1NzI1ODhcIiwgXCIjNTYyMTgyXCIsIFwiIzUzMUU3Q1wiLCBcIiM1MTFBNzVcIiwgXCIjNEUxODZGXCIsIFwiIzRCMTY2OFwiLCBcIiM0NzE0NjFcIiwgXCIjNDQxMzVBXCIsIFwiIzQxMTI1NFwiLCBcIiMzRDExNEVcIiwgXCIjM0ExMTQ5XCIsIFwiIzM3MTE0NFwiLCBcIiMzNTExNDBcIiwgXCIjMzMxMTNDXCIsIFwiIzMxMTMzOVwiLCBcIiMzMDE0MzdcIiwgXCIjMzMxMjM3XCIsIFwiIzM1MTEzOFwiLCBcIiMzODExMzlcIiwgXCIjM0IxMTNCXCIsIFwiIzNGMTIzRFwiLCBcIiM0MzEyM0VcIiwgXCIjNDgxMzQxXCIsIFwiIzREMTQ0M1wiLCBcIiM1MjE1NDVcIiwgXCIjNTcxNjQ3XCIsIFwiIzVDMTc0OVwiLCBcIiM2MTE4NEJcIiwgXCIjNjcxOTRDXCIsIFwiIzZDMUI0RVwiLCBcIiM3MTFENEZcIiwgXCIjNzYxRjRGXCIsIFwiIzdCMjE1MFwiLCBcIiM4MDIzNTBcIiwgXCIjODUyNjUwXCIsIFwiIzhBMjk1MFwiLCBcIiM4RTJDNTBcIiwgXCIjOTIyRjUwXCIsIFwiIzk2MzM1MFwiLCBcIiM5QTM3NTBcIiwgXCIjOUUzQjUwXCIsIFwiI0ExM0Y1MFwiLCBcIiNBNTQzNTBcIiwgXCIjQTg0NzUwXCIsIFwiI0FCNEI1MFwiLCBcIiNBRTUwNTFcIiwgXCIjQjE1NDUyXCIsIFwiI0IzNTk1M1wiLCBcIiNCNjVENTRcIiwgXCIjQjg2MjU1XCIsIFwiI0JBNjY1N1wiLCBcIiNCQzZCNTlcIiwgXCIjQkU3MDVCXCIsIFwiI0MwNzU1RVwiLCBcIiNDMjdBNjFcIiwgXCIjQzM3RjY0XCIsIFwiI0M1ODQ2OFwiLCBcIiNDNjg5NkNcIiwgXCIjQzc4RTcxXCIsIFwiI0M4OTI3NVwiLCBcIiNDOTk3N0JcIiwgXCIjQ0E5QzgwXCIsIFwiI0NDQTE4NlwiLCBcIiNDREE2OENcIiwgXCIjQ0VBQjkyXCIsIFwiI0NGQUY5OVwiLCBcIiNEMUI0QTBcIiwgXCIjRDJCOEE3XCIsIFwiI0Q0QkRBRFwiLCBcIiNENkMxQjRcIiwgXCIjRDhDNUJCXCIsIFwiI0Q5QzlDMlwiLCBcIiNEQkNDQzhcIiwgXCIjREREMENFXCIsIFwiI0RFRDNEM1wiLCBcIiNERkQ1RDhcIiwgXCIjRTBEN0RCXCIsIFwiI0UxRDhERlwiLCBcIiNFMkQ5RTFcIl0sXG4gICAgcG9zaXRpb25zOiBbMCwgMC4wMDc4NzQwMTU3LCAwLjAxNTc0ODAzMTUsIDAuMDIzNjIyMDQ3MiwgMC4wMzE0OTYwNjMsIDAuMDM5MzcwMDc4NywgMC4wNDcyNDQwOTQ1LCAwLjA1NTExODExMDIsIDAuMDYyOTkyMTI2LCAwLjA3MDg2NjE0MTcsIDAuMDc4NzQwMTU3NSwgMC4wODY2MTQxNzMyLCAwLjA5NDQ4ODE4OSwgMC4xMDIzNjIyMDQ3LCAwLjExMDIzNjIyMDUsIDAuMTE4MTEwMjM2MiwgMC4xMjU5ODQyNTIsIDAuMTMzODU4MjY3NywgMC4xNDE3MzIyODM1LCAwLjE0OTYwNjI5OTIsIDAuMTU3NDgwMzE1LCAwLjE2NTM1NDMzMDcsIDAuMTczMjI4MzQ2NSwgMC4xODExMDIzNjIyLCAwLjE4ODk3NjM3OCwgMC4xOTY4NTAzOTM3LCAwLjIwNDcyNDQwOTQsIDAuMjEyNTk4NDI1MiwgMC4yMjA0NzI0NDA5LCAwLjIyODM0NjQ1NjcsIDAuMjM2MjIwNDcyNCwgMC4yNDQwOTQ0ODgyLCAwLjI1MTk2ODUwMzksIDAuMjU5ODQyNTE5NywgMC4yNjc3MTY1MzU0LCAwLjI3NTU5MDU1MTIsIDAuMjgzNDY0NTY2OSwgMC4yOTEzMzg1ODI3LCAwLjI5OTIxMjU5ODQsIDAuMzA3MDg2NjE0MiwgMC4zMTQ5NjA2Mjk5LCAwLjMyMjgzNDY0NTcsIDAuMzMwNzA4NjYxNCwgMC4zMzg1ODI2NzcyLCAwLjM0NjQ1NjY5MjksIDAuMzU0MzMwNzA4NywgMC4zNjIyMDQ3MjQ0LCAwLjM3MDA3ODc0MDIsIDAuMzc3OTUyNzU1OSwgMC4zODU4MjY3NzE3LCAwLjM5MzcwMDc4NzQsIDAuNDAxNTc0ODAzMSwgMC40MDk0NDg4MTg5LCAwLjQxNzMyMjgzNDYsIDAuNDI1MTk2ODUwNCwgMC40MzMwNzA4NjYxLCAwLjQ0MDk0NDg4MTksIDAuNDQ4ODE4ODk3NiwgMC40NTY2OTI5MTM0LCAwLjQ2NDU2NjkyOTEsIDAuNDcyNDQwOTQ0OSwgMC40ODAzMTQ5NjA2LCAwLjQ4ODE4ODk3NjQsIDAuNDk2MDYyOTkyMSwgMC41MDM5MzcwMDc5LCAwLjUxMTgxMTAyMzYsIDAuNTE5Njg1MDM5NCwgMC41Mjc1NTkwNTUxLCAwLjUzNTQzMzA3MDksIDAuNTQzMzA3MDg2NiwgMC41NTExODExMDI0LCAwLjU1OTA1NTExODEsIDAuNTY2OTI5MTMzOSwgMC41NzQ4MDMxNDk2LCAwLjU4MjY3NzE2NTQsIDAuNTkwNTUxMTgxMSwgMC41OTg0MjUxOTY5LCAwLjYwNjI5OTIxMjYsIDAuNjE0MTczMjI4MywgMC42MjIwNDcyNDQxLCAwLjYyOTkyMTI1OTgsIDAuNjM3Nzk1Mjc1NiwgMC42NDU2NjkyOTEzLCAwLjY1MzU0MzMwNzEsIDAuNjYxNDE3MzIyOCwgMC42NjkyOTEzMzg2LCAwLjY3NzE2NTM1NDMsIDAuNjg1MDM5MzcwMSwgMC42OTI5MTMzODU4LCAwLjcwMDc4NzQwMTYsIDAuNzA4NjYxNDE3MywgMC43MTY1MzU0MzMxLCAwLjcyNDQwOTQ0ODgsIDAuNzMyMjgzNDY0NiwgMC43NDAxNTc0ODAzLCAwLjc0ODAzMTQ5NjEsIDAuNzU1OTA1NTExOCwgMC43NjM3Nzk1Mjc2LCAwLjc3MTY1MzU0MzMsIDAuNzc5NTI3NTU5MSwgMC43ODc0MDE1NzQ4LCAwLjc5NTI3NTU5MDYsIDAuODAzMTQ5NjA2MywgMC44MTEwMjM2MjIsIDAuODE4ODk3NjM3OCwgMC44MjY3NzE2NTM1LCAwLjgzNDY0NTY2OTMsIDAuODQyNTE5Njg1LCAwLjg1MDM5MzcwMDgsIDAuODU4MjY3NzE2NSwgMC44NjYxNDE3MzIzLCAwLjg3NDAxNTc0OCwgMC44ODE4ODk3NjM4LCAwLjg4OTc2Mzc3OTUsIDAuODk3NjM3Nzk1MywgMC45MDU1MTE4MTEsIDAuOTEzMzg1ODI2OCwgMC45MjEyNTk4NDI1LCAwLjkyOTEzMzg1ODMsIDAuOTM3MDA3ODc0LCAwLjk0NDg4MTg4OTgsIDAuOTUyNzU1OTA1NSwgMC45NjA2Mjk5MjEzLCAwLjk2ODUwMzkzNywgMC45NzYzNzc5NTI4LCAwLjk4NDI1MTk2ODUsIDAuOTkyMTI1OTg0MywgMV1cbiAgfSxcbiAgdHdpbGlnaHRfc2hpZnRlZDoge1xuICAgIGNvbG9yczogW1wiIzMwMTQzN1wiLCBcIiMzMjEyM0FcIiwgXCIjMzQxMTNFXCIsIFwiIzM2MTE0MlwiLCBcIiMzOTExNDZcIiwgXCIjM0MxMTRCXCIsIFwiIzNGMTI1MVwiLCBcIiM0MjEyNTdcIiwgXCIjNDYxNDVFXCIsIFwiIzQ5MTU2NFwiLCBcIiM0QzE3NkJcIiwgXCIjNEYxOTcyXCIsIFwiIzUyMUM3OVwiLCBcIiM1NTFGN0ZcIiwgXCIjNTcyMzg1XCIsIFwiIzU4Mjc4QlwiLCBcIiM1QTJCOTBcIiwgXCIjNUIzMDk1XCIsIFwiIzVDMzU5QVwiLCBcIiM1RDNBOUVcIiwgXCIjNUQzRUExXCIsIFwiIzVFNDNBNVwiLCBcIiM1RTQ4QThcIiwgXCIjNUU0REFCXCIsIFwiIzVFNTJBRFwiLCBcIiM1RjU3QjBcIiwgXCIjNUY1QkIyXCIsIFwiIzVGNjBCNFwiLCBcIiM1RjY1QjVcIiwgXCIjNjA2OUI3XCIsIFwiIzYwNkVCOFwiLCBcIiM2MTcyQkFcIiwgXCIjNjI3N0JCXCIsIFwiIzYzN0JCQ1wiLCBcIiM2NTdGQkRcIiwgXCIjNjY4NEJEXCIsIFwiIzY4ODhCRVwiLCBcIiM2QjhDQkZcIiwgXCIjNkQ5MEMwXCIsIFwiIzcwOTRDMFwiLCBcIiM3Mzk4QzFcIiwgXCIjNzY5Q0MxXCIsIFwiIzdBQTBDMlwiLCBcIiM3RUE0QzNcIiwgXCIjODJBN0MzXCIsIFwiIzg3QUJDNFwiLCBcIiM4Q0FGQzVcIiwgXCIjOTFCMkM2XCIsIFwiIzk2QjZDN1wiLCBcIiM5Q0I5QzhcIiwgXCIjQTFCREM5XCIsIFwiI0E3QzBDQlwiLCBcIiNBREMzQ0RcIiwgXCIjQjNDNkNFXCIsIFwiI0I5QzlEMFwiLCBcIiNCRkNDRDNcIiwgXCIjQzVDRkQ1XCIsIFwiI0NCRDJEN1wiLCBcIiNEMEQ0RDlcIiwgXCIjRDRENkRDXCIsIFwiI0Q4RDhERVwiLCBcIiNEQ0Q5REZcIiwgXCIjREVEOUUxXCIsIFwiI0UxRDlFMlwiLCBcIiNFMkQ5RTFcIiwgXCIjRTFEOERGXCIsIFwiI0UwRDdEQlwiLCBcIiNERkQ1RDhcIiwgXCIjREVEM0QzXCIsIFwiI0RERDBDRVwiLCBcIiNEQkNDQzhcIiwgXCIjRDlDOUMyXCIsIFwiI0Q4QzVCQlwiLCBcIiNENkMxQjRcIiwgXCIjRDRCREFEXCIsIFwiI0QyQjhBN1wiLCBcIiNEMUI0QTBcIiwgXCIjQ0ZBRjk5XCIsIFwiI0NFQUI5MlwiLCBcIiNDREE2OENcIiwgXCIjQ0NBMTg2XCIsIFwiI0NBOUM4MFwiLCBcIiNDOTk3N0JcIiwgXCIjQzg5Mjc1XCIsIFwiI0M3OEU3MVwiLCBcIiNDNjg5NkNcIiwgXCIjQzU4NDY4XCIsIFwiI0MzN0Y2NFwiLCBcIiNDMjdBNjFcIiwgXCIjQzA3NTVFXCIsIFwiI0JFNzA1QlwiLCBcIiNCQzZCNTlcIiwgXCIjQkE2NjU3XCIsIFwiI0I4NjI1NVwiLCBcIiNCNjVENTRcIiwgXCIjQjM1OTUzXCIsIFwiI0IxNTQ1MlwiLCBcIiNBRTUwNTFcIiwgXCIjQUI0QjUwXCIsIFwiI0E4NDc1MFwiLCBcIiNBNTQzNTBcIiwgXCIjQTEzRjUwXCIsIFwiIzlFM0I1MFwiLCBcIiM5QTM3NTBcIiwgXCIjOTYzMzUwXCIsIFwiIzkyMkY1MFwiLCBcIiM4RTJDNTBcIiwgXCIjOEEyOTUwXCIsIFwiIzg1MjY1MFwiLCBcIiM4MDIzNTBcIiwgXCIjN0IyMTUwXCIsIFwiIzc2MUY0RlwiLCBcIiM3MTFENEZcIiwgXCIjNkMxQjRFXCIsIFwiIzY3MTk0Q1wiLCBcIiM2MTE4NEJcIiwgXCIjNUMxNzQ5XCIsIFwiIzU3MTY0N1wiLCBcIiM1MjE1NDVcIiwgXCIjNEQxNDQzXCIsIFwiIzQ4MTM0MVwiLCBcIiM0MzEyM0VcIiwgXCIjM0YxMjNEXCIsIFwiIzNCMTEzQlwiLCBcIiMzODExMzlcIiwgXCIjMzUxMTM4XCIsIFwiIzMzMTIzN1wiLCBcIiMzMDE0MzdcIl0sXG4gICAgcG9zaXRpb25zOiBbMCwgMC4wMDc4NzQwMTU3LCAwLjAxNTc0ODAzMTUsIDAuMDIzNjIyMDQ3MiwgMC4wMzE0OTYwNjMsIDAuMDM5MzcwMDc4NywgMC4wNDcyNDQwOTQ1LCAwLjA1NTExODExMDIsIDAuMDYyOTkyMTI2LCAwLjA3MDg2NjE0MTcsIDAuMDc4NzQwMTU3NSwgMC4wODY2MTQxNzMyLCAwLjA5NDQ4ODE4OSwgMC4xMDIzNjIyMDQ3LCAwLjExMDIzNjIyMDUsIDAuMTE4MTEwMjM2MiwgMC4xMjU5ODQyNTIsIDAuMTMzODU4MjY3NywgMC4xNDE3MzIyODM1LCAwLjE0OTYwNjI5OTIsIDAuMTU3NDgwMzE1LCAwLjE2NTM1NDMzMDcsIDAuMTczMjI4MzQ2NSwgMC4xODExMDIzNjIyLCAwLjE4ODk3NjM3OCwgMC4xOTY4NTAzOTM3LCAwLjIwNDcyNDQwOTQsIDAuMjEyNTk4NDI1MiwgMC4yMjA0NzI0NDA5LCAwLjIyODM0NjQ1NjcsIDAuMjM2MjIwNDcyNCwgMC4yNDQwOTQ0ODgyLCAwLjI1MTk2ODUwMzksIDAuMjU5ODQyNTE5NywgMC4yNjc3MTY1MzU0LCAwLjI3NTU5MDU1MTIsIDAuMjgzNDY0NTY2OSwgMC4yOTEzMzg1ODI3LCAwLjI5OTIxMjU5ODQsIDAuMzA3MDg2NjE0MiwgMC4zMTQ5NjA2Mjk5LCAwLjMyMjgzNDY0NTcsIDAuMzMwNzA4NjYxNCwgMC4zMzg1ODI2NzcyLCAwLjM0NjQ1NjY5MjksIDAuMzU0MzMwNzA4NywgMC4zNjIyMDQ3MjQ0LCAwLjM3MDA3ODc0MDIsIDAuMzc3OTUyNzU1OSwgMC4zODU4MjY3NzE3LCAwLjM5MzcwMDc4NzQsIDAuNDAxNTc0ODAzMSwgMC40MDk0NDg4MTg5LCAwLjQxNzMyMjgzNDYsIDAuNDI1MTk2ODUwNCwgMC40MzMwNzA4NjYxLCAwLjQ0MDk0NDg4MTksIDAuNDQ4ODE4ODk3NiwgMC40NTY2OTI5MTM0LCAwLjQ2NDU2NjkyOTEsIDAuNDcyNDQwOTQ0OSwgMC40ODAzMTQ5NjA2LCAwLjQ4ODE4ODk3NjQsIDAuNDk2MDYyOTkyMSwgMC41MDM5MzcwMDc5LCAwLjUxMTgxMTAyMzYsIDAuNTE5Njg1MDM5NCwgMC41Mjc1NTkwNTUxLCAwLjUzNTQzMzA3MDksIDAuNTQzMzA3MDg2NiwgMC41NTExODExMDI0LCAwLjU1OTA1NTExODEsIDAuNTY2OTI5MTMzOSwgMC41NzQ4MDMxNDk2LCAwLjU4MjY3NzE2NTQsIDAuNTkwNTUxMTgxMSwgMC41OTg0MjUxOTY5LCAwLjYwNjI5OTIxMjYsIDAuNjE0MTczMjI4MywgMC42MjIwNDcyNDQxLCAwLjYyOTkyMTI1OTgsIDAuNjM3Nzk1Mjc1NiwgMC42NDU2NjkyOTEzLCAwLjY1MzU0MzMwNzEsIDAuNjYxNDE3MzIyOCwgMC42NjkyOTEzMzg2LCAwLjY3NzE2NTM1NDMsIDAuNjg1MDM5MzcwMSwgMC42OTI5MTMzODU4LCAwLjcwMDc4NzQwMTYsIDAuNzA4NjYxNDE3MywgMC43MTY1MzU0MzMxLCAwLjcyNDQwOTQ0ODgsIDAuNzMyMjgzNDY0NiwgMC43NDAxNTc0ODAzLCAwLjc0ODAzMTQ5NjEsIDAuNzU1OTA1NTExOCwgMC43NjM3Nzk1Mjc2LCAwLjc3MTY1MzU0MzMsIDAuNzc5NTI3NTU5MSwgMC43ODc0MDE1NzQ4LCAwLjc5NTI3NTU5MDYsIDAuODAzMTQ5NjA2MywgMC44MTEwMjM2MjIsIDAuODE4ODk3NjM3OCwgMC44MjY3NzE2NTM1LCAwLjgzNDY0NTY2OTMsIDAuODQyNTE5Njg1LCAwLjg1MDM5MzcwMDgsIDAuODU4MjY3NzE2NSwgMC44NjYxNDE3MzIzLCAwLjg3NDAxNTc0OCwgMC44ODE4ODk3NjM4LCAwLjg4OTc2Mzc3OTUsIDAuODk3NjM3Nzk1MywgMC45MDU1MTE4MTEsIDAuOTEzMzg1ODI2OCwgMC45MjEyNTk4NDI1LCAwLjkyOTEzMzg1ODMsIDAuOTM3MDA3ODc0LCAwLjk0NDg4MTg4OTgsIDAuOTUyNzU1OTA1NSwgMC45NjA2Mjk5MjEzLCAwLjk2ODUwMzkzNywgMC45NzYzNzc5NTI4LCAwLjk4NDI1MTk2ODUsIDAuOTkyMTI1OTg0MywgMV1cbiAgfVxufTtcblxuZnVuY3Rpb24gcGVnJHN1YmNsYXNzKGNoaWxkLCBwYXJlbnQpIHtcbiAgZnVuY3Rpb24gQygpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG4gIH1cbiAgQy5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xuICBjaGlsZC5wcm90b3R5cGUgPSBuZXcgQygpO1xufVxuZnVuY3Rpb24gcGVnJFN5bnRheEVycm9yKG1lc3NhZ2UsIGV4cGVjdGVkLCBmb3VuZCwgbG9jYXRpb24pIHtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgdGhpcy5leHBlY3RlZCA9IGV4cGVjdGVkO1xuICB0aGlzLmZvdW5kID0gZm91bmQ7XG4gIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgdGhpcy5uYW1lID0gXCJTeW50YXhFcnJvclwiO1xuICBpZiAodHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBwZWckU3ludGF4RXJyb3IpO1xuICB9XG59XG5wZWckc3ViY2xhc3MocGVnJFN5bnRheEVycm9yLCBFcnJvcik7XG5wZWckU3ludGF4RXJyb3IuYnVpbGRNZXNzYWdlID0gZnVuY3Rpb24oZXhwZWN0ZWQsIGZvdW5kKSB7XG4gIHZhciBERVNDUklCRV9FWFBFQ1RBVElPTl9GTlMgPSB7XG4gICAgbGl0ZXJhbDogZnVuY3Rpb24oZXhwZWN0YXRpb24pIHtcbiAgICAgIHJldHVybiAnXCInICsgbGl0ZXJhbEVzY2FwZShleHBlY3RhdGlvbi50ZXh0KSArICdcIic7XG4gICAgfSxcbiAgICBjbGFzczogZnVuY3Rpb24oZXhwZWN0YXRpb24pIHtcbiAgICAgIHZhciBlc2NhcGVkUGFydHMgPSBleHBlY3RhdGlvbi5wYXJ0cy5tYXAoZnVuY3Rpb24ocGFydCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShwYXJ0KSA/IGNsYXNzRXNjYXBlKHBhcnRbMF0pICsgXCItXCIgKyBjbGFzc0VzY2FwZShwYXJ0WzFdKSA6IGNsYXNzRXNjYXBlKHBhcnQpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gXCJbXCIgKyAoZXhwZWN0YXRpb24uaW52ZXJ0ZWQgPyBcIl5cIiA6IFwiXCIpICsgZXNjYXBlZFBhcnRzICsgXCJdXCI7XG4gICAgfSxcbiAgICBhbnk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFwiYW55IGNoYXJhY3RlclwiO1xuICAgIH0sXG4gICAgZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBcImVuZCBvZiBpbnB1dFwiO1xuICAgIH0sXG4gICAgb3RoZXI6IGZ1bmN0aW9uKGV4cGVjdGF0aW9uKSB7XG4gICAgICByZXR1cm4gZXhwZWN0YXRpb24uZGVzY3JpcHRpb247XG4gICAgfSxcbiAgICBub3Q6IGZ1bmN0aW9uKGV4cGVjdGF0aW9uKSB7XG4gICAgICByZXR1cm4gXCJub3QgXCIgKyBkZXNjcmliZUV4cGVjdGF0aW9uKGV4cGVjdGF0aW9uLmV4cGVjdGVkKTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGhleChjaCkge1xuICAgIHJldHVybiBjaC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICB9XG4gIGZ1bmN0aW9uIGxpdGVyYWxFc2NhcGUocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoL1xcXFwvZywgXCJcXFxcXFxcXFwiKS5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykucmVwbGFjZSgvXFwwL2csIFwiXFxcXDBcIikucmVwbGFjZSgvXFx0L2csIFwiXFxcXHRcIikucmVwbGFjZSgvXFxuL2csIFwiXFxcXG5cIikucmVwbGFjZSgvXFxyL2csIFwiXFxcXHJcIikucmVwbGFjZSgvW1xceDAwLVxceDBGXS9nLCBmdW5jdGlvbihjaCkge1xuICAgICAgcmV0dXJuIFwiXFxcXHgwXCIgKyBoZXgoY2gpO1xuICAgIH0pLnJlcGxhY2UoL1tcXHgxMC1cXHgxRlxceDdGLVxceDlGXS9nLCBmdW5jdGlvbihjaCkge1xuICAgICAgcmV0dXJuIFwiXFxcXHhcIiArIGhleChjaCk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gY2xhc3NFc2NhcGUocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoL1xcXFwvZywgXCJcXFxcXFxcXFwiKS5yZXBsYWNlKC9cXF0vZywgXCJcXFxcXVwiKS5yZXBsYWNlKC9cXF4vZywgXCJcXFxcXlwiKS5yZXBsYWNlKC8tL2csIFwiXFxcXC1cIikucmVwbGFjZSgvXFwwL2csIFwiXFxcXDBcIikucmVwbGFjZSgvXFx0L2csIFwiXFxcXHRcIikucmVwbGFjZSgvXFxuL2csIFwiXFxcXG5cIikucmVwbGFjZSgvXFxyL2csIFwiXFxcXHJcIikucmVwbGFjZSgvW1xceDAwLVxceDBGXS9nLCBmdW5jdGlvbihjaCkge1xuICAgICAgcmV0dXJuIFwiXFxcXHgwXCIgKyBoZXgoY2gpO1xuICAgIH0pLnJlcGxhY2UoL1tcXHgxMC1cXHgxRlxceDdGLVxceDlGXS9nLCBmdW5jdGlvbihjaCkge1xuICAgICAgcmV0dXJuIFwiXFxcXHhcIiArIGhleChjaCk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVzY3JpYmVFeHBlY3RhdGlvbihleHBlY3RhdGlvbikge1xuICAgIHJldHVybiBERVNDUklCRV9FWFBFQ1RBVElPTl9GTlNbZXhwZWN0YXRpb24udHlwZV0oZXhwZWN0YXRpb24pO1xuICB9XG4gIGZ1bmN0aW9uIGRlc2NyaWJlRXhwZWN0ZWQoZXhwZWN0ZWQyKSB7XG4gICAgdmFyIGRlc2NyaXB0aW9ucyA9IGV4cGVjdGVkMi5tYXAoZGVzY3JpYmVFeHBlY3RhdGlvbik7XG4gICAgdmFyIGksIGo7XG4gICAgZGVzY3JpcHRpb25zLnNvcnQoKTtcbiAgICBpZiAoZGVzY3JpcHRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAoaSA9IDEsIGogPSAxOyBpIDwgZGVzY3JpcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChkZXNjcmlwdGlvbnNbaSAtIDFdICE9PSBkZXNjcmlwdGlvbnNbaV0pIHtcbiAgICAgICAgICBkZXNjcmlwdGlvbnNbal0gPSBkZXNjcmlwdGlvbnNbaV07XG4gICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkZXNjcmlwdGlvbnMubGVuZ3RoID0gajtcbiAgICB9XG4gICAgc3dpdGNoIChkZXNjcmlwdGlvbnMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbnNbMF07XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbnNbMF0gKyBcIiBvciBcIiArIGRlc2NyaXB0aW9uc1sxXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBkZXNjcmlwdGlvbnMuc2xpY2UoMCwgLTEpLmpvaW4oXCIsIFwiKSArIFwiLCBvciBcIiArIGRlc2NyaXB0aW9uc1tkZXNjcmlwdGlvbnMubGVuZ3RoIC0gMV07XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGRlc2NyaWJlRm91bmQoZm91bmQyKSB7XG4gICAgcmV0dXJuIGZvdW5kMiA/ICdcIicgKyBsaXRlcmFsRXNjYXBlKGZvdW5kMikgKyAnXCInIDogXCJlbmQgb2YgaW5wdXRcIjtcbiAgfVxuICByZXR1cm4gXCJFeHBlY3RlZCBcIiArIGRlc2NyaWJlRXhwZWN0ZWQoZXhwZWN0ZWQpICsgXCIgYnV0IFwiICsgZGVzY3JpYmVGb3VuZChmb3VuZCkgKyBcIiBmb3VuZC5cIjtcbn07XG5mdW5jdGlvbiBwZWckcGFyc2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fTtcbiAgdmFyIHBlZyRGQUlMRUQgPSB7fTtcbiAgdmFyIHBlZyRzdGFydFJ1bGVGdW5jdGlvbnMgPSB7IEV4cHJlc3Npb246IHBlZyRwYXJzZUV4cHJlc3Npb24gfTtcbiAgdmFyIHBlZyRzdGFydFJ1bGVGdW5jdGlvbiA9IHBlZyRwYXJzZUV4cHJlc3Npb247XG4gIHZhciBwZWckYzAgPSBcIitcIjtcbiAgdmFyIHBlZyRjMSA9IFwiLVwiO1xuICB2YXIgcGVnJGMyID0gXCIqXCI7XG4gIHZhciBwZWckYzMgPSBcIi9cIjtcbiAgdmFyIHBlZyRjNCA9IFwiKipcIjtcbiAgdmFyIHBlZyRjNSA9IFwiKFwiO1xuICB2YXIgcGVnJGM2ID0gXCIpXCI7XG4gIHZhciBwZWckcjAgPSAvXltcXC0rXS87XG4gIHZhciBwZWckcjEgPSAvXlswLTldLztcbiAgdmFyIHBlZyRyMiA9IC9eW2EtekEtWl8kXS87XG4gIHZhciBwZWckcjMgPSAvXlthLXpBLVpfJDAtOV0vO1xuICB2YXIgcGVnJHI0ID0gL15bIFxcdFxcblxccl0vO1xuICB2YXIgcGVnJGUwID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIitcIiwgZmFsc2UpO1xuICB2YXIgcGVnJGUxID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIi1cIiwgZmFsc2UpO1xuICB2YXIgcGVnJGUyID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIipcIiwgZmFsc2UpO1xuICB2YXIgcGVnJGUzID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIi9cIiwgZmFsc2UpO1xuICB2YXIgcGVnJGU0ID0gcGVnJGxpdGVyYWxFeHBlY3RhdGlvbihcIioqXCIsIGZhbHNlKTtcbiAgdmFyIHBlZyRlNSA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIoXCIsIGZhbHNlKTtcbiAgdmFyIHBlZyRlNiA9IHBlZyRsaXRlcmFsRXhwZWN0YXRpb24oXCIpXCIsIGZhbHNlKTtcbiAgdmFyIHBlZyRlNyA9IHBlZyRvdGhlckV4cGVjdGF0aW9uKFwiZmxvYXRcIik7XG4gIHZhciBwZWckZTggPSBwZWckb3RoZXJFeHBlY3RhdGlvbihcImludGVnZXJcIik7XG4gIHZhciBwZWckZTkgPSBwZWckb3RoZXJFeHBlY3RhdGlvbihcImlkZW50aWZpZXJcIik7XG4gIHZhciBwZWckZTEwID0gcGVnJG90aGVyRXhwZWN0YXRpb24oXCJ3aGl0ZXNwYWNlXCIpO1xuICB2YXIgcGVnJGYwID0gZnVuY3Rpb24oaGVhZCwgdGFpbCkge1xuICAgIHZhciBsaHMgPSBoZWFkO1xuICAgIHZhciBpLCBvcDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGFpbC5sZW5ndGg7IGkrKykge1xuICAgICAgb3AgPSB0YWlsW2ldWzFdO1xuICAgICAgbGhzID0gbWFrZU5vZGUobGhzLCB0YWlsW2ldWzNdLCBvcCk7XG4gICAgfVxuICAgIHJldHVybiBsaHM7XG4gIH07XG4gIHZhciBwZWckZjEgPSBmdW5jdGlvbihoZWFkLCB0YWlsKSB7XG4gICAgdmFyIGxocyA9IGhlYWQ7XG4gICAgdmFyIGksIG9wO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0YWlsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvcCA9IHRhaWxbaV1bMV07XG4gICAgICBsaHMgPSBtYWtlTm9kZShsaHMsIHRhaWxbaV1bM10sIG9wKTtcbiAgICB9XG4gICAgcmV0dXJuIGxocztcbiAgfTtcbiAgdmFyIHBlZyRmMiA9IGZ1bmN0aW9uKGV4cHIpIHtcbiAgICByZXR1cm4gZXhwcjtcbiAgfTtcbiAgdmFyIHBlZyRmMyA9IGZ1bmN0aW9uKG4sIGUpIHtcbiAgICByZXR1cm4geyBmbjogbiwgbGhzOiBlIH07XG4gIH07XG4gIHZhciBwZWckZjQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh0ZXh0KCksIDEwKTtcbiAgfTtcbiAgdmFyIHBlZyRmNSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBwYXJzZUludCh0ZXh0KCksIDEwKTtcbiAgfTtcbiAgdmFyIHBlZyRmNiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0ZXh0KCk7XG4gIH07XG4gIHZhciBwZWckY3VyclBvcyA9IDA7XG4gIHZhciBwZWckc2F2ZWRQb3MgPSAwO1xuICB2YXIgcGVnJHBvc0RldGFpbHNDYWNoZSA9IFt7IGxpbmU6IDEsIGNvbHVtbjogMSB9XTtcbiAgdmFyIHBlZyRleHBlY3RlZCA9IFtdO1xuICB2YXIgcGVnJHNpbGVudEZhaWxzID0gMDtcbiAgdmFyIHBlZyRyZXN1bHQ7XG4gIGlmIChcInN0YXJ0UnVsZVwiIGluIG9wdGlvbnMpIHtcbiAgICBpZiAoIShvcHRpb25zLnN0YXJ0UnVsZSBpbiBwZWckc3RhcnRSdWxlRnVuY3Rpb25zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBzdGFydCBwYXJzaW5nIGZyb20gcnVsZSBcImAgKyBvcHRpb25zLnN0YXJ0UnVsZSArICdcIi4nKTtcbiAgICB9XG4gICAgcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uID0gcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uc1tvcHRpb25zLnN0YXJ0UnVsZV07XG4gIH1cbiAgZnVuY3Rpb24gdGV4dCgpIHtcbiAgICByZXR1cm4gaW5wdXQuc3Vic3RyaW5nKHBlZyRzYXZlZFBvcywgcGVnJGN1cnJQb3MpO1xuICB9XG4gIGZ1bmN0aW9uIHBlZyRsaXRlcmFsRXhwZWN0YXRpb24odGV4dDIsIGlnbm9yZUNhc2UpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcImxpdGVyYWxcIiwgdGV4dDogdGV4dDIsIGlnbm9yZUNhc2UgfTtcbiAgfVxuICBmdW5jdGlvbiBwZWckZW5kRXhwZWN0YXRpb24oKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJlbmRcIiB9O1xuICB9XG4gIGZ1bmN0aW9uIHBlZyRvdGhlckV4cGVjdGF0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJvdGhlclwiLCBkZXNjcmlwdGlvbiB9O1xuICB9XG4gIGZ1bmN0aW9uIHBlZyRjb21wdXRlUG9zRGV0YWlscyhwb3MpIHtcbiAgICB2YXIgZGV0YWlscyA9IHBlZyRwb3NEZXRhaWxzQ2FjaGVbcG9zXTtcbiAgICB2YXIgcDtcbiAgICBpZiAoZGV0YWlscykge1xuICAgICAgcmV0dXJuIGRldGFpbHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHAgPSBwb3MgLSAxO1xuICAgICAgd2hpbGUgKCFwZWckcG9zRGV0YWlsc0NhY2hlW3BdKSB7XG4gICAgICAgIHAtLTtcbiAgICAgIH1cbiAgICAgIGRldGFpbHMgPSBwZWckcG9zRGV0YWlsc0NhY2hlW3BdO1xuICAgICAgZGV0YWlscyA9IHtcbiAgICAgICAgbGluZTogZGV0YWlscy5saW5lLFxuICAgICAgICBjb2x1bW46IGRldGFpbHMuY29sdW1uXG4gICAgICB9O1xuICAgICAgd2hpbGUgKHAgPCBwb3MpIHtcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocCkgPT09IDEwKSB7XG4gICAgICAgICAgZGV0YWlscy5saW5lKys7XG4gICAgICAgICAgZGV0YWlscy5jb2x1bW4gPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRldGFpbHMuY29sdW1uKys7XG4gICAgICAgIH1cbiAgICAgICAgcCsrO1xuICAgICAgfVxuICAgICAgcGVnJHBvc0RldGFpbHNDYWNoZVtwb3NdID0gZGV0YWlscztcbiAgICAgIHJldHVybiBkZXRhaWxzO1xuICAgIH1cbiAgfVxuICB2YXIgcGVnJFZBTElERklMRU5BTUUgPSB0eXBlb2Ygb3B0aW9ucy5maWxlbmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBvcHRpb25zLmZpbGVuYW1lLmxlbmd0aCA+IDA7XG4gIGZ1bmN0aW9uIHBlZyRjb21wdXRlTG9jYXRpb24oc3RhcnRQb3MsIGVuZFBvcykge1xuICAgIHZhciBsb2MgPSB7fTtcbiAgICBpZiAocGVnJFZBTElERklMRU5BTUUpXG4gICAgICBsb2MuZmlsZW5hbWUgPSBvcHRpb25zLmZpbGVuYW1lO1xuICAgIHZhciBzdGFydFBvc0RldGFpbHMgPSBwZWckY29tcHV0ZVBvc0RldGFpbHMoc3RhcnRQb3MpO1xuICAgIGxvYy5zdGFydCA9IHtcbiAgICAgIG9mZnNldDogc3RhcnRQb3MsXG4gICAgICBsaW5lOiBzdGFydFBvc0RldGFpbHMubGluZSxcbiAgICAgIGNvbHVtbjogc3RhcnRQb3NEZXRhaWxzLmNvbHVtblxuICAgIH07XG4gICAgdmFyIGVuZFBvc0RldGFpbHMgPSBwZWckY29tcHV0ZVBvc0RldGFpbHMoZW5kUG9zKTtcbiAgICBsb2MuZW5kID0ge1xuICAgICAgb2Zmc2V0OiBlbmRQb3MsXG4gICAgICBsaW5lOiBlbmRQb3NEZXRhaWxzLmxpbmUsXG4gICAgICBjb2x1bW46IGVuZFBvc0RldGFpbHMuY29sdW1uXG4gICAgfTtcbiAgICByZXR1cm4gbG9jO1xuICB9XG4gIGZ1bmN0aW9uIHBlZyRiZWdpbigpIHtcbiAgICBwZWckZXhwZWN0ZWQucHVzaCh7IHBvczogcGVnJGN1cnJQb3MsIHZhcmlhbnRzOiBbXSB9KTtcbiAgfVxuICBmdW5jdGlvbiBwZWckZXhwZWN0KGV4cGVjdGVkMikge1xuICAgIHZhciB0b3AgPSBwZWckZXhwZWN0ZWRbcGVnJGV4cGVjdGVkLmxlbmd0aCAtIDFdO1xuICAgIGlmIChwZWckY3VyclBvcyA8IHRvcC5wb3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHBlZyRjdXJyUG9zID4gdG9wLnBvcykge1xuICAgICAgdG9wLnBvcyA9IHBlZyRjdXJyUG9zO1xuICAgICAgdG9wLnZhcmlhbnRzID0gW107XG4gICAgfVxuICAgIHRvcC52YXJpYW50cy5wdXNoKGV4cGVjdGVkMik7XG4gIH1cbiAgZnVuY3Rpb24gcGVnJGJ1aWxkU3RydWN0dXJlZEVycm9yKGV4cGVjdGVkMiwgZm91bmQsIGxvY2F0aW9uMikge1xuICAgIHJldHVybiBuZXcgcGVnJFN5bnRheEVycm9yKFxuICAgICAgcGVnJFN5bnRheEVycm9yLmJ1aWxkTWVzc2FnZShleHBlY3RlZDIsIGZvdW5kKSxcbiAgICAgIGV4cGVjdGVkMixcbiAgICAgIGZvdW5kLFxuICAgICAgbG9jYXRpb24yXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBwZWckYnVpbGRFcnJvcigpIHtcbiAgICB2YXIgZXhwZWN0ZWQyID0gcGVnJGV4cGVjdGVkWzBdO1xuICAgIHZhciBmYWlsUG9zID0gZXhwZWN0ZWQyLnBvcztcbiAgICByZXR1cm4gcGVnJGJ1aWxkU3RydWN0dXJlZEVycm9yKFxuICAgICAgZXhwZWN0ZWQyLnZhcmlhbnRzLFxuICAgICAgZmFpbFBvcyA8IGlucHV0Lmxlbmd0aCA/IGlucHV0LmNoYXJBdChmYWlsUG9zKSA6IG51bGwsXG4gICAgICBmYWlsUG9zIDwgaW5wdXQubGVuZ3RoID8gcGVnJGNvbXB1dGVMb2NhdGlvbihmYWlsUG9zLCBmYWlsUG9zICsgMSkgOiBwZWckY29tcHV0ZUxvY2F0aW9uKGZhaWxQb3MsIGZhaWxQb3MpXG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBwZWckcGFyc2VFeHByZXNzaW9uKCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1LCBzNiwgczc7XG4gICAgdmFyIHJ1bGUkZXhwZWN0cyA9IGZ1bmN0aW9uKGV4cGVjdGVkMikge1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMClcbiAgICAgICAgcGVnJGV4cGVjdChleHBlY3RlZDIpO1xuICAgIH07XG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRwYXJzZVRlcm0oKTtcbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gW107XG4gICAgICBzMyA9IHBlZyRjdXJyUG9zO1xuICAgICAgczQgPSBwZWckcGFyc2VfKCk7XG4gICAgICBydWxlJGV4cGVjdHMocGVnJGUwKTtcbiAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDMpIHtcbiAgICAgICAgczUgPSBwZWckYzA7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgICBpZiAoczUgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcnVsZSRleHBlY3RzKHBlZyRlMSk7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDUpIHtcbiAgICAgICAgICBzNSA9IHBlZyRjMTtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHM2ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICBzNyA9IHBlZyRwYXJzZVRlcm0oKTtcbiAgICAgICAgaWYgKHM3ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczQgPSBbczQsIHM1LCBzNiwgczddO1xuICAgICAgICAgIHMzID0gczQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcbiAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczM7XG4gICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMi5wdXNoKHMzKTtcbiAgICAgICAgczMgPSBwZWckY3VyclBvcztcbiAgICAgICAgczQgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgIHJ1bGUkZXhwZWN0cyhwZWckZTApO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQzKSB7XG4gICAgICAgICAgczUgPSBwZWckYzA7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHM1ID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcnVsZSRleHBlY3RzKHBlZyRlMSk7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0NSkge1xuICAgICAgICAgICAgczUgPSBwZWckYzE7XG4gICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHM2ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgIHM3ID0gcGVnJHBhcnNlVGVybSgpO1xuICAgICAgICAgIGlmIChzNyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczQgPSBbczQsIHM1LCBzNiwgczddO1xuICAgICAgICAgICAgczMgPSBzNDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcbiAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcbiAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckZjAoczEsIHMyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG4gICAgcmV0dXJuIHMwO1xuICB9XG4gIGZ1bmN0aW9uIHBlZyRwYXJzZVRlcm0oKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2LCBzNztcbiAgICB2YXIgcnVsZSRleHBlY3RzID0gZnVuY3Rpb24oZXhwZWN0ZWQyKSB7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKVxuICAgICAgICBwZWckZXhwZWN0KGV4cGVjdGVkMik7XG4gICAgfTtcbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gcGVnJHBhcnNlRXhwb25lbnRpYWwoKTtcbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gW107XG4gICAgICBzMyA9IHBlZyRjdXJyUG9zO1xuICAgICAgczQgPSBwZWckcGFyc2VfKCk7XG4gICAgICBydWxlJGV4cGVjdHMocGVnJGUyKTtcbiAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDIpIHtcbiAgICAgICAgczUgPSBwZWckYzI7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgICBpZiAoczUgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcnVsZSRleHBlY3RzKHBlZyRlMyk7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDcpIHtcbiAgICAgICAgICBzNSA9IHBlZyRjMztcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHM2ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICBzNyA9IHBlZyRwYXJzZUV4cG9uZW50aWFsKCk7XG4gICAgICAgIGlmIChzNyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHM0ID0gW3M0LCBzNSwgczYsIHM3XTtcbiAgICAgICAgICBzMyA9IHM0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczM7XG4gICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMzO1xuICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgICB3aGlsZSAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIucHVzaChzMyk7XG4gICAgICAgIHMzID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIHM0ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICBydWxlJGV4cGVjdHMocGVnJGUyKTtcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0Mikge1xuICAgICAgICAgIHM1ID0gcGVnJGMyO1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzNSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHJ1bGUkZXhwZWN0cyhwZWckZTMpO1xuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDcpIHtcbiAgICAgICAgICAgIHM1ID0gcGVnJGMzO1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNiA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICBzNyA9IHBlZyRwYXJzZUV4cG9uZW50aWFsKCk7XG4gICAgICAgICAgaWYgKHM3ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNCA9IFtzNCwgczUsIHM2LCBzN107XG4gICAgICAgICAgICBzMyA9IHM0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMzO1xuICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMzO1xuICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRmMShzMSwgczIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICByZXR1cm4gczA7XG4gIH1cbiAgZnVuY3Rpb24gcGVnJHBhcnNlRXhwb25lbnRpYWwoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2LCBzNztcbiAgICB2YXIgcnVsZSRleHBlY3RzID0gZnVuY3Rpb24oZXhwZWN0ZWQyKSB7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKVxuICAgICAgICBwZWckZXhwZWN0KGV4cGVjdGVkMik7XG4gICAgfTtcbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gcGVnJHBhcnNlRmFjdG9yKCk7XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IFtdO1xuICAgICAgczMgPSBwZWckY3VyclBvcztcbiAgICAgIHM0ID0gcGVnJHBhcnNlXygpO1xuICAgICAgcnVsZSRleHBlY3RzKHBlZyRlNCk7XG4gICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAyKSA9PT0gcGVnJGM0KSB7XG4gICAgICAgIHM1ID0gcGVnJGM0O1xuICAgICAgICBwZWckY3VyclBvcyArPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHM2ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICBzNyA9IHBlZyRwYXJzZUZhY3RvcigpO1xuICAgICAgICBpZiAoczcgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNCA9IFtzNCwgczUsIHM2LCBzN107XG4gICAgICAgICAgczMgPSBzNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMzO1xuICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcbiAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgICAgd2hpbGUgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyLnB1c2goczMpO1xuICAgICAgICBzMyA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBzNCA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgcnVsZSRleHBlY3RzKHBlZyRlNCk7XG4gICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDIpID09PSBwZWckYzQpIHtcbiAgICAgICAgICBzNSA9IHBlZyRjNDtcbiAgICAgICAgICBwZWckY3VyclBvcyArPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNiA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICBzNyA9IHBlZyRwYXJzZUZhY3RvcigpO1xuICAgICAgICAgIGlmIChzNyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczQgPSBbczQsIHM1LCBzNiwgczddO1xuICAgICAgICAgICAgczMgPSBzNDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcbiAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcbiAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckZjEoczEsIHMyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG4gICAgcmV0dXJuIHMwO1xuICB9XG4gIGZ1bmN0aW9uIHBlZyRwYXJzZUZhY3RvcigpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNTtcbiAgICB2YXIgcnVsZSRleHBlY3RzID0gZnVuY3Rpb24oZXhwZWN0ZWQyKSB7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKVxuICAgICAgICBwZWckZXhwZWN0KGV4cGVjdGVkMik7XG4gICAgfTtcbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHJ1bGUkZXhwZWN0cyhwZWckZTUpO1xuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDApIHtcbiAgICAgIHMxID0gcGVnJGM1O1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gcGVnJHBhcnNlXygpO1xuICAgICAgczMgPSBwZWckcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczQgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgIHJ1bGUkZXhwZWN0cyhwZWckZTYpO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQxKSB7XG4gICAgICAgICAgczUgPSBwZWckYzY7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcGVnJHNhdmVkUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckZjIoczMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczAgPSBwZWckcGFyc2VGbG9hdCgpO1xuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMwID0gcGVnJHBhcnNlSW50ZWdlcigpO1xuICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgIHMxID0gcGVnJHBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgcnVsZSRleHBlY3RzKHBlZyRlNSk7XG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQwKSB7XG4gICAgICAgICAgICAgIHMyID0gcGVnJGM1O1xuICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHMzID0gcGVnJHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBydWxlJGV4cGVjdHMocGVnJGU2KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQxKSB7XG4gICAgICAgICAgICAgICAgICBzNCA9IHBlZyRjNjtcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHM0ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGYzKHMxLCBzMyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczAgPSBwZWckcGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzMDtcbiAgfVxuICBmdW5jdGlvbiBwZWckcGFyc2VGbG9hdCgpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNTtcbiAgICB2YXIgcnVsZSRleHBlY3RzID0gZnVuY3Rpb24oZXhwZWN0ZWQyKSB7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKVxuICAgICAgICBwZWckZXhwZWN0KGV4cGVjdGVkMik7XG4gICAgfTtcbiAgICBydWxlJGV4cGVjdHMocGVnJGU3KTtcbiAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gW107XG4gICAgaWYgKHBlZyRyMC50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEucHVzaChzMik7XG4gICAgICBpZiAocGVnJHIwLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH1cbiAgICBzMiA9IFtdO1xuICAgIGlmIChwZWckcjEudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgczMgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHdoaWxlIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMi5wdXNoKHMzKTtcbiAgICAgICAgaWYgKHBlZyRyMS50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgICAgczMgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICB9XG4gICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBpZiAoaW5wdXQubGVuZ3RoID4gcGVnJGN1cnJQb3MpIHtcbiAgICAgICAgczMgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHM0ID0gW107XG4gICAgICAgIGlmIChwZWckcjEudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgIHM1ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICB3aGlsZSAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM0LnB1c2goczUpO1xuICAgICAgICAgICAgaWYgKHBlZyRyMS50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgICAgICAgIHM1ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczQgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGY0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG4gICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgcmV0dXJuIHMwO1xuICB9XG4gIGZ1bmN0aW9uIHBlZyRwYXJzZUludGVnZXIoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuICAgIHZhciBydWxlJGV4cGVjdHMgPSBmdW5jdGlvbihleHBlY3RlZDIpIHtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApXG4gICAgICAgIHBlZyRleHBlY3QoZXhwZWN0ZWQyKTtcbiAgICB9O1xuICAgIHJ1bGUkZXhwZWN0cyhwZWckZTgpO1xuICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBbXTtcbiAgICBpZiAocGVnJHIwLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgIHMyID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICB9XG4gICAgd2hpbGUgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMS5wdXNoKHMyKTtcbiAgICAgIGlmIChwZWckcjAudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICB9XG4gICAgfVxuICAgIHMyID0gW107XG4gICAgaWYgKHBlZyRyMS50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICBzMyA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgd2hpbGUgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyLnB1c2goczMpO1xuICAgICAgICBpZiAocGVnJHIxLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICBzMyA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgIH1cbiAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHBlZyRzYXZlZFBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckZjUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICB9XG4gICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgcmV0dXJuIHMwO1xuICB9XG4gIGZ1bmN0aW9uIHBlZyRwYXJzZUlkZW50aWZpZXIoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNDtcbiAgICB2YXIgcnVsZSRleHBlY3RzID0gZnVuY3Rpb24oZXhwZWN0ZWQyKSB7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKVxuICAgICAgICBwZWckZXhwZWN0KGV4cGVjdGVkMik7XG4gICAgfTtcbiAgICBydWxlJGV4cGVjdHMocGVnJGU5KTtcbiAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gW107XG4gICAgaWYgKHBlZyRyMC50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEucHVzaChzMik7XG4gICAgICBpZiAocGVnJHIwLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGVnJHIyLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgIHMyID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICB9XG4gICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMyA9IFtdO1xuICAgICAgaWYgKHBlZyRyMy50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgIHM0ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHM0ID0gcGVnJEZBSUxFRDtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMy5wdXNoKHM0KTtcbiAgICAgICAgaWYgKHBlZyRyMy50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgICAgczQgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczQgPSBwZWckRkFJTEVEO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwZWckc2F2ZWRQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJGY2KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgIHJldHVybiBzMDtcbiAgfVxuICBmdW5jdGlvbiBwZWckcGFyc2VfKCkge1xuICAgIHZhciBzMCwgczE7XG4gICAgdmFyIHJ1bGUkZXhwZWN0cyA9IGZ1bmN0aW9uKGV4cGVjdGVkMikge1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMClcbiAgICAgICAgcGVnJGV4cGVjdChleHBlY3RlZDIpO1xuICAgIH07XG4gICAgcnVsZSRleHBlY3RzKHBlZyRlMTApO1xuICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgIHMwID0gW107XG4gICAgaWYgKHBlZyRyNC50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICBzMSA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgfVxuICAgIHdoaWxlIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczAucHVzaChzMSk7XG4gICAgICBpZiAocGVnJHI0LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgczEgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgfVxuICAgIH1cbiAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICByZXR1cm4gczA7XG4gIH1cbiAgZnVuY3Rpb24gbWFrZU5vZGUobGhzLCByaHMsIG9wKSB7XG4gICAgaWYgKHR5cGVvZiBsaHMgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHJocyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgc3dpdGNoIChvcCkge1xuICAgICAgICBjYXNlIFwiK1wiOlxuICAgICAgICAgIHJldHVybiBsaHMgKyByaHM7XG4gICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgICAgcmV0dXJuIGxocyAtIHJocztcbiAgICAgICAgY2FzZSBcIipcIjpcbiAgICAgICAgICByZXR1cm4gbGhzICogcmhzO1xuICAgICAgICBjYXNlIFwiL1wiOlxuICAgICAgICAgIHJldHVybiBsaHMgLyByaHM7XG4gICAgICAgIGNhc2UgXCIqKlwiOlxuICAgICAgICAgIHJldHVybiBNYXRoLnBvdyhsaHMsIHJocyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBsaHMsXG4gICAgICByaHMsXG4gICAgICBvcFxuICAgIH07XG4gIH1cbiAgcGVnJGJlZ2luKCk7XG4gIHBlZyRyZXN1bHQgPSBwZWckc3RhcnRSdWxlRnVuY3Rpb24oKTtcbiAgaWYgKHBlZyRyZXN1bHQgIT09IHBlZyRGQUlMRUQgJiYgcGVnJGN1cnJQb3MgPT09IGlucHV0Lmxlbmd0aCkge1xuICAgIHJldHVybiBwZWckcmVzdWx0O1xuICB9IGVsc2Uge1xuICAgIGlmIChwZWckcmVzdWx0ICE9PSBwZWckRkFJTEVEICYmIHBlZyRjdXJyUG9zIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICBwZWckZXhwZWN0KHBlZyRlbmRFeHBlY3RhdGlvbigpKTtcbiAgICB9XG4gICAgdGhyb3cgcGVnJGJ1aWxkRXJyb3IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuZnVuY3Rpb24gZGVmYXVsdEZvcihhcmcsIHZhbCkge1xuICByZXR1cm4gdHlwZW9mIGFyZyAhPT0gXCJ1bmRlZmluZWRcIiA/IGFyZyA6IHZhbDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZTNEQ29udGV4dChjYW52YXMsIG9wdEF0dHJpYnMpIHtcbiAgY29uc3QgbmFtZXMgPSBbXCJ3ZWJnbFwiLCBcImV4cGVyaW1lbnRhbC13ZWJnbFwiXTtcbiAgbGV0IGNvbnRleHQgPSBudWxsO1xuICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgbmFtZXMubGVuZ3RoOyArK2lpKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChuYW1lc1tpaV0sIG9wdEF0dHJpYnMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoIWNvbnRleHQgfHwgIWNvbnRleHQuZ2V0RXh0ZW5zaW9uKFwiT0VTX3RleHR1cmVfZmxvYXRcIikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0oZ2wsIHZlcnRleFNoYWRlclNvdXJjZTIsIGZyYWdtZW50U2hhZGVyU291cmNlMikge1xuICBjb25zdCB2ZXJ0ZXhTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuVkVSVEVYX1NIQURFUik7XG4gIGdsLnNoYWRlclNvdXJjZSh2ZXJ0ZXhTaGFkZXIsIHZlcnRleFNoYWRlclNvdXJjZTIpO1xuICBnbC5jb21waWxlU2hhZGVyKHZlcnRleFNoYWRlcik7XG4gIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHZlcnRleFNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGdsLmdldFNoYWRlckluZm9Mb2codmVydGV4U2hhZGVyKSk7XG4gIH1cbiAgY29uc3QgZnJhZ21lbnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSKTtcbiAgZ2wuc2hhZGVyU291cmNlKGZyYWdtZW50U2hhZGVyLCBmcmFnbWVudFNoYWRlclNvdXJjZTIpO1xuICBnbC5jb21waWxlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcbiAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoZnJhZ21lbnRTaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihnbC5nZXRTaGFkZXJJbmZvTG9nKGZyYWdtZW50U2hhZGVyKSk7XG4gIH1cbiAgY29uc3QgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XG4gIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XG4gIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuICByZXR1cm4gcHJvZ3JhbTtcbn1cbmZ1bmN0aW9uIHNldFJlY3RhbmdsZShnbCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICBjb25zdCB4MSA9IHg7XG4gIGNvbnN0IHgyID0geCArIHdpZHRoO1xuICBjb25zdCB5MSA9IHk7XG4gIGNvbnN0IHkyID0geSArIGhlaWdodDtcbiAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgIHgxLFxuICAgIHkxLFxuICAgIHgyLFxuICAgIHkxLFxuICAgIHgxLFxuICAgIHkyLFxuICAgIHgxLFxuICAgIHkyLFxuICAgIHgyLFxuICAgIHkxLFxuICAgIHgyLFxuICAgIHkyXG4gIF0pLCBnbC5TVEFUSUNfRFJBVyk7XG59XG5mdW5jdGlvbiBjcmVhdGVEYXRhc2V0KGdsLCBpZCwgZGF0YSwgd2lkdGgsIGhlaWdodCkge1xuICBsZXQgdGV4dHVyZURhdGE7XG4gIGlmIChnbCkge1xuICAgIGdsLnZpZXdwb3J0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIHRleHR1cmVEYXRhID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmVEYXRhKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgIGdsLnRleEltYWdlMkQoXG4gICAgICBnbC5URVhUVVJFXzJELFxuICAgICAgMCxcbiAgICAgIGdsLkxVTUlOQU5DRSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgMCxcbiAgICAgIGdsLkxVTUlOQU5DRSxcbiAgICAgIGdsLkZMT0FULFxuICAgICAgbmV3IEZsb2F0MzJBcnJheShkYXRhKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHsgdGV4dHVyZURhdGEsIHdpZHRoLCBoZWlnaHQsIGRhdGEsIGlkIH07XG59XG5mdW5jdGlvbiBkZXN0cm95RGF0YXNldChnbCwgZGF0YXNldCkge1xuICBpZiAoZ2wpIHtcbiAgICBnbC5kZWxldGVUZXh0dXJlKGRhdGFzZXQudGV4dHVyZURhdGEpO1xuICB9XG59XG5mdW5jdGlvbiBhZGRDb2xvclNjYWxlKG5hbWUsIGNvbG9ycywgcG9zaXRpb25zKSB7XG4gIGlmIChjb2xvcnMubGVuZ3RoICE9PSBwb3NpdGlvbnMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb2xvciBzY2FsZS5cIik7XG4gIH1cbiAgY29sb3JzY2FsZXNbbmFtZV0gPSB7IGNvbG9ycywgcG9zaXRpb25zIH07XG59XG5mdW5jdGlvbiByZW5kZXJDb2xvclNjYWxlVG9DYW52YXMobmFtZSwgY2FudmFzLCB0eXBlID0gXCJjb250aW51b3VzXCIpIHtcbiAgY29uc3QgY3NEZWYgPSBjb2xvcnNjYWxlc1tuYW1lXTtcbiAgY2FudmFzLmhlaWdodCA9IDE7XG4gIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gIGNvbnN0IHdpZHRoID0gODE5MjtcbiAgaWYgKCFjdHgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZ2V0IGNhbnZhcyBjb250ZXh0LlwiKTtcbiAgfVxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGNzRGVmKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGlmICh0eXBlID09PSBcImNvbnRpbnVvdXNcIikge1xuICAgICAgY29uc3QgZ3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgd2lkdGgsIDEpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjc0RlZi5jb2xvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKGNzRGVmLnBvc2l0aW9uc1tpXSwgY3NEZWYuY29sb3JzW2ldKTtcbiAgICAgIH1cbiAgICAgIGN0eC5maWxsU3R5bGUgPSBncmFkaWVudDtcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgMSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcImRpc2NyZXRlXCIpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3NEZWYuY29sb3JzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IG5vd1BvcyA9IGNzRGVmLnBvc2l0aW9uc1tpXSwgbGFzdFBvcyA9IGNzRGVmLnBvc2l0aW9uc1tpICsgMV07XG4gICAgICAgIGNvbnN0IHN0YXJ0UG9zID0gbm93UG9zICogKHdpZHRoIC0gMTApO1xuICAgICAgICBjb25zdCBlbmRQb3MgPSBsYXN0UG9zID8gbGFzdFBvcyAqICh3aWR0aCAtIDEwKSA6IHdpZHRoO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gY3NEZWYuY29sb3JzW2ldO1xuICAgICAgICBjdHguZmlsbFJlY3Qoc3RhcnRQb3MsIDAsIGVuZFBvcyAtIHN0YXJ0UG9zLCAxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb2xvciBzY2FsZSB0eXBlLlwiKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGNzRGVmKSA9PT0gXCJbb2JqZWN0IFVpbnQ4QXJyYXldXCIpIHtcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjb25zdCBpbWdEYXRhID0gY3R4LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgMSk7XG4gICAgaW1nRGF0YS5kYXRhLnNldChjc0RlZik7XG4gICAgY3R4LnB1dEltYWdlRGF0YShpbWdEYXRhLCAwLCAwKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb2xvciBzY2FsZSBub3QgZGVmaW5lZC5cIik7XG4gIH1cbn1cbmNvbnN0IHZlcnRleFNoYWRlclNvdXJjZSA9IGBcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247XG5hdHRyaWJ1dGUgdmVjMiBhX3RleENvb3JkO1xudW5pZm9ybSBtYXQzIHVfbWF0cml4O1xudW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjtcbnZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xudm9pZCBtYWluKCkge1xuICAvLyBhcHBseSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcbiAgdmVjMiBwb3NpdGlvbiA9ICh1X21hdHJpeCAqIHZlYzMoYV9wb3NpdGlvbiwgMSkpLnh5O1xuICAvLyBjb252ZXJ0IHRoZSByZWN0YW5nbGUgZnJvbSBwaXhlbHMgdG8gMC4wIHRvIDEuMFxuICB2ZWMyIHplcm9Ub09uZSA9IHBvc2l0aW9uIC8gdV9yZXNvbHV0aW9uO1xuICAvLyBjb252ZXJ0IGZyb20gMC0+MSB0byAwLT4yXG4gIHZlYzIgemVyb1RvVHdvID0gemVyb1RvT25lICogMi4wO1xuICAvLyBjb252ZXJ0IGZyb20gMC0+MiB0byAtMS0+KzEgKGNsaXBzcGFjZSlcbiAgdmVjMiBjbGlwU3BhY2UgPSB6ZXJvVG9Ud28gLSAxLjA7XG4gIGdsX1Bvc2l0aW9uID0gdmVjNChjbGlwU3BhY2UgKiB2ZWMyKDEsIC0xKSwgMCwgMSk7XG4gIC8vIHBhc3MgdGhlIHRleENvb3JkIHRvIHRoZSBmcmFnbWVudCBzaGFkZXJcbiAgLy8gVGhlIEdQVSB3aWxsIGludGVycG9sYXRlIHRoaXMgdmFsdWUgYmV0d2VlbiBwb2ludHMuXG4gIHZfdGV4Q29vcmQgPSBhX3RleENvb3JkO1xufWA7XG5jb25zdCBmcmFnbWVudFNoYWRlclNvdXJjZSA9IGBcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuLy8gb3VyIHRleHR1cmVcbnVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZURhdGE7XG51bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmVTY2FsZTtcbnVuaWZvcm0gdmVjMiB1X3RleHR1cmVTaXplO1xudW5pZm9ybSB2ZWMyIHVfZG9tYWluO1xudW5pZm9ybSB2ZWMyIHVfZGlzcGxheV9yYW5nZTtcbnVuaWZvcm0gYm9vbCB1X2FwcGx5X2Rpc3BsYXlfcmFuZ2U7XG51bmlmb3JtIGZsb2F0IHVfbm9EYXRhVmFsdWU7XG51bmlmb3JtIGJvb2wgdV9jbGFtcExvdztcbnVuaWZvcm0gYm9vbCB1X2NsYW1wSGlnaDtcbi8vIHRoZSB0ZXhDb29yZHMgcGFzc2VkIGluIGZyb20gdGhlIHZlcnRleCBzaGFkZXIuXG52YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcblxuYm9vbCBpc25hbiggZmxvYXQgdmFsICkge1xuICByZXR1cm4gKCB2YWwgPCAwLjAgfHwgMC4wIDwgdmFsIHx8IHZhbCA9PSAwLjAgKSA/IGZhbHNlIDogdHJ1ZTtcbn1cblxudm9pZCBtYWluKCkge1xuICB2ZWMyIG9uZVBpeGVsID0gdmVjMigxLjAsIDEuMCkgLyB1X3RleHR1cmVTaXplO1xuICBmbG9hdCB2YWx1ZSA9IHRleHR1cmUyRCh1X3RleHR1cmVEYXRhLCB2X3RleENvb3JkKVswXTtcbiAgaWYodmFsdWUgPCAtMy40MDI4MjM0NjZlKzM4KSAvLyBDaGVjayBmb3IgcG9zc2libGUgTmFOIHZhbHVlXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAsIDAsIDAuMCk7XG4gIGVsc2UgaWYgKHZhbHVlID09IHVfbm9EYXRhVmFsdWUgfHwgaXNuYW4odmFsdWUpKVxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLCAwLCAwLjApO1xuICBlbHNlIGlmICh1X2FwcGx5X2Rpc3BsYXlfcmFuZ2UgJiYgKHZhbHVlIDwgdV9kaXNwbGF5X3JhbmdlWzBdIHx8IHZhbHVlID49IHVfZGlzcGxheV9yYW5nZVsxXSkpXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLCAwLCAwLjApO1xuICBlbHNlIGlmICgoIXVfY2xhbXBMb3cgJiYgdmFsdWUgPCB1X2RvbWFpblswXSkgfHwgKCF1X2NsYW1wSGlnaCAmJiB2YWx1ZSA+IHVfZG9tYWluWzFdKSlcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAsIDAsIDAsIDApO1xuICBlbHNlIHtcbiAgICBmbG9hdCBub3JtYWxpc2VkVmFsdWUgPSAodmFsdWUgLSB1X2RvbWFpblswXSkgLyAodV9kb21haW5bMV0gLSB1X2RvbWFpblswXSk7XG4gICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVfdGV4dHVyZVNjYWxlLCB2ZWMyKG5vcm1hbGlzZWRWYWx1ZSwgMCkpO1xuICB9XG59YDtcbmNsYXNzIHBsb3Qge1xuICBjYW52YXM7XG4gIGN1cnJlbnREYXRhc2V0O1xuICBkYXRhc2V0Q29sbGVjdGlvbjtcbiAgZ2w7XG4gIHByb2dyYW07XG4gIHRleENvb3JkQnVmZmVyO1xuICBjdHg7XG4gIGRpc3BsYXlSYW5nZTtcbiAgYXBwbHlEaXNwbGF5UmFuZ2U7XG4gIG1hdHJpeDtcbiAgY29sb3JTY2FsZUltYWdlO1xuICBkb21haW47XG4gIGNvbG9yU2NhbGVDYW52YXM7XG4gIG5hbWU7XG4gIGNsYW1wTG93O1xuICBjbGFtcEhpZ2g7XG4gIHRleHR1cmVTY2FsZTtcbiAgbm9EYXRhVmFsdWU7XG4gIGV4cHJlc3Npb25Bc3Q7XG4gIGNvbG9yVHlwZSA9IFwiY29udGludW91c1wiO1xuICBwb3NpdGlvbkJ1ZmZlcjtcbiAgcHJvZ3JhbUNhY2hlID0ge307XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLmRhdGFzZXRDb2xsZWN0aW9uID0ge307XG4gICAgdGhpcy5jdXJyZW50RGF0YXNldCA9IG51bGw7XG4gICAgdGhpcy5zZXRDYW52YXMob3B0aW9ucy5jYW52YXMpO1xuICAgIHRoaXMuc2V0Q29sb3JUeXBlKG9wdGlvbnMudHlwZSk7XG4gICAgaWYgKGRlZmF1bHRGb3Iob3B0aW9ucy51c2VXZWJHTCwgdHJ1ZSkpIHtcbiAgICAgIGNvbnN0IGdsID0gY3JlYXRlM0RDb250ZXh0KHRoaXMuY2FudmFzLCB7IHByZW11bHRpcGxpZWRBbHBoYTogZmFsc2UgfSk7XG4gICAgICBpZiAoZ2wgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5nbCA9IGdsO1xuICAgICAgICB0aGlzLnByb2dyYW0gPSBjcmVhdGVQcm9ncmFtKGdsLCB2ZXJ0ZXhTaGFkZXJTb3VyY2UsIGZyYWdtZW50U2hhZGVyU291cmNlKTtcbiAgICAgICAgZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuICAgICAgICBjb25zdCB0ZXhDb29yZExvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcImFfdGV4Q29vcmRcIik7XG4gICAgICAgIHRoaXMudGV4Q29vcmRCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMudGV4Q29vcmRCdWZmZXIpO1xuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAgICAgMCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIDEsXG4gICAgICAgICAgMCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIDEsXG4gICAgICAgICAgMCxcbiAgICAgICAgICAxLFxuICAgICAgICAgIDEsXG4gICAgICAgICAgMCxcbiAgICAgICAgICAxLFxuICAgICAgICAgIDFcbiAgICAgICAgXSksIGdsLlNUQVRJQ19EUkFXKTtcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGV4Q29vcmRMb2NhdGlvbik7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGV4Q29vcmRMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbkJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5wb3NpdGlvbkJ1ZmZlcik7XG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KFtcbiAgICAgICAgICAwLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgMSxcbiAgICAgICAgICAwLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgMSxcbiAgICAgICAgICAwLFxuICAgICAgICAgIDEsXG4gICAgICAgICAgMSxcbiAgICAgICAgICAwLFxuICAgICAgICAgIDEsXG4gICAgICAgICAgMVxuICAgICAgICBdKSwgZ2wuU1RBVElDX0RSQVcpO1xuICAgICAgICBjb25zdCBwb3NpdGlvbkxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5wcm9ncmFtLCBcImFfcG9zaXRpb25cIik7XG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uTG9jYXRpb24pO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvc2l0aW9uTG9jYXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmNvbG9yU2NhbGVJbWFnZSkge1xuICAgICAgdGhpcy5zZXRDb2xvclNjYWxlSW1hZ2Uob3B0aW9ucy5jb2xvclNjYWxlSW1hZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldENvbG9yU2NhbGUoZGVmYXVsdEZvcihvcHRpb25zLmNvbG9yU2NhbGUsIFwidmlyaWRpc1wiKSk7XG4gICAgfVxuICAgIHRoaXMuc2V0RG9tYWluKGRlZmF1bHRGb3Iob3B0aW9ucy5kb21haW4sIFswLCAxXSkpO1xuICAgIHRoaXMuZGlzcGxheVJhbmdlID0gZGVmYXVsdEZvcihvcHRpb25zLmRpc3BsYXlSYW5nZSwgWzAsIDFdKTtcbiAgICB0aGlzLmFwcGx5RGlzcGxheVJhbmdlID0gZGVmYXVsdEZvcihvcHRpb25zLmFwcGx5RGlzcGxheVJhbmdlLCBmYWxzZSk7XG4gICAgdGhpcy5zZXRDbGFtcChkZWZhdWx0Rm9yKG9wdGlvbnMuY2xhbXBMb3csIHRydWUpLCBvcHRpb25zLmNsYW1wSGlnaCk7XG4gICAgdGhpcy5zZXROb0RhdGFWYWx1ZShvcHRpb25zLm5vRGF0YVZhbHVlKTtcbiAgICBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgICBjb25zdCBsID0gb3B0aW9ucy5kYXRhLmxlbmd0aDtcbiAgICAgIHRoaXMuc2V0RGF0YShcbiAgICAgICAgb3B0aW9ucy5kYXRhLFxuICAgICAgICBkZWZhdWx0Rm9yKG9wdGlvbnMud2lkdGgsIG9wdGlvbnMuZGF0YVtsIC0gMl0pLFxuICAgICAgICBkZWZhdWx0Rm9yKG9wdGlvbnMuaGVpZ2h0LCBvcHRpb25zLmRhdGFbbCAtIDJdKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZGF0YXNldHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5kYXRhc2V0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBkcyA9IG9wdGlvbnMuZGF0YXNldHNbaV07XG4gICAgICAgIHRoaXMuYWRkRGF0YXNldChkcy5pZCwgZHMuZGF0YSwgZHMud2lkdGgsIGRzLmhlaWdodCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm1hdHJpeCkge1xuICAgICAgdGhpcy5tYXRyaXggPSBvcHRpb25zLm1hdHJpeDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tYXRyaXggPSBbXG4gICAgICAgIDEsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDEsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDFcbiAgICAgIF07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHJhdyBkYXRhIGZyb20gdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBkYXRhc2V0LlxuICAgKiBAcmV0dXJucyB7VHlwZWRBcnJheX0gdGhlIGRhdGEgb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBkYXRhc2V0LlxuICAgKi9cbiAgZ2V0RGF0YSgpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5jdXJyZW50RGF0YXNldDtcbiAgICBpZiAoIWRhdGFzZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGRhdGFzZXQgYXZhaWxhYmxlLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGFzZXQuZGF0YTtcbiAgfVxuICAvKipcbiAgICogUXVlcnkgdGhlIHJhdyByYXN0ZXIgZGF0YSBhdCB0aGUgc3BlY2lmaWVkIGNvb3JkaW5hdGVzLlxuICAgKiBAcGFyYW0ge051bWJlcn0geCB0aGUgeCBjb29yZGluYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5IHRoZSB5IGNvb3JkaW5hdGVcbiAgICogQHJldHVybnMge051bWJlcn0gdGhlIHZhbHVlIGF0IHRoZSBzcGVjaWZpZWQgY29vcmRpbmF0ZXNcbiAgICovXG4gIGF0UG9pbnQoeCwgeSkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmN1cnJlbnREYXRhc2V0O1xuICAgIGlmICghZGF0YXNldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZGF0YXNldCBhdmFpbGFibGUuXCIpO1xuICAgIH0gZWxzZSBpZiAoeCA+PSBkYXRhc2V0LndpZHRoIHx8IHkgPj0gZGF0YXNldC5oZWlnaHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvb3JkaW5hdGVzIGFyZSBvdXRzaWRlIG9mIGltYWdlIGJvdW5kcy5cIik7XG4gICAgfVxuICAgIHJldHVybiBkYXRhc2V0LmRhdGFbeSAqIGRhdGFzZXQud2lkdGggKyB4XTtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSByYXcgcmFzdGVyIGRhdGEgdG8gYmUgcmVuZGVyZWQuIFRoaXMgY3JlYXRlcyBhIG5ldyB1bm5hbWVkIGRhdGFzZXQuXG4gICAqIEBwYXJhbSB7VHlwZWRBcnJheX0gZGF0YSB0aGUgcmF3IHJhc3RlciBkYXRhLiBUaGlzIGNhbiBiZSBhIHR5cGVkIGFycmF5IG9mXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBhbnkgdHlwZSwgYnV0IHdpbGwgYmUgY29lcmNlZCB0byBGbG9hdDMyQXJyYXkgd2hlblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgYmVlaW5nIHJlbmRlcmVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggdGhlIHdpZHRoIG9mIHRoZSByYXN0ZXIgaW1hZ2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCB0aGUgaGVpZ2h0IG9mIHRoZSBkYXRhXG4gICAqL1xuICBzZXREYXRhKGRhdGEsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50RGF0YXNldCAmJiB0aGlzLmN1cnJlbnREYXRhc2V0LmlkID09PSBudWxsKSB7XG4gICAgICBkZXN0cm95RGF0YXNldCh0aGlzLmdsLCB0aGlzLmN1cnJlbnREYXRhc2V0KTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50RGF0YXNldCA9IGNyZWF0ZURhdGFzZXQodGhpcy5nbCwgbnVsbCwgZGF0YSwgd2lkdGgsIGhlaWdodCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBuYW1lZCBkYXRhc2V0LiBUaGUgc2VtYW50aWNzIGFyZSB0aGUgc2FtZSBhcyB3aXRoIEBzZWUgc2V0RGF0YS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIHRoZSBpZGVudGlmaWVyIGZvciB0aGUgZGF0YXNldC5cbiAgICogQHBhcmFtIHtUeXBlZEFycmF5fSBkYXRhIHRoZSByYXcgcmFzdGVyIGRhdGEuIFRoaXMgY2FuIGJlIGEgdHlwZWQgYXJyYXkgb2ZcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGFueSB0eXBlLCBidXQgd2lsbCBiZSBjb2VyY2VkIHRvIEZsb2F0MzJBcnJheSB3aGVuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBiZWVpbmcgcmVuZGVyZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCB0aGUgd2lkdGggb2YgdGhlIHJhc3RlciBpbWFnZVxuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IHRoZSBoZWlnaHQgb2YgdGhlIGRhdGFcbiAgICovXG4gIGFkZERhdGFzZXQoaWQsIGRhdGEsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAodGhpcy5kYXRhc2V0QXZhaWxhYmxlKGlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGVyZSBpcyBhbHJlYWR5IGEgZGF0YXNldCByZWdpc3RlcmVkIHdpdGggaWQgJyR7aWR9J2ApO1xuICAgIH1cbiAgICB0aGlzLmRhdGFzZXRDb2xsZWN0aW9uW2lkXSA9IGNyZWF0ZURhdGFzZXQodGhpcy5nbCwgaWQsIGRhdGEsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGlmICghdGhpcy5jdXJyZW50RGF0YXNldCkge1xuICAgICAgdGhpcy5jdXJyZW50RGF0YXNldCA9IHRoaXMuZGF0YXNldENvbGxlY3Rpb25baWRdO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBjdXJyZW50IGRhdGFzZXQgdG8gYmUgcmVuZGVyZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCB0aGUgaWRlbnRpZmllciBvZiB0aGUgZGF0YXNldCB0byBiZSByZW5kZXJlZC5cbiAgICovXG4gIHNldEN1cnJlbnREYXRhc2V0KGlkKSB7XG4gICAgaWYgKCF0aGlzLmRhdGFzZXRBdmFpbGFibGUoaWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHN1Y2ggZGF0YXNldCByZWdpc3RlcmVkOiAnJHtpZH0nYCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmN1cnJlbnREYXRhc2V0ICYmIHRoaXMuY3VycmVudERhdGFzZXQuaWQgPT09IG51bGwpIHtcbiAgICAgIGRlc3Ryb3lEYXRhc2V0KHRoaXMuZ2wsIHRoaXMuY3VycmVudERhdGFzZXQpO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnREYXRhc2V0ID0gdGhpcy5kYXRhc2V0Q29sbGVjdGlvbltpZF07XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZGF0YXNldC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIHRoZSBpZGVudGlmaWVyIG9mIHRoZSBkYXRhc2V0IHRvIGJlIHJlbW92ZWQuXG4gICAqL1xuICByZW1vdmVEYXRhc2V0KGlkKSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZGF0YXNldENvbGxlY3Rpb25baWRdO1xuICAgIGlmICghZGF0YXNldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBzdWNoIGRhdGFzZXQgcmVnaXN0ZXJlZDogJyR7aWR9J2ApO1xuICAgIH1cbiAgICBkZXN0cm95RGF0YXNldCh0aGlzLmdsLCBkYXRhc2V0KTtcbiAgICBpZiAodGhpcy5jdXJyZW50RGF0YXNldCA9PT0gZGF0YXNldCkge1xuICAgICAgdGhpcy5jdXJyZW50RGF0YXNldCA9IG51bGw7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLmRhdGFzZXRDb2xsZWN0aW9uW2lkXTtcbiAgfVxuICByZW1vdmVBbGxEYXRhc2V0KCkge1xuICAgIE9iamVjdC5rZXlzKHRoaXMuZGF0YXNldENvbGxlY3Rpb24pLmZvckVhY2goKGlkKSA9PiB0aGlzLnJlbW92ZURhdGFzZXQoaWQpKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGRhdGFzZXQgaXMgYXZhaWxhYmxlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgdGhlIGlkZW50aWZpZXIgb2YgdGhlIGRhdGFzZXQgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCBhIGRhdGFzZXQgd2l0aCB0aGF0IGlkZW50aWZpZXIgaXMgZGVmaW5lZFxuICAgKi9cbiAgZGF0YXNldEF2YWlsYWJsZShpZCkge1xuICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eSh0aGlzLmRhdGFzZXRDb2xsZWN0aW9uLCBpZCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSByZW5kZXJlZCBjb2xvciBzY2FsZSBpbWFnZS5cbiAgICogQHJldHVybnMgeyhIVE1MQ2FudmFzRWxlbWVudHxIVE1MSW1hZ2VFbGVtZW50KX0gdGhlIGNhbnZhcyBvciBpbWFnZSBlbGVtZW50XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciB0aGUgcmVuZGVyZWQgY29sb3Igc2NhbGVcbiAgICovXG4gIGdldENvbG9yU2NhbGVJbWFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xvclNjYWxlSW1hZ2U7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgY2FudmFzIHRvIGRyYXcgdG8uIFdoZW4gbm8gY2FudmFzIGlzIHN1cHBsaWVkLCBhIG5ldyBjYW52YXMgZWxlbWVudFxuICAgKiBpcyBjcmVhdGVkLlxuICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50IHwgT2Zmc2NyZWVuQ2FudmFzfSBbY2FudmFzXSB0aGUgY2FudmFzIGVsZW1lbnQgdG8gcmVuZGVyIHRvLlxuICAgKi9cbiAgc2V0Q2FudmFzKGNhbnZhcykge1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gIH1cbiAgc2V0Q29sb3JUeXBlKHR5cGUpIHtcbiAgICB0aGlzLmNvbG9yVHlwZSA9IHR5cGUgPz8gXCJjb250aW51b3VzXCI7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgbmV3IHZhbHVlIGRvbWFpbiBmb3IgdGhlIHJlbmRlcmluZy5cbiAgICogQHBhcmFtIHtudW1iZXJbXX0gZG9tYWluIHRoZSB2YWx1ZSBkb21haW4gcmFuZ2UgaW4gdGhlIGZvcm0gW2xvdywgaGlnaF1cbiAgICovXG4gIHNldERvbWFpbihkb21haW4pIHtcbiAgICBpZiAoIWRvbWFpbiB8fCBkb21haW4ubGVuZ3RoICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRvbWFpbiBzcGVjaWZpZWQuXCIpO1xuICAgIH1cbiAgICB0aGlzLmRvbWFpbiA9IGRvbWFpbjtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBkaXNwbGF5IHJhbmdlIHRoYXQgd2lsbCBiZSByZW5kZXJlZCwgdmFsdWVzIG91dHNpZGUgb2YgdGhlIHJhbmdlXG4gICAqIHdpbGwgbm90IGJlIHJlbmRlcmVkICh0cmFuc3BhcmVudClcbiAgICogQHBhcmFtIHtudW1iZXJbXX0gZGlzcGxheVJhbmdlIHJhbmdlIGFycmF5IGluIHRoZSBmb3JtIFttaW4sIG1heF1cbiAgICovXG4gIHNldERpc3BsYXlSYW5nZShkaXNwbGF5UmFuZ2UpIHtcbiAgICBpZiAoIWRpc3BsYXlSYW5nZSB8fCBkaXNwbGF5UmFuZ2UubGVuZ3RoICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZpZXcgcmFuZ2Ugc3BlY2lmaWVkLlwiKTtcbiAgICB9XG4gICAgdGhpcy5kaXNwbGF5UmFuZ2UgPSBkaXNwbGF5UmFuZ2U7XG4gICAgdGhpcy5hcHBseURpc3BsYXlSYW5nZSA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgY2FudmFzIHRoYXQgaXMgY3VycmVudGx5IHJlbmRlcmVkIHRvLlxuICAgKiBAcmV0dXJucyB7SFRNTENhbnZhc0VsZW1lbnR9IHRoZSBjYW52YXMgdGhhdCBpcyBjdXJyZW50bHkgcmVuZGVyZWQgdG8uXG4gICAqL1xuICBnZXRDYW52YXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBjb2xvciBzY2FsZS5cbiAgICogQHBhcmFtIHtDb2xvclNjYWxlTmFtZXN9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGNvbG9yc2NhbGUuIE11c3QgYmUgcmVnaXN0ZXJlZC5cbiAgICovXG4gIHNldENvbG9yU2NhbGUobmFtZSkge1xuICAgIGlmICghaGFzT3duUHJvcGVydHkoY29sb3JzY2FsZXMsIG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHN1Y2ggY29sb3Igc2NhbGUgJyR7bmFtZX0nYCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5jb2xvclNjYWxlQ2FudmFzKSB7XG4gICAgICB0aGlzLmNvbG9yU2NhbGVDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgdGhpcy5jb2xvclNjYWxlQ2FudmFzLndpZHRoID0gMjU2O1xuICAgICAgdGhpcy5jb2xvclNjYWxlQ2FudmFzLmhlaWdodCA9IDE7XG4gICAgfVxuICAgIHJlbmRlckNvbG9yU2NhbGVUb0NhbnZhcyhuYW1lLCB0aGlzLmNvbG9yU2NhbGVDYW52YXMsIHRoaXMuY29sb3JUeXBlKTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuc2V0Q29sb3JTY2FsZUltYWdlKHRoaXMuY29sb3JTY2FsZUNhbnZhcyk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgY2xhbXBpbmcgZm9yIHRoZSBsb3dlciBhbmQgdGhlIHVwcGVyIGJvcmRlciBvZiB0aGUgdmFsdWVzLiBXaGVuXG4gICAqIGNsYW1waW5nIGlzIGVuYWJsZWQgZm9yIGVpdGhlciBzaWRlLCB0aGUgdmFsdWVzIGJlbG93IG9yIGFib3ZlIHdpbGwgYmVcbiAgICogY2xhbXBlZCB0byB0aGUgbWluaW11bS9tYXhpbXVtIGNvbG9yLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNsYW1wTG93IHdoZXRoZXIgb3Igbm90IHRoZSBtaW5pbXVtIHNoYWxsIGJlIGNsYW1wZWQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2xhbXBIaWdoIHdoZXRoZXIgb3Igbm90IHRoZSBtYXhtaW11bSBzaGFsbCBiZSBjbGFtcGVkLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0cyB0byBjbGFtcE1pbi5cbiAgICovXG4gIHNldENsYW1wKGNsYW1wTG93LCBjbGFtcEhpZ2gpIHtcbiAgICB0aGlzLmNsYW1wTG93ID0gY2xhbXBMb3c7XG4gICAgdGhpcy5jbGFtcEhpZ2ggPSB0eXBlb2YgY2xhbXBIaWdoICE9PSBcInVuZGVmaW5lZFwiID8gY2xhbXBIaWdoIDogY2xhbXBMb3c7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGNvbG9yIHNjYWxlIGFzIGFuIGltYWdlIG9yIGNhbnZhcy5cbiAgICogQHBhcmFtIHsoSFRNTENhbnZhc0VsZW1lbnR8SFRNTEltYWdlRWxlbWVudCl9IGNvbG9yU2NhbGVJbWFnZSB0aGUgbmV3IGNvbG9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGUgaW1hZ2VcbiAgICovXG4gIHNldENvbG9yU2NhbGVJbWFnZShjb2xvclNjYWxlSW1hZ2UpIHtcbiAgICB0aGlzLmNvbG9yU2NhbGVJbWFnZSA9IGNvbG9yU2NhbGVJbWFnZTtcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgaWYgKGdsKSB7XG4gICAgICBpZiAodGhpcy50ZXh0dXJlU2NhbGUpIHtcbiAgICAgICAgZ2wuZGVsZXRlVGV4dHVyZSh0aGlzLnRleHR1cmVTY2FsZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnRleHR1cmVTY2FsZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZVNjYWxlKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGNvbG9yU2NhbGVJbWFnZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIG5vLWRhdGEtdmFsdWU6IGEgc3BlY2lhbCB2YWx1ZSB0aGF0IHdpbGwgYmUgcmVuZGVyZWQgdHJhbnNwYXJlbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBub0RhdGFWYWx1ZSB0aGUgbm8tZGF0YS12YWx1ZS4gVXNlIG51bGwgdG8gY2xlYXIgYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c2x5IHNldCBuby1kYXRhLXZhbHVlLlxuICAgKi9cbiAgc2V0Tm9EYXRhVmFsdWUobm9EYXRhVmFsdWUpIHtcbiAgICB0aGlzLm5vRGF0YVZhbHVlID0gbm9EYXRhVmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgbWFwIHRvIHRoZSBzcGVjaWZpZWQgY2FudmFzIHdpdGggdGhlIGdpdmVuIHNldHRpbmdzLlxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmN1cnJlbnREYXRhc2V0O1xuICAgIGNhbnZhcy53aWR0aCA9IGRhdGFzZXQud2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGRhdGFzZXQuaGVpZ2h0O1xuICAgIGxldCBpZHMgPSB0aGlzLmdldEV4cHJlc3Npb25JZHMoKTtcbiAgICBpZiAodGhpcy5nbCkge1xuICAgICAgdGhpcy5yZW5kZXJXZWJHTChkYXRhc2V0LCBpZHMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jdHgpIHtcbiAgICAgIHRoaXMucmVuZGVyMkQoZGF0YXNldCk7XG4gICAgfVxuICB9XG4gIGdldEV4cHJlc3Npb25JZHMoKSB7XG4gICAgaWYgKCF0aGlzLmV4cHJlc3Npb25Bc3QpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBpZHNTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IGdldElkcyA9IChub2RlKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIG5vZGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWRzU2V0LmFkZChub2RlLnJlcGxhY2UoL1srLV0vZywgXCJcIikpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBub2RlLmxocyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZHNTZXQuYWRkKG5vZGUubGhzLnJlcGxhY2UoL1srLV0vZywgXCJcIikpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZS5saHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZ2V0SWRzKG5vZGUubGhzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygbm9kZS5yaHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWRzU2V0LmFkZChub2RlLnJocy5yZXBsYWNlKC9bKy1dL2csIFwiXCIpKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUucmhzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGdldElkcyhub2RlLnJocyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBnZXRJZHModGhpcy5leHByZXNzaW9uQXN0KTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShpZHNTZXQpO1xuICB9XG4gIHJlbmRlcldlYkdMKGRhdGFzZXQsIGlkcykge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICBnbC52aWV3cG9ydCgwLCAwLCBkYXRhc2V0LndpZHRoLCBkYXRhc2V0LmhlaWdodCk7XG4gICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMuZ2V0T3JDcmVhdGVQcm9ncmFtKGlkcyk7XG4gICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICB0aGlzLnNldHVwVGV4dHVyZXMocHJvZ3JhbSwgaWRzLCBkYXRhc2V0KTtcbiAgICB0aGlzLnNldHVwVW5pZm9ybXMocHJvZ3JhbSk7XG4gICAgdGhpcy5zZXR1cEF0dHJpYnV0ZXMocHJvZ3JhbSk7XG4gICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIDYpO1xuICB9XG4gIGdldE9yQ3JlYXRlUHJvZ3JhbShpZHMpIHtcbiAgICBpZiAoIXRoaXMuZXhwcmVzc2lvbkFzdCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvZ3JhbTtcbiAgICB9XG4gICAgY29uc3QgZXhwcktleSA9IEpTT04uc3RyaW5naWZ5KHRoaXMuZXhwcmVzc2lvbkFzdCk7XG4gICAgaWYgKHRoaXMucHJvZ3JhbUNhY2hlW2V4cHJLZXldKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9ncmFtQ2FjaGVbZXhwcktleV07XG4gICAgfVxuICAgIGNvbnN0IHZlcnRleFNoYWRlciA9IHRoaXMuY3JlYXRlVmVydGV4U2hhZGVyKCk7XG4gICAgY29uc3QgZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmNyZWF0ZUZyYWdtZW50U2hhZGVyKGlkcyk7XG4gICAgY29uc3QgcHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW0odGhpcy5nbCwgdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcik7XG4gICAgdGhpcy5wcm9ncmFtQ2FjaGVbZXhwcktleV0gPSBwcm9ncmFtO1xuICAgIHJldHVybiBwcm9ncmFtO1xuICB9XG4gIGNyZWF0ZVZlcnRleFNoYWRlcigpIHtcbiAgICByZXR1cm4gYFxuICAgICAgYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjtcbiAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFfdGV4Q29vcmQ7XG4gICAgICB1bmlmb3JtIG1hdDMgdV9tYXRyaXg7XG4gICAgICB1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uO1xuICAgICAgdmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIHZlYzIgcG9zaXRpb24gPSAodV9tYXRyaXggKiB2ZWMzKGFfcG9zaXRpb24sIDEpKS54eTtcbiAgICAgICAgdmVjMiB6ZXJvVG9PbmUgPSBwb3NpdGlvbiAvIHVfcmVzb2x1dGlvbjtcbiAgICAgICAgdmVjMiB6ZXJvVG9Ud28gPSB6ZXJvVG9PbmUgKiAyLjA7XG4gICAgICAgIHZlYzIgY2xpcFNwYWNlID0gemVyb1RvVHdvIC0gMS4wO1xuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoY2xpcFNwYWNlICogdmVjMigxLCAtMSksIDAsIDEpO1xuICAgICAgICB2X3RleENvb3JkID0gYV90ZXhDb29yZDtcbiAgICAgIH1cbiAgICBgO1xuICB9XG4gIGNyZWF0ZUZyYWdtZW50U2hhZGVyKGlkcykge1xuICAgIGlmICghaWRzKSB7XG4gICAgICByZXR1cm4gZnJhZ21lbnRTaGFkZXJTb3VyY2U7XG4gICAgfVxuICAgIGNvbnN0IGV4cHJlc3Npb25SZWR1Y2VyID0gKG5vZGUpID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAobm9kZS5vcCA9PT0gXCIqKlwiKSB7XG4gICAgICAgICAgcmV0dXJuIGBwb3coJHtleHByZXNzaW9uUmVkdWNlcihub2RlLmxocyl9LCAke2V4cHJlc3Npb25SZWR1Y2VyKG5vZGUucmhzKX0pYDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5mbikge1xuICAgICAgICAgIHJldHVybiBgKCR7bm9kZS5mbn0oJHtleHByZXNzaW9uUmVkdWNlcihub2RlLmxocyl9KSlgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgKCR7ZXhwcmVzc2lvblJlZHVjZXIobm9kZS5saHMpfSAke25vZGUub3B9ICR7ZXhwcmVzc2lvblJlZHVjZXIobm9kZS5yaHMpfSlgO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gYCR7bm9kZX1fdmFsdWVgO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGBmbG9hdCgke25vZGV9KWA7XG4gICAgfTtcbiAgICBjb25zdCBjb21waWxlZEV4cHJlc3Npb24gPSBleHByZXNzaW9uUmVkdWNlcih0aGlzLmV4cHJlc3Npb25Bc3QpO1xuICAgIHJldHVybiBgXG4gICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZVNjYWxlO1xuICAgICAgJHtpZHMubWFwKChpZCkgPT4gYHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dHVyZV8ke2lkfTtgKS5qb2luKFwiXFxuXCIpfVxuICAgICAgdW5pZm9ybSB2ZWMyIHVfdGV4dHVyZVNpemU7XG4gICAgICB1bmlmb3JtIHZlYzIgdV9kb21haW47XG4gICAgICB1bmlmb3JtIHZlYzIgdV9kaXNwbGF5X3JhbmdlO1xuICAgICAgdW5pZm9ybSBib29sIHVfYXBwbHlfZGlzcGxheV9yYW5nZTtcbiAgICAgIHVuaWZvcm0gZmxvYXQgdV9ub0RhdGFWYWx1ZTtcbiAgICAgIHVuaWZvcm0gYm9vbCB1X2NsYW1wTG93O1xuICAgICAgdW5pZm9ybSBib29sIHVfY2xhbXBIaWdoO1xuICAgICAgdmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XG4gICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICR7aWRzLm1hcCgoaWQpID0+IGBmbG9hdCAke2lkfV92YWx1ZSA9IHRleHR1cmUyRCh1X3RleHR1cmVfJHtpZH0sIHZfdGV4Q29vcmQpWzBdO2ApLmpvaW4oXCJcXG5cIil9XG4gICAgICAgIGZsb2F0IHZhbHVlID0gJHtjb21waWxlZEV4cHJlc3Npb259O1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PSB1X25vRGF0YVZhbHVlKVxuICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMC4wLCAwLCAwLCAwLjApO1xuICAgICAgICBlbHNlIGlmICh1X2FwcGx5X2Rpc3BsYXlfcmFuZ2UgJiYgKHZhbHVlIDwgdV9kaXNwbGF5X3JhbmdlWzBdIHx8IHZhbHVlID49IHVfZGlzcGxheV9yYW5nZVsxXSkpXG4gICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjAsIDAsIDAsIDAuMCk7XG4gICAgICAgIGVsc2UgaWYgKCghdV9jbGFtcExvdyAmJiB2YWx1ZSA8IHVfZG9tYWluWzBdKSB8fCAoIXVfY2xhbXBIaWdoICYmIHZhbHVlID4gdV9kb21haW5bMV0pKVxuICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMCwgMCwgMCwgMCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGZsb2F0IG5vcm1hbGlzZWRWYWx1ZSA9ICh2YWx1ZSAtIHVfZG9tYWluWzBdKSAvICh1X2RvbWFpblsxXSAtIHVfZG9tYWluWzBdKTtcbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodV90ZXh0dXJlU2NhbGUsIHZlYzIobm9ybWFsaXNlZFZhbHVlLCAwKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBgO1xuICB9XG4gIHNldHVwVGV4dHVyZXMocHJvZ3JhbSwgaWRzLCBkYXRhc2V0KSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGlmIChpZHMpIHtcbiAgICAgIGdsLnVuaWZvcm0xaShnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X3RleHR1cmVTY2FsZVwiKSwgMCk7XG4gICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZVNjYWxlKTtcbiAgICAgIGlkcy5mb3JFYWNoKChpZCwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSBpbmRleCArIDE7XG4gICAgICAgIGNvbnN0IGRzID0gdGhpcy5kYXRhc2V0Q29sbGVjdGlvbltpZF07XG4gICAgICAgIGlmICghZHMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHN1Y2ggZGF0YXNldCByZWdpc3RlcmVkOiAnJHtpZH0nYCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2wudW5pZm9ybTFpKGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBgdV90ZXh0dXJlXyR7aWR9YCksIGxvY2F0aW9uKTtcbiAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbFtgVEVYVFVSRSR7bG9jYXRpb259YF0pO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBkcy50ZXh0dXJlRGF0YSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2wudW5pZm9ybTFpKGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfdGV4dHVyZURhdGFcIiksIDApO1xuICAgICAgZ2wudW5pZm9ybTFpKGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfdGV4dHVyZVNjYWxlXCIpLCAxKTtcbiAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgZGF0YXNldC50ZXh0dXJlRGF0YSk7XG4gICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUxKTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMudGV4dHVyZVNjYWxlKTtcbiAgICB9XG4gIH1cbiAgc2V0dXBVbmlmb3Jtcyhwcm9ncmFtKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgIGdsLnVuaWZvcm0yZihnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X3Jlc29sdXRpb25cIiksIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgZ2wudW5pZm9ybTJmdihnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X2RvbWFpblwiKSwgdGhpcy5kb21haW4pO1xuICAgIGdsLnVuaWZvcm0yZnYoZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9kaXNwbGF5X3JhbmdlXCIpLCB0aGlzLmRpc3BsYXlSYW5nZSk7XG4gICAgZ2wudW5pZm9ybTFpKGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfYXBwbHlfZGlzcGxheV9yYW5nZVwiKSwgK3RoaXMuYXBwbHlEaXNwbGF5UmFuZ2UpO1xuICAgIGdsLnVuaWZvcm0xaShnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X2NsYW1wTG93XCIpLCArdGhpcy5jbGFtcExvdyk7XG4gICAgZ2wudW5pZm9ybTFpKGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfY2xhbXBIaWdoXCIpLCArdGhpcy5jbGFtcEhpZ2gpO1xuICAgIGdsLnVuaWZvcm0xZihnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X25vRGF0YVZhbHVlXCIpLCB0aGlzLm5vRGF0YVZhbHVlKTtcbiAgICBnbC51bmlmb3JtTWF0cml4M2Z2KGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVfbWF0cml4XCIpLCBmYWxzZSwgdGhpcy5tYXRyaXgpO1xuICB9XG4gIHNldHVwQXR0cmlidXRlcyhwcm9ncmFtKSB7XG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgIGNvbnN0IHBvc2l0aW9uTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBcImFfcG9zaXRpb25cIik7XG4gICAgY29uc3QgcG9zaXRpb25CdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgcG9zaXRpb25CdWZmZXIpO1xuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uTG9jYXRpb24pO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocG9zaXRpb25Mb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICBzZXRSZWN0YW5nbGUoZ2wsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gIH1cbiAgcmVuZGVyMkQoZGF0YXNldCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IHcgPSB0aGlzLmNhbnZhcy53aWR0aDtcbiAgICBjb25zdCBoID0gdGhpcy5jYW52YXMuaGVpZ2h0O1xuICAgIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5jcmVhdGVJbWFnZURhdGEodywgaCk7XG4gICAgY29uc3QgdHJhbmdlID0gdGhpcy5kb21haW5bMV0gLSB0aGlzLmRvbWFpblswXTtcbiAgICBjb25zdCBzdGVwcyA9IHRoaXMuY29sb3JTY2FsZUNhbnZhcy53aWR0aDtcbiAgICBjb25zdCBjc0ltYWdlRGF0YSA9IHRoaXMuY29sb3JTY2FsZUNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikuZ2V0SW1hZ2VEYXRhKDAsIDAsIHN0ZXBzLCAxKS5kYXRhO1xuICAgIGxldCBhbHBoYTtcbiAgICBjb25zdCBkYXRhID0gZGF0YXNldC5kYXRhO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaDsgeSsrKSB7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHc7IHgrKykge1xuICAgICAgICBjb25zdCBpID0geSAqIHcgKyB4O1xuICAgICAgICBsZXQgYyA9IE1hdGguZmxvb3IoKGRhdGFbaV0gLSB0aGlzLmRvbWFpblswXSkgLyB0cmFuZ2UgKiAoc3RlcHMgLSAxKSk7XG4gICAgICAgIGFscGhhID0gMjU1O1xuICAgICAgICBpZiAoYyA8IDApIHtcbiAgICAgICAgICBjID0gMDtcbiAgICAgICAgICBpZiAoIXRoaXMuY2xhbXBMb3cpIHtcbiAgICAgICAgICAgIGFscGhhID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYyA+IDI1NSkge1xuICAgICAgICAgIGMgPSAyNTU7XG4gICAgICAgICAgaWYgKCF0aGlzLmNsYW1wSGlnaCkge1xuICAgICAgICAgICAgYWxwaGEgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YVtpXSA9PT0gdGhpcy5ub0RhdGFWYWx1ZSB8fCBkYXRhW2ldICE9PSBkYXRhW2ldKSB7XG4gICAgICAgICAgYWxwaGEgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYXBwbHlEaXNwbGF5UmFuZ2UgJiYgKGRhdGFbaV0gPCB0aGlzLmRpc3BsYXlSYW5nZVswXSB8fCBkYXRhW2ldID49IHRoaXMuZGlzcGxheVJhbmdlWzFdKSkge1xuICAgICAgICAgIGFscGhhID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleCA9ICh5ICogdyArIHgpICogNDtcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAwXSA9IGNzSW1hZ2VEYXRhW2MgKiA0XTtcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSA9IGNzSW1hZ2VEYXRhW2MgKiA0ICsgMV07XG4gICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl0gPSBjc0ltYWdlRGF0YVtjICogNCArIDJdO1xuICAgICAgICBpbWFnZURhdGEuZGF0YVtpbmRleCArIDNdID0gTWF0aC5taW4oYWxwaGEsIGNzSW1hZ2VEYXRhW2MgKiA0ICsgM10pO1xuICAgICAgfVxuICAgIH1cbiAgICBjdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgc3BlY2lmaWVkIGRhdGFzZXQgd2l0aCB0aGUgY3VycmVudCBzZXR0aW5ncy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIHRoZSBpZGVudGlmaWVyIG9mIHRoZSBkYXRhc2V0IHRvIHJlbmRlci5cbiAgICovXG4gIHJlbmRlckRhdGFzZXQoaWQpIHtcbiAgICB0aGlzLnNldEN1cnJlbnREYXRhc2V0KGlkKTtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXIoKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBjb2xvciBmb3IgdGhlIHNwZWNpZmllZCB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbCB0aGUgdmFsdWUgdG8gcXVlcnkgdGhlIGNvbG9yIGZvci5cbiAgICogQHJldHVybnMge0FycmF5fSB0aGUgNC10dXBsZTogcmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEgaW4gdGhlIHJhbmdlIDAtMjU1LlxuICAgKi9cbiAgZ2V0Q29sb3IodmFsKSB7XG4gICAgY29uc3Qgc3RlcHMgPSB0aGlzLmNvbG9yU2NhbGVDYW52YXMud2lkdGg7XG4gICAgY29uc3QgY3NJbWFnZURhdGEgPSB0aGlzLmNvbG9yU2NhbGVDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLmdldEltYWdlRGF0YSgwLCAwLCBzdGVwcywgMSkuZGF0YTtcbiAgICBjb25zdCB0cmFuZ2UgPSB0aGlzLmRvbWFpblsxXSAtIHRoaXMuZG9tYWluWzBdO1xuICAgIGxldCBjID0gTWF0aC5yb3VuZCgodmFsIC0gdGhpcy5kb21haW5bMF0pIC8gdHJhbmdlICogc3RlcHMpO1xuICAgIGxldCBhbHBoYSA9IDI1NTtcbiAgICBpZiAoYyA8IDApIHtcbiAgICAgIGMgPSAwO1xuICAgICAgaWYgKCF0aGlzLmNsYW1wTG93KSB7XG4gICAgICAgIGFscGhhID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGMgPiAyNTUpIHtcbiAgICAgIGMgPSAyNTU7XG4gICAgICBpZiAoIXRoaXMuY2xhbXBIaWdoKSB7XG4gICAgICAgIGFscGhhID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgIGNzSW1hZ2VEYXRhW2MgKiA0XSxcbiAgICAgIGNzSW1hZ2VEYXRhW2MgKiA0ICsgMV0sXG4gICAgICBjc0ltYWdlRGF0YVtjICogNCArIDJdLFxuICAgICAgYWxwaGFcbiAgICBdO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGEgbWF0aGVtYXRpY2FsIGV4cHJlc3Npb24gdG8gYmUgZXZhbHVhdGVkIG9uIHRoZSBwbG90LiBFeHByZXNzaW9uIGNhbiBjb250YWluIG1hdGhlbWF0aWNhbCBvcGVyYXRpb25zIHdpdGggaW50ZWdlci9mbG9hdCB2YWx1ZXMsIGRhdGFzZXQgaWRlbnRpZmllcnMgb3IgR0xTTCBzdXBwb3J0ZWQgZnVuY3Rpb25zIHdpdGggYSBzaW5nbGUgcGFyYW1ldGVyLlxuICAgKiBTdXBwb3J0ZWQgbWF0aGVtYXRpY2FsIG9wZXJhdGlvbnMgYXJlOiBhZGQgJysnLCBzdWJ0cmFjdCAnLScsIG11bHRpcGx5ICcqJywgZGl2aWRlICcvJywgcG93ZXIgJyoqJywgdW5hcnkgcGx1cyAnK2EnLCB1bmFyeSBtaW51cyAnLWEnLlxuICAgKiBVc2VmdWwgR0xTTCBmdW5jdGlvbnMgYXJlIGZvciBleGFtcGxlOiByYWRpYW5zLCBkZWdyZWVzLCBzaW4sIGFzaW4sIGNvcywgYWNvcywgdGFuLCBhdGFuLCBsb2cyLCBsb2csIHNxcnQsIGV4cDIsIGV4cCwgYWJzLCBzaWduLCBmbG9vciwgY2VpbCwgZnJhY3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIE1hdGhlbWF0aWNhbCBleHByZXNzaW9uLiBFeGFtcGxlOiAnLTIgKiBzaW4oMy4xNDE1IC0gZGF0YXNldDEpICoqIDInXG4gICAqL1xuICBzZXRFeHByZXNzaW9uKGV4cHJlc3Npb24pIHtcbiAgICBpZiAoIWV4cHJlc3Npb24gfHwgIWV4cHJlc3Npb24ubGVuZ3RoKSB7XG4gICAgICB0aGlzLmV4cHJlc3Npb25Bc3QgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV4cHJlc3Npb25Bc3QgPSBwZWckcGFyc2UoZXhwcmVzc2lvbik7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IHRoaXMuZ2wpID09IG51bGwgPyB2b2lkIDAgOiBfYS5kZWxldGVQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG4gICAgdGhpcy5yZW1vdmVBbGxEYXRhc2V0KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TWluTWF4KGRhdGEsIG5vZGF0YSkge1xuICBsZXQgbWluLCBtYXg7XG4gIGZvciAobGV0IGogPSAwOyBqIDwgZGF0YS5sZW5ndGg7IGogKz0gMSkge1xuICAgIGNvbnN0IHZhbCA9IGRhdGFbal07XG4gICAgaWYgKHZhbCA9PT0gbm9kYXRhKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKG1pbiA9PT0gdm9pZCAwICYmIG1heCA9PT0gdm9pZCAwKSB7XG4gICAgICBtaW4gPSBtYXggPSB2YWw7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHZhbCA8IG1pbikge1xuICAgICAgbWluID0gdmFsO1xuICAgIH0gZWxzZSBpZiAodmFsID4gbWF4KSB7XG4gICAgICBtYXggPSB2YWw7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgbWluLFxuICAgIG1heFxuICB9O1xufVxuZnVuY3Rpb24gZGVjaW1hbDJyZ2IobnVtYmVyKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKG51bWJlciAqIDI1NSk7XG59XG5mdW5jdGlvbiBnZXRSYW5nZShiYW5kcywgb3B0cykge1xuICBjb25zdCBiYW5kID0gYmFuZHNbb3B0cy5iYW5kXTtcbiAgaWYgKCFiYW5kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGJhbmQke29wdHMuYmFuZH1gKTtcbiAgfVxuICBjb25zdCBtaW4gPSAob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5taW4pID8/ICtiYW5kLm1pbjtcbiAgY29uc3QgbWF4ID0gKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMubWF4KSA/PyArYmFuZC5tYXg7XG4gIGNvbnN0IHJhbmdlID0gbWF4IC0gbWluO1xuICByZXR1cm4geyBtaW4sIG1heCwgcmFuZ2UgfTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQ29sb3JTY2FsZShjb2xvcnMsIG1pbk1heCkge1xuICBsZXQgc3RvcHM7XG4gIGlmICh0eXBlb2YgY29sb3JzWzBdID09PSBcInN0cmluZ1wiKSB7XG4gICAgc3RvcHMgPSBjb2xvcnMubWFwKChjb2xvciwgaW5kZXgpID0+IFtpbmRleCAvIGNvbG9ycy5sZW5ndGgsIGNvbG9yXSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgW21pbiwgbWF4XSA9IG1pbk1heDtcbiAgICBzdG9wcyA9IGNvbG9ycy5tYXAoKGl0ZW0pID0+IFsoaXRlbVswXSAtIG1pbikgLyAobWF4IC0gbWluKSwgaXRlbVsxXV0pO1xuICB9XG4gIHN0b3BzLnNvcnQoKGEsIGIpID0+IGFbMF0gLSBiWzBdKTtcbiAgbGV0IGkgPSBzdG9wcy5sZW5ndGggLSAxO1xuICB3aGlsZSAoaSA+IDEgJiYgc3RvcHNbaV1bMF0gPj0gMSAmJiBzdG9wc1tpIC0gMV1bMF0gPj0gMSkge1xuICAgIHN0b3BzLnBvcCgpO1xuICAgIGktLTtcbiAgfVxuICBpZiAoc3RvcHNbMF1bMF0gPiAwKSB7XG4gICAgc3RvcHMgPSBbWzAsIHN0b3BzWzBdWzFdXSwgLi4uc3RvcHNdO1xuICB9XG4gIGNvbnN0IGNvbG9yU2NhbGUgPSB7XG4gICAgY29sb3JzOiBzdG9wcy5tYXAoKHN0b3ApID0+IHN0b3BbMV0pLFxuICAgIHBvc2l0aW9uczogc3RvcHMubWFwKChzdG9wKSA9PiB7XG4gICAgICBsZXQgcyA9IHN0b3BbMF07XG4gICAgICBpZiAocyA8IDApXG4gICAgICAgIHJldHVybiAwO1xuICAgICAgaWYgKHMgPiAxKVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIHJldHVybiBzO1xuICAgIH0pXG4gIH07XG4gIHJldHVybiBjb2xvclNjYWxlO1xufVxuZnVuY3Rpb24gZmluZEFuZFNvcnRCYW5kTnVtYmVycyhzdHIpIHtcbiAgY29uc3QgcmVnZXggPSAvYihcXGQrKS9nO1xuICBjb25zdCBiYW5kTnVtYmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCBtYXRjaDtcbiAgd2hpbGUgKChtYXRjaCA9IHJlZ2V4LmV4ZWMoc3RyKSkgIT09IG51bGwpIHtcbiAgICBiYW5kTnVtYmVycy5hZGQocGFyc2VJbnQobWF0Y2hbMV0pIC0gMSk7XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20oYmFuZE51bWJlcnMpLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ0NvbG9yVG9SZ2JhKGNvbG9yKSB7XG4gIGNvbnN0IG5ld0NvbG9yID0gQ29sb3IuZnJvbUNzc0NvbG9yU3RyaW5nKGNvbG9yKTtcbiAgY29uc3QgeyByZWQsIGdyZWVuLCBibHVlLCBhbHBoYSB9ID0gbmV3Q29sb3I7XG4gIHJldHVybiBbcmVkLCBncmVlbiwgYmx1ZSwgYWxwaGFdLm1hcCgodmFsKSA9PiBNYXRoLnJvdW5kKHZhbCAqIDI1NSkpO1xufVxuZnVuY3Rpb24gcmV2ZXJzZUFycmF5KG9wdGlvbnMpIHtcbiAgY29uc3QgeyBhcnJheSwgd2lkdGgsIGhlaWdodCB9ID0gb3B0aW9ucztcbiAgY29uc3QgcmV2ZXJzZWRBcnJheSA9IFtdO1xuICBmb3IgKGxldCByb3cgPSBoZWlnaHQgLSAxOyByb3cgPj0gMDsgcm93LS0pIHtcbiAgICBjb25zdCBzdGFydEluZGV4ID0gcm93ICogd2lkdGg7XG4gICAgY29uc3QgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgd2lkdGg7XG4gICAgY29uc3Qgcm93QXJyYXkgPSBhcnJheS5zbGljZShzdGFydEluZGV4LCBlbmRJbmRleCk7XG4gICAgcmV2ZXJzZWRBcnJheS5wdXNoKC4uLnJvd0FycmF5KTtcbiAgfVxuICByZXR1cm4gcmV2ZXJzZWRBcnJheTtcbn1cblxuY2xhc3MgVElGRkltYWdlcnlQcm92aWRlclRpbGluZ1NjaGVtZSBleHRlbmRzIFdlYk1lcmNhdG9yVGlsaW5nU2NoZW1lIHtcbiAgbmF0aXZlUmVjdGFuZ2xlO1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgY29uc3QgeyBwcm9qZWN0LCB1bnByb2plY3QgfSA9IG9wdGlvbnM7XG4gICAgdGhpcy5uYXRpdmVSZWN0YW5nbGUgPSBuZXcgUmVjdGFuZ2xlKG9wdGlvbnMucmVjdGFuZ2xlU291dGh3ZXN0SW5NZXRlcnMueCwgb3B0aW9ucy5yZWN0YW5nbGVTb3V0aHdlc3RJbk1ldGVycy55LCBvcHRpb25zLnJlY3RhbmdsZU5vcnRoZWFzdEluTWV0ZXJzLngsIG9wdGlvbnMucmVjdGFuZ2xlTm9ydGhlYXN0SW5NZXRlcnMueSk7XG4gICAgdGhpcy5fcHJvamVjdGlvbiA9IHtcbiAgICAgIGVsbGlwc29pZDogdGhpcy5lbGxpcHNvaWQsXG4gICAgICBwcm9qZWN0KGNhcnRvZ3JhcGhpYywgcmVzdWx0KSB7XG4gICAgICAgIGNvbnN0IFt4LCB5XSA9IHByb2plY3QoW2NhcnRvZ3JhcGhpYy5sb25naXR1ZGUsIGNhcnRvZ3JhcGhpYy5sYXRpdHVkZV0ubWFwKE1hdGgkMS50b0RlZ3JlZXMpKTtcbiAgICAgICAgY29uc3QgeiA9IGNhcnRvZ3JhcGhpYy5oZWlnaHQ7XG4gICAgICAgIHJldHVybiBDYXJ0ZXNpYW4zLmZyb21FbGVtZW50cyh4LCB5LCB6LCByZXN1bHQpO1xuICAgICAgfSxcbiAgICAgIHVucHJvamVjdChjYXJ0ZXNpYW4sIHJlc3VsdCkge1xuICAgICAgICBjb25zdCBbbG9uZ2l0dWRlLCBsYXRpdHVkZV0gPSB1bnByb2plY3QoW2NhcnRlc2lhbi54LCBjYXJ0ZXNpYW4ueV0pO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBjYXJ0ZXNpYW4uejtcbiAgICAgICAgcmV0dXJuIENhcnRvZ3JhcGhpYy5mcm9tRGVncmVlcyhsb25naXR1ZGUsIGxhdGl0dWRlLCBoZWlnaHQsIHJlc3VsdCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzd01ldGVycyA9IG5ldyBDYXJ0ZXNpYW4zKCk7XG4gICAgb3B0aW9ucy5yZWN0YW5nbGVTb3V0aHdlc3RJbk1ldGVycy5jbG9uZShzd01ldGVycyk7XG4gICAgY29uc3QgbmVNZXRlcnMgPSBuZXcgQ2FydGVzaWFuMygpO1xuICAgIG9wdGlvbnMucmVjdGFuZ2xlTm9ydGhlYXN0SW5NZXRlcnMuY2xvbmUobmVNZXRlcnMpO1xuICAgIGNvbnN0IHNlTWV0ZXJzID0gbmV3IENhcnRlc2lhbjMobmVNZXRlcnMueCwgc3dNZXRlcnMueSk7XG4gICAgY29uc3QgbndNZXRlcnMgPSBuZXcgQ2FydGVzaWFuMyhzd01ldGVycy54LCBuZU1ldGVycy55KTtcbiAgICBjb25zdCBzb3V0aHdlc3QgPSB0aGlzLnByb2plY3Rpb24udW5wcm9qZWN0KHN3TWV0ZXJzKTtcbiAgICBjb25zdCBzb3V0aGVhc3QgPSB0aGlzLnByb2plY3Rpb24udW5wcm9qZWN0KHNlTWV0ZXJzKTtcbiAgICBjb25zdCBub3J0aHdlc3QgPSB0aGlzLnByb2plY3Rpb24udW5wcm9qZWN0KG53TWV0ZXJzKTtcbiAgICBjb25zdCBub3J0aGVhc3QgPSB0aGlzLnByb2plY3Rpb24udW5wcm9qZWN0KG5lTWV0ZXJzKTtcbiAgICB0aGlzLl9yZWN0YW5nbGUgPSBSZWN0YW5nbGUuZnJvbUNhcnRvZ3JhcGhpY0FycmF5KFtzb3V0aHdlc3QsIHNvdXRoZWFzdCwgbm9ydGh3ZXN0LCBub3J0aGVhc3RdKTtcbiAgfVxuICB0aWxlWFlUb05hdGl2ZVJlY3RhbmdsZTIoeCwgeSwgbGV2ZWwpIHtcbiAgICBjb25zdCByZWN0ID0gdGhpcy50aWxlWFlUb1JlY3RhbmdsZSh4LCB5LCBsZXZlbCk7XG4gICAgY29uc3QgcHJvamVjdGlvbiA9IHRoaXMucHJvamVjdGlvbjtcbiAgICBjb25zdCB3cyA9IHByb2plY3Rpb24ucHJvamVjdChuZXcgQ2FydG9ncmFwaGljKHJlY3Qud2VzdCwgcmVjdC5zb3V0aCkpO1xuICAgIGNvbnN0IHduID0gcHJvamVjdGlvbi5wcm9qZWN0KG5ldyBDYXJ0b2dyYXBoaWMocmVjdC53ZXN0LCByZWN0Lm5vcnRoKSk7XG4gICAgY29uc3QgZW4gPSBwcm9qZWN0aW9uLnByb2plY3QobmV3IENhcnRvZ3JhcGhpYyhyZWN0LmVhc3QsIHJlY3Qubm9ydGgpKTtcbiAgICBjb25zdCBlcyA9IHByb2plY3Rpb24ucHJvamVjdChuZXcgQ2FydG9ncmFwaGljKHJlY3QuZWFzdCwgcmVjdC5zb3V0aCkpO1xuICAgIGNvbnN0IHBvc2l0aW9ucyA9IFt3cywgd24sIGVuLCBlc107XG4gICAgY29uc3QgeHggPSBwb3NpdGlvbnMubWFwKChwb3MpID0+IHBvcy54KTtcbiAgICBjb25zdCB5eSA9IHBvc2l0aW9ucy5tYXAoKHBvcykgPT4gcG9zLnkpO1xuICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKFxuICAgICAgTWF0aC5taW4oLi4ueHgpLFxuICAgICAgTWF0aC5taW4oLi4ueXkpLFxuICAgICAgTWF0aC5tYXgoLi4ueHgpLFxuICAgICAgTWF0aC5tYXgoLi4ueXkpXG4gICAgKTtcbiAgfVxuICB0aWxlWFlUb1JlY3RhbmdsZSh4LCB5LCBsZXZlbCkge1xuICAgIGNvbnN0IHJlY3QgPSB0aGlzLnRpbGVYWVRvTmF0aXZlUmVjdGFuZ2xlKHgsIHksIGxldmVsKTtcbiAgICBjb25zdCBwcm9qZWN0aW9uID0gdGhpcy5wcm9qZWN0aW9uO1xuICAgIGNvbnN0IHdzID0gcHJvamVjdGlvbi51bnByb2plY3QobmV3IENhcnRlc2lhbjMocmVjdC53ZXN0LCByZWN0LnNvdXRoKSk7XG4gICAgY29uc3Qgd24gPSBwcm9qZWN0aW9uLnVucHJvamVjdChuZXcgQ2FydGVzaWFuMyhyZWN0Lndlc3QsIHJlY3Qubm9ydGgpKTtcbiAgICBjb25zdCBlbiA9IHByb2plY3Rpb24udW5wcm9qZWN0KG5ldyBDYXJ0ZXNpYW4zKHJlY3QuZWFzdCwgcmVjdC5ub3J0aCkpO1xuICAgIGNvbnN0IGVzID0gcHJvamVjdGlvbi51bnByb2plY3QobmV3IENhcnRlc2lhbjMocmVjdC5lYXN0LCByZWN0LnNvdXRoKSk7XG4gICAgY29uc3QgbmV3UmVjdCA9IFJlY3RhbmdsZS5mcm9tQ2FydG9ncmFwaGljQXJyYXkoW3dzLCB3biwgZW4sIGVzXSk7XG4gICAgaWYgKG5ld1JlY3QuZWFzdCA8IG5ld1JlY3Qud2VzdCkge1xuICAgICAgbmV3UmVjdC5lYXN0ICs9IE1hdGgkMS5UV09fUEk7XG4gICAgfVxuICAgIHJldHVybiBuZXdSZWN0O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc2FtcGxlTmVhcmVzdChkYXRhLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodCwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCwgd2luZG93LCBidWZmZXIgPSAwIH0gPSBvcHRpb25zO1xuICBjb25zdCBbeDAsIHkwLCB4MSwgeTFdID0gd2luZG93O1xuICBjb25zdCBlZmZlY3RpdmVTb3VyY2VXaWR0aCA9IHNvdXJjZVdpZHRoIC0gMiAqIGJ1ZmZlcjtcbiAgY29uc3QgZWZmZWN0aXZlU291cmNlSGVpZ2h0ID0gc291cmNlSGVpZ2h0IC0gMiAqIGJ1ZmZlcjtcbiAgY29uc3QgcmVzYW1wbGVkRGF0YSA9IGNvcHlOZXdTaXplKGRhdGEsIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQpO1xuICBmb3IgKGxldCB5ID0gMDsgeSA8IHRhcmdldEhlaWdodDsgeSsrKSB7XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCB0YXJnZXRXaWR0aDsgeCsrKSB7XG4gICAgICBjb25zdCBjb2wgPSBidWZmZXIgKyAoZWZmZWN0aXZlU291cmNlV2lkdGggKiAoeDAgKyB4IC8gdGFyZ2V0V2lkdGggKiAoeDEgLSB4MCkpID4+PiAwKTtcbiAgICAgIGNvbnN0IHJvdyA9IGJ1ZmZlciArIChlZmZlY3RpdmVTb3VyY2VIZWlnaHQgKiAoeTAgKyB5IC8gdGFyZ2V0SGVpZ2h0ICogKHkxIC0geTApKSA+Pj4gMCk7XG4gICAgICByZXNhbXBsZWREYXRhW3kgKiB0YXJnZXRXaWR0aCArIHhdID0gZGF0YVtyb3cgKiBzb3VyY2VXaWR0aCArIGNvbF07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNhbXBsZWREYXRhO1xufVxuZnVuY3Rpb24gcmVzYW1wbGVEYXRhKGRhdGEsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyBtZXRob2QgPSBcIm5lYXJlc3RcIiB9ID0gb3B0aW9ucztcbiAgc3dpdGNoIChtZXRob2QpIHtcbiAgICBjYXNlIFwibmVhcmVzdFwiOlxuICAgICAgcmV0dXJuIHJlc2FtcGxlTmVhcmVzdChkYXRhLCBvcHRpb25zKTtcbiAgICBjYXNlIFwiYmlsaW5lYXJcIjpcbiAgICAgIHJldHVybiByZXNhbXBsZUJpbGluZWFyKGRhdGEsIG9wdGlvbnMpO1xuICB9XG59XG5mdW5jdGlvbiBjb3B5TmV3U2l6ZShhcnJheSwgd2lkdGgsIGhlaWdodCwgc2FtcGxlc1BlclBpeGVsID0gMSkge1xuICByZXR1cm4gbmV3IChPYmplY3QuZ2V0UHJvdG90eXBlT2YoYXJyYXkpKS5jb25zdHJ1Y3Rvcih3aWR0aCAqIGhlaWdodCAqIHNhbXBsZXNQZXJQaXhlbCk7XG59XG5mdW5jdGlvbiBsZXJwKHYwLCB2MSwgdCkge1xuICByZXR1cm4gKDEgLSB0KSAqIHYwICsgdCAqIHYxO1xufVxuZnVuY3Rpb24gcmVzYW1wbGVCaWxpbmVhcihkYXRhLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodCwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCwgd2luZG93LCBidWZmZXIgPSAwLCBub2RhdGEgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IFt4MCwgeTAsIHgxLCB5MV0gPSB3aW5kb3c7XG4gIGNvbnN0IHdpbmRvd1dpZHRoID0geDEgLSB4MDtcbiAgY29uc3Qgd2luZG93SGVpZ2h0ID0geTEgLSB5MDtcbiAgY29uc3QgbmV3QXJyYXkgPSBjb3B5TmV3U2l6ZShkYXRhLCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0KTtcbiAgY29uc3QgZWZmZWN0aXZlU291cmNlV2lkdGggPSBzb3VyY2VXaWR0aCAtIDIgKiBidWZmZXI7XG4gIGNvbnN0IGVmZmVjdGl2ZVNvdXJjZUhlaWdodCA9IHNvdXJjZUhlaWdodCAtIDIgKiBidWZmZXI7XG4gIGNvbnN0IGludlRhcmdldFdpZHRoID0gMSAvIHRhcmdldFdpZHRoO1xuICBjb25zdCBpbnZUYXJnZXRIZWlnaHQgPSAxIC8gdGFyZ2V0SGVpZ2h0O1xuICBjb25zdCBpc05vZGF0YSA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmIChub2RhdGEgPT09IHZvaWQgMClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAobm9kYXRhID09PSAwKVxuICAgICAgcmV0dXJuIHZhbHVlID09PSAwO1xuICAgIHJldHVybiBNYXRoLmFicygodmFsdWUgLSBub2RhdGEpIC8gbm9kYXRhKSA8IDFlLTY7XG4gIH07XG4gIGZvciAobGV0IHkgPSAwOyB5IDwgdGFyZ2V0SGVpZ2h0OyB5KyspIHtcbiAgICBjb25zdCB5UmF0aW8gPSB5ICogaW52VGFyZ2V0SGVpZ2h0O1xuICAgIGNvbnN0IHlNYXBwZWQgPSB5MCArIHlSYXRpbyAqIHdpbmRvd0hlaWdodDtcbiAgICBjb25zdCByYXdZID0gZWZmZWN0aXZlU291cmNlSGVpZ2h0ICogeU1hcHBlZCArIGJ1ZmZlcjtcbiAgICBjb25zdCB5bCA9IE1hdGguZmxvb3IocmF3WSk7XG4gICAgY29uc3QgeWggPSBNYXRoLm1pbihNYXRoLmNlaWwocmF3WSksIHNvdXJjZUhlaWdodCAtIGJ1ZmZlciAtIDEpO1xuICAgIGNvbnN0IHR5ID0gcmF3WSAtIHlsO1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGFyZ2V0V2lkdGg7IHgrKykge1xuICAgICAgY29uc3QgeFJhdGlvID0geCAqIGludlRhcmdldFdpZHRoO1xuICAgICAgY29uc3QgeE1hcHBlZCA9IHgwICsgeFJhdGlvICogd2luZG93V2lkdGg7XG4gICAgICBjb25zdCByYXdYID0gZWZmZWN0aXZlU291cmNlV2lkdGggKiB4TWFwcGVkICsgYnVmZmVyO1xuICAgICAgY29uc3QgeGwgPSBNYXRoLmZsb29yKHJhd1gpO1xuICAgICAgY29uc3QgeGggPSBNYXRoLm1pbihNYXRoLmNlaWwocmF3WCksIHNvdXJjZVdpZHRoIC0gYnVmZmVyIC0gMSk7XG4gICAgICBjb25zdCB0eEZyYWN0aW9uID0gcmF3WCAtIHhsO1xuICAgICAgY29uc3QgY2VudGVyID0gZGF0YVt5bCAqIHNvdXJjZVdpZHRoICsgeGxdO1xuICAgICAgY29uc3QgbmVpZ2hib3JzID0gW1xuICAgICAgICBkYXRhW3lsICogc291cmNlV2lkdGggKyB4bF0sXG4gICAgICAgIGRhdGFbeWwgKiBzb3VyY2VXaWR0aCArIHhoXSxcbiAgICAgICAgZGF0YVt5aCAqIHNvdXJjZVdpZHRoICsgeGxdLFxuICAgICAgICBkYXRhW3loICogc291cmNlV2lkdGggKyB4aF1cbiAgICAgIF07XG4gICAgICBuZWlnaGJvcnMuZm9yRWFjaCgobmVpZ2hib3IsIGluZGV4KSA9PiB7XG4gICAgICAgIGlmIChpc05vZGF0YShuZWlnaGJvcikpIHtcbiAgICAgICAgICBuZWlnaGJvcnNbaW5kZXhdID0gY2VudGVyO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChpc05vZGF0YShjZW50ZXIpKSB7XG4gICAgICAgIG5ld0FycmF5W3kgKiB0YXJnZXRXaWR0aCArIHhdID0gbm9kYXRhO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFtsbCwgaGwsIGxoLCBoaF0gPSBuZWlnaGJvcnM7XG4gICAgICBjb25zdCB2MCA9IGxlcnAobGwsIGhsLCB0eEZyYWN0aW9uKTtcbiAgICAgIGNvbnN0IHYxID0gbGVycChsaCwgaGgsIHR4RnJhY3Rpb24pO1xuICAgICAgY29uc3QgdmFsdWUgPSBsZXJwKHYwLCB2MSwgdHkpO1xuICAgICAgbmV3QXJyYXlbeSAqIHRhcmdldFdpZHRoICsgeF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld0FycmF5O1xufVxuXG5mdW5jdGlvbiBpblJhbmdlKHZhbCwgcmFuZ2UpIHtcbiAgaWYgKHZhbCA8IHJhbmdlWzBdICYmIHZhbCA8IHJhbmdlWzFdIHx8IHZhbCA+IHJhbmdlWzBdICYmIHZhbCA+IHJhbmdlWzFdKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiByZXByb2plY3Rpb24ob3B0aW9ucykge1xuICBjb25zdCB7IGRhdGEsIHNvdXJjZUJCb3gsIHRhcmdldEJCb3gsIHByb2plY3QsIHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQsIG5vZGF0YSB9ID0gb3B0aW9ucztcbiAgY29uc3QgeyB0YXJnZXRXaWR0aCA9IHNvdXJjZVdpZHRoLCB0YXJnZXRIZWlnaHQgPSBzb3VyY2VIZWlnaHQgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSA9IHNvdXJjZUJCb3g7XG4gIGNvbnN0IFttaW5Mb24sIG1pbkxhdCwgbWF4TG9uLCBtYXhMYXRdID0gdGFyZ2V0QkJveDtcbiAgY29uc3Qgc3RlcFggPSBNYXRoLmFicyhtYXhYIC0gbWluWCkgLyBzb3VyY2VXaWR0aDtcbiAgY29uc3Qgc3RlcFkgPSBNYXRoLmFicyhtYXhZIC0gbWluWSkgLyBzb3VyY2VIZWlnaHQ7XG4gIGNvbnN0IHN0ZXBMb24gPSBNYXRoLmFicyhtYXhMb24gLSBtaW5Mb24pIC8gdGFyZ2V0V2lkdGg7XG4gIGNvbnN0IHN0ZXBMYXQgPSBNYXRoLmFicyhtYXhMYXQgLSBtaW5MYXQpIC8gdGFyZ2V0SGVpZ2h0O1xuICBjb25zdCByZXN1bHQgPSBjb3B5TmV3U2l6ZShkYXRhLCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0KS5maWxsKG5vZGF0YSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0SGVpZ2h0OyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRhcmdldFdpZHRoOyBqKyspIHtcbiAgICAgIGNvbnN0IGxvbiA9IG1pbkxvbiArIHN0ZXBMb24gKiAoaiArIDAuNSk7XG4gICAgICBjb25zdCBsYXQgPSBtYXhMYXQgLSBzdGVwTGF0ICogKGkgKyAwLjUpO1xuICAgICAgY29uc3QgW3gsIHldID0gcHJvamVjdChbbG9uLCBsYXRdKTtcbiAgICAgIGlmICghaW5SYW5nZSh4LCBbbWluWCwgbWF4WF0pIHx8ICFpblJhbmdlKHksIFttaW5YLCBtYXhZXSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBpbmRleFggPSB+figoeCAtIG1pblgpIC8gc3RlcFgpO1xuICAgICAgY29uc3QgaW5kZXhZID0gfn4oKG1heFkgLSB5KSAvIHN0ZXBZKTtcbiAgICAgIGNvbnN0IHNvdXJjZVZhbCA9IGRhdGFbaW5kZXhZICogc291cmNlV2lkdGggKyBpbmRleFhdO1xuICAgICAgY29uc3QgaW5kZXggPSBpICogdGFyZ2V0V2lkdGggKyBqO1xuICAgICAgcmVzdWx0W2luZGV4XSA9IHNvdXJjZVZhbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVJbWFnZShvcHRzKSB7XG4gIGNvbnN0IHsgZGF0YSwgd2lkdGgsIGhlaWdodCwgcmVuZGVyT3B0aW9ucywgYmFuZHMsIG5vRGF0YSwgY29sb3JNYXBwaW5nIH0gPSBvcHRzO1xuICBjb25zdCBpbWFnZURhdGEgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgZnVuY3Rpb24gaWZOb0RhdGFGdW5jKC4uLnZhbHMpIHtcbiAgICBpZiAodmFscy5zb21lKCh2YWwpID0+IGlzTmFOKHZhbCkgfHwgdmFsID09PSBub0RhdGEpKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHsgciwgZywgYiB9ID0gcmVuZGVyT3B0aW9ucyA/PyB7fTtcbiAgY29uc3QgcmFuZ2VzID0gW3IsIGcsIGJdLm1hcCgoaXRlbSkgPT4gZ2V0UmFuZ2UoYmFuZHMsIGl0ZW0pKTtcbiAgY29uc3QgcmVkRGF0YSA9IGRhdGFbMF07XG4gIGNvbnN0IGdyZWVuRGF0YSA9IGRhdGFbMV07XG4gIGNvbnN0IGJsdWVEYXRhID0gZGF0YVsyXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhWzBdLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IHJlZCA9IGRlY2ltYWwycmdiKChyZWREYXRhW2ldIC0gcmFuZ2VzWzBdLm1pbikgLyByYW5nZXNbMF0ucmFuZ2UpO1xuICAgIGxldCBncmVlbiA9IGRlY2ltYWwycmdiKChncmVlbkRhdGFbaV0gLSByYW5nZXNbMV0ubWluKSAvIHJhbmdlc1sxXS5yYW5nZSk7XG4gICAgbGV0IGJsdWUgPSBkZWNpbWFsMnJnYigoYmx1ZURhdGFbaV0gLSByYW5nZXNbMl0ubWluKSAvIHJhbmdlc1syXS5yYW5nZSk7XG4gICAgbGV0IGFscGhhID0gaWZOb0RhdGFGdW5jKHJlZERhdGFbaV0sIGdyZWVuRGF0YVtpXSwgYmx1ZURhdGFbaV0pID8gMCA6IDI1NTtcbiAgICBjb2xvck1hcHBpbmcubWFwKChbY29sb3JGcm9tLCBjb2xvclRvXSkgPT4ge1xuICAgICAgaWYgKHJlZCA9PT0gY29sb3JGcm9tWzBdICYmIGdyZWVuID09PSBjb2xvckZyb21bMV0gJiYgYmx1ZSA9PT0gY29sb3JGcm9tWzJdKSB7XG4gICAgICAgIHJlZCA9IGNvbG9yVG9bMF07XG4gICAgICAgIGdyZWVuID0gY29sb3JUb1sxXTtcbiAgICAgICAgYmx1ZSA9IGNvbG9yVG9bMl07XG4gICAgICAgIGFscGhhID0gY29sb3JUb1szXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpbWFnZURhdGFbaSAqIDRdID0gcmVkO1xuICAgIGltYWdlRGF0YVtpICogNCArIDFdID0gZ3JlZW47XG4gICAgaW1hZ2VEYXRhW2kgKiA0ICsgMl0gPSBibHVlO1xuICAgIGltYWdlRGF0YVtpICogNCArIDNdID0gYWxwaGE7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gbmV3IEltYWdlRGF0YShpbWFnZURhdGEsIHdpZHRoLCBoZWlnaHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDYW5hdmFzKHdpZHRoLCBoZWlnaHQpIHtcbiAgaWYgKFwiT2Zmc2NyZWVuQ2FudmFzXCIgaW4gd2luZG93KSB7XG4gICAgcmV0dXJuIG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY2FudiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2Fudi53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnYuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHJldHVybiBjYW52O1xuICB9XG59XG5cbnZhciBXb3JrZXJDbGFzcyA9IG51bGw7XG5cbnRyeSB7XG4gICAgdmFyIFdvcmtlclRocmVhZHMgPVxuICAgICAgICB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbW9kdWxlLnJlcXVpcmUgPT09ICdmdW5jdGlvbicgJiYgbW9kdWxlLnJlcXVpcmUoJ3dvcmtlcl90aHJlYWRzJykgfHxcbiAgICAgICAgdHlwZW9mIF9fbm9uX3dlYnBhY2tfcmVxdWlyZV9fID09PSAnZnVuY3Rpb24nICYmIF9fbm9uX3dlYnBhY2tfcmVxdWlyZV9fKCd3b3JrZXJfdGhyZWFkcycpIHx8XG4gICAgICAgIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nICYmIHJlcXVpcmUoJ3dvcmtlcl90aHJlYWRzJyk7XG4gICAgV29ya2VyQ2xhc3MgPSBXb3JrZXJUaHJlYWRzLldvcmtlcjtcbn0gY2F0Y2goZSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG5mdW5jdGlvbiBkZWNvZGVCYXNlNjQkMShiYXNlNjQsIGVuYWJsZVVuaWNvZGUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYmFzZTY0LCAnYmFzZTY0JykudG9TdHJpbmcoZW5hYmxlVW5pY29kZSA/ICd1dGYxNicgOiAndXRmOCcpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVCYXNlNjRXb3JrZXJGYWN0b3J5JDIoYmFzZTY0LCBzb3VyY2VtYXBBcmcsIGVuYWJsZVVuaWNvZGVBcmcpIHtcbiAgICB2YXIgc291cmNlbWFwID0gc291cmNlbWFwQXJnID09PSB1bmRlZmluZWQgPyBudWxsIDogc291cmNlbWFwQXJnO1xuICAgIHZhciBlbmFibGVVbmljb2RlID0gZW5hYmxlVW5pY29kZUFyZyA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBlbmFibGVVbmljb2RlQXJnO1xuICAgIHZhciBzb3VyY2UgPSBkZWNvZGVCYXNlNjQkMShiYXNlNjQsIGVuYWJsZVVuaWNvZGUpO1xuICAgIHZhciBzdGFydCA9IHNvdXJjZS5pbmRleE9mKCdcXG4nLCAxMCkgKyAxO1xuICAgIHZhciBib2R5ID0gc291cmNlLnN1YnN0cmluZyhzdGFydCkgKyAoc291cmNlbWFwID8gJ1xcL1xcLyMgc291cmNlTWFwcGluZ1VSTD0nICsgc291cmNlbWFwIDogJycpO1xuICAgIHJldHVybiBmdW5jdGlvbiBXb3JrZXJGYWN0b3J5KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXb3JrZXJDbGFzcyhib2R5LCBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7IGV2YWw6IHRydWUgfSkpO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGRlY29kZUJhc2U2NChiYXNlNjQsIGVuYWJsZVVuaWNvZGUpIHtcbiAgICB2YXIgYmluYXJ5U3RyaW5nID0gYXRvYihiYXNlNjQpO1xuICAgIGlmIChlbmFibGVVbmljb2RlKSB7XG4gICAgICAgIHZhciBiaW5hcnlWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5U3RyaW5nLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gYmluYXJ5U3RyaW5nLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgYmluYXJ5Vmlld1tpXSA9IGJpbmFyeVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50MTZBcnJheShiaW5hcnlWaWV3LmJ1ZmZlcikpO1xuICAgIH1cbiAgICByZXR1cm4gYmluYXJ5U3RyaW5nO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVUkwoYmFzZTY0LCBzb3VyY2VtYXBBcmcsIGVuYWJsZVVuaWNvZGVBcmcpIHtcbiAgICB2YXIgc291cmNlbWFwID0gc291cmNlbWFwQXJnID09PSB1bmRlZmluZWQgPyBudWxsIDogc291cmNlbWFwQXJnO1xuICAgIHZhciBlbmFibGVVbmljb2RlID0gZW5hYmxlVW5pY29kZUFyZyA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBlbmFibGVVbmljb2RlQXJnO1xuICAgIHZhciBzb3VyY2UgPSBkZWNvZGVCYXNlNjQoYmFzZTY0LCBlbmFibGVVbmljb2RlKTtcbiAgICB2YXIgc3RhcnQgPSBzb3VyY2UuaW5kZXhPZignXFxuJywgMTApICsgMTtcbiAgICB2YXIgYm9keSA9IHNvdXJjZS5zdWJzdHJpbmcoc3RhcnQpICsgKHNvdXJjZW1hcCA/ICdcXC9cXC8jIHNvdXJjZU1hcHBpbmdVUkw9JyArIHNvdXJjZW1hcCA6ICcnKTtcbiAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtib2R5XSwgeyB0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcgfSk7XG4gICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJhc2U2NFdvcmtlckZhY3RvcnkkMShiYXNlNjQsIHNvdXJjZW1hcEFyZywgZW5hYmxlVW5pY29kZUFyZykge1xuICAgIHZhciB1cmw7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIFdvcmtlckZhY3Rvcnkob3B0aW9ucykge1xuICAgICAgICB1cmwgPSB1cmwgfHwgY3JlYXRlVVJMKGJhc2U2NCwgc291cmNlbWFwQXJnLCBlbmFibGVVbmljb2RlQXJnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBXb3JrZXIodXJsLCBvcHRpb25zKTtcbiAgICB9O1xufVxuXG52YXIga0lzTm9kZUpTID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyA/IHByb2Nlc3MgOiAwKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nO1xuXG5mdW5jdGlvbiBpc05vZGVKUygpIHtcbiAgICByZXR1cm4ga0lzTm9kZUpTO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVCYXNlNjRXb3JrZXJGYWN0b3J5KGJhc2U2NCwgc291cmNlbWFwQXJnLCBlbmFibGVVbmljb2RlQXJnKSB7XG4gICAgaWYgKGlzTm9kZUpTKCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJhc2U2NFdvcmtlckZhY3RvcnkkMihiYXNlNjQsIHNvdXJjZW1hcEFyZywgZW5hYmxlVW5pY29kZUFyZyk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVCYXNlNjRXb3JrZXJGYWN0b3J5JDEoYmFzZTY0LCBzb3VyY2VtYXBBcmcsIGVuYWJsZVVuaWNvZGVBcmcpO1xufVxuXG52YXIgV29ya2VyRmFjdG9yeSA9IGNyZWF0ZUJhc2U2NFdvcmtlckZhY3RvcnkoJ0x5b2djbTlzYkhWd0xYQnNkV2RwYmkxM1pXSXRkMjl5YTJWeUxXeHZZV1JsY2lBcUx3b29ablZ1WTNScGIyNGdLQ2tnZXdvZ0lDZDFjMlVnYzNSeWFXTjBKenNLQ2lBZ1puVnVZM1JwYjI0Z2NtVnpZVzF3YkdWT1pXRnlaWE4wS0dSaGRHRXNJRzl3ZEdsdmJuTXBJSHNLSUNBZ0lHTnZibk4wSUhzZ2MyOTFjbU5sVjJsa2RHZ3NJSE52ZFhKalpVaGxhV2RvZEN3Z2RHRnlaMlYwVjJsa2RHZ3NJSFJoY21kbGRFaGxhV2RvZEN3Z2QybHVaRzkzTENCaWRXWm1aWElnUFNBd0lIMGdQU0J2Y0hScGIyNXpPd29nSUNBZ1kyOXVjM1FnVzNnd0xDQjVNQ3dnZURFc0lIa3hYU0E5SUhkcGJtUnZkenNLSUNBZ0lHTnZibk4wSUdWbVptVmpkR2wyWlZOdmRYSmpaVmRwWkhSb0lEMGdjMjkxY21ObFYybGtkR2dnTFNBeUlDb2dZblZtWm1WeU93b2dJQ0FnWTI5dWMzUWdaV1ptWldOMGFYWmxVMjkxY21ObFNHVnBaMmgwSUQwZ2MyOTFjbU5sU0dWcFoyaDBJQzBnTWlBcUlHSjFabVpsY2pzS0lDQWdJR052Ym5OMElISmxjMkZ0Y0d4bFpFUmhkR0VnUFNCamIzQjVUbVYzVTJsNlpTaGtZWFJoTENCMFlYSm5aWFJYYVdSMGFDd2dkR0Z5WjJWMFNHVnBaMmgwS1RzS0lDQWdJR1p2Y2lBb2JHVjBJSGtnUFNBd095QjVJRHdnZEdGeVoyVjBTR1ZwWjJoME95QjVLeXNwSUhzS0lDQWdJQ0FnWm05eUlDaHNaWFFnZUNBOUlEQTdJSGdnUENCMFlYSm5aWFJYYVdSMGFEc2dlQ3NyS1NCN0NpQWdJQ0FnSUNBZ1kyOXVjM1FnWTI5c0lEMGdZblZtWm1WeUlDc2dLR1ZtWm1WamRHbDJaVk52ZFhKalpWZHBaSFJvSUNvZ0tIZ3dJQ3NnZUNBdklIUmhjbWRsZEZkcFpIUm9JQ29nS0hneElDMGdlREFwS1NBK1BqNGdNQ2s3Q2lBZ0lDQWdJQ0FnWTI5dWMzUWdjbTkzSUQwZ1luVm1abVZ5SUNzZ0tHVm1abVZqZEdsMlpWTnZkWEpqWlVobGFXZG9kQ0FxSUNoNU1DQXJJSGtnTHlCMFlYSm5aWFJJWldsbmFIUWdLaUFvZVRFZ0xTQjVNQ2twSUQ0K1BpQXdLVHNLSUNBZ0lDQWdJQ0J5WlhOaGJYQnNaV1JFWVhSaFcza2dLaUIwWVhKblpYUlhhV1IwYUNBcklIaGRJRDBnWkdGMFlWdHliM2NnS2lCemIzVnlZMlZYYVdSMGFDQXJJR052YkYwN0NpQWdJQ0FnSUgwS0lDQWdJSDBLSUNBZ0lISmxkSFZ5YmlCeVpYTmhiWEJzWldSRVlYUmhPd29nSUgwS0lDQm1kVzVqZEdsdmJpQnlaWE5oYlhCc1pVUmhkR0VvWkdGMFlTd2diM0IwYVc5dWN5a2dld29nSUNBZ1kyOXVjM1FnZXlCdFpYUm9iMlFnUFNBaWJtVmhjbVZ6ZENJZ2ZTQTlJRzl3ZEdsdmJuTTdDaUFnSUNCemQybDBZMmdnS0cxbGRHaHZaQ2tnZXdvZ0lDQWdJQ0JqWVhObElDSnVaV0Z5WlhOMElqb0tJQ0FnSUNBZ0lDQnlaWFIxY200Z2NtVnpZVzF3YkdWT1pXRnlaWE4wS0dSaGRHRXNJRzl3ZEdsdmJuTXBPd29nSUNBZ0lDQmpZWE5sSUNKaWFXeHBibVZoY2lJNkNpQWdJQ0FnSUNBZ2NtVjBkWEp1SUhKbGMyRnRjR3hsUW1sc2FXNWxZWElvWkdGMFlTd2diM0IwYVc5dWN5azdDaUFnSUNCOUNpQWdmUW9nSUdaMWJtTjBhVzl1SUdOdmNIbE9aWGRUYVhwbEtHRnljbUY1TENCM2FXUjBhQ3dnYUdWcFoyaDBMQ0J6WVcxd2JHVnpVR1Z5VUdsNFpXd2dQU0F4S1NCN0NpQWdJQ0J5WlhSMWNtNGdibVYzSUNoUFltcGxZM1F1WjJWMFVISnZkRzkwZVhCbFQyWW9ZWEp5WVhrcEtTNWpiMjV6ZEhKMVkzUnZjaWgzYVdSMGFDQXFJR2hsYVdkb2RDQXFJSE5oYlhCc1pYTlFaWEpRYVhobGJDazdDaUFnZlFvZ0lHWjFibU4wYVc5dUlHeGxjbkFvZGpBc0lIWXhMQ0IwS1NCN0NpQWdJQ0J5WlhSMWNtNGdLREVnTFNCMEtTQXFJSFl3SUNzZ2RDQXFJSFl4T3dvZ0lIMEtJQ0JtZFc1amRHbHZiaUJ5WlhOaGJYQnNaVUpwYkdsdVpXRnlLR1JoZEdFc0lHOXdkR2x2Ym5NcElIc0tJQ0FnSUdOdmJuTjBJSHNnYzI5MWNtTmxWMmxrZEdnc0lITnZkWEpqWlVobGFXZG9kQ3dnZEdGeVoyVjBWMmxrZEdnc0lIUmhjbWRsZEVobGFXZG9kQ3dnZDJsdVpHOTNMQ0JpZFdabVpYSWdQU0F3TENCdWIyUmhkR0VnZlNBOUlHOXdkR2x2Ym5NN0NpQWdJQ0JqYjI1emRDQmJlREFzSUhrd0xDQjRNU3dnZVRGZElEMGdkMmx1Wkc5M093b2dJQ0FnWTI5dWMzUWdkMmx1Wkc5M1YybGtkR2dnUFNCNE1TQXRJSGd3T3dvZ0lDQWdZMjl1YzNRZ2QybHVaRzkzU0dWcFoyaDBJRDBnZVRFZ0xTQjVNRHNLSUNBZ0lHTnZibk4wSUc1bGQwRnljbUY1SUQwZ1kyOXdlVTVsZDFOcGVtVW9aR0YwWVN3Z2RHRnlaMlYwVjJsa2RHZ3NJSFJoY21kbGRFaGxhV2RvZENrN0NpQWdJQ0JqYjI1emRDQmxabVpsWTNScGRtVlRiM1Z5WTJWWGFXUjBhQ0E5SUhOdmRYSmpaVmRwWkhSb0lDMGdNaUFxSUdKMVptWmxjanNLSUNBZ0lHTnZibk4wSUdWbVptVmpkR2wyWlZOdmRYSmpaVWhsYVdkb2RDQTlJSE52ZFhKalpVaGxhV2RvZENBdElESWdLaUJpZFdabVpYSTdDaUFnSUNCamIyNXpkQ0JwYm5aVVlYSm5aWFJYYVdSMGFDQTlJREVnTHlCMFlYSm5aWFJYYVdSMGFEc0tJQ0FnSUdOdmJuTjBJR2x1ZGxSaGNtZGxkRWhsYVdkb2RDQTlJREVnTHlCMFlYSm5aWFJJWldsbmFIUTdDaUFnSUNCamIyNXpkQ0JwYzA1dlpHRjBZU0E5SUNoMllXeDFaU2tnUFQ0Z2V3b2dJQ0FnSUNCcFppQW9ibTlrWVhSaElEMDlQU0IyYjJsa0lEQXBDaUFnSUNBZ0lDQWdjbVYwZFhKdUlHWmhiSE5sT3dvZ0lDQWdJQ0JwWmlBb2JtOWtZWFJoSUQwOVBTQXdLUW9nSUNBZ0lDQWdJSEpsZEhWeWJpQjJZV3gxWlNBOVBUMGdNRHNLSUNBZ0lDQWdjbVYwZFhKdUlFMWhkR2d1WVdKektDaDJZV3gxWlNBdElHNXZaR0YwWVNrZ0x5QnViMlJoZEdFcElEd2dNV1V0TmpzS0lDQWdJSDA3Q2lBZ0lDQm1iM0lnS0d4bGRDQjVJRDBnTURzZ2VTQThJSFJoY21kbGRFaGxhV2RvZERzZ2VTc3JLU0I3Q2lBZ0lDQWdJR052Ym5OMElIbFNZWFJwYnlBOUlIa2dLaUJwYm5aVVlYSm5aWFJJWldsbmFIUTdDaUFnSUNBZ0lHTnZibk4wSUhsTllYQndaV1FnUFNCNU1DQXJJSGxTWVhScGJ5QXFJSGRwYm1SdmQwaGxhV2RvZERzS0lDQWdJQ0FnWTI5dWMzUWdjbUYzV1NBOUlHVm1abVZqZEdsMlpWTnZkWEpqWlVobGFXZG9kQ0FxSUhsTllYQndaV1FnS3lCaWRXWm1aWEk3Q2lBZ0lDQWdJR052Ym5OMElIbHNJRDBnVFdGMGFDNW1iRzl2Y2loeVlYZFpLVHNLSUNBZ0lDQWdZMjl1YzNRZ2VXZ2dQU0JOWVhSb0xtMXBiaWhOWVhSb0xtTmxhV3dvY21GM1dTa3NJSE52ZFhKalpVaGxhV2RvZENBdElHSjFabVpsY2lBdElERXBPd29nSUNBZ0lDQmpiMjV6ZENCMGVTQTlJSEpoZDFrZ0xTQjViRHNLSUNBZ0lDQWdabTl5SUNoc1pYUWdlQ0E5SURBN0lIZ2dQQ0IwWVhKblpYUlhhV1IwYURzZ2VDc3JLU0I3Q2lBZ0lDQWdJQ0FnWTI5dWMzUWdlRkpoZEdsdklEMGdlQ0FxSUdsdWRsUmhjbWRsZEZkcFpIUm9Pd29nSUNBZ0lDQWdJR052Ym5OMElIaE5ZWEJ3WldRZ1BTQjRNQ0FySUhoU1lYUnBieUFxSUhkcGJtUnZkMWRwWkhSb093b2dJQ0FnSUNBZ0lHTnZibk4wSUhKaGQxZ2dQU0JsWm1abFkzUnBkbVZUYjNWeVkyVlhhV1IwYUNBcUlIaE5ZWEJ3WldRZ0t5QmlkV1ptWlhJN0NpQWdJQ0FnSUNBZ1kyOXVjM1FnZUd3Z1BTQk5ZWFJvTG1ac2IyOXlLSEpoZDFncE93b2dJQ0FnSUNBZ0lHTnZibk4wSUhob0lEMGdUV0YwYUM1dGFXNG9UV0YwYUM1alpXbHNLSEpoZDFncExDQnpiM1Z5WTJWWGFXUjBhQ0F0SUdKMVptWmxjaUF0SURFcE93b2dJQ0FnSUNBZ0lHTnZibk4wSUhSNFJuSmhZM1JwYjI0Z1BTQnlZWGRZSUMwZ2VHdzdDaUFnSUNBZ0lDQWdZMjl1YzNRZ1kyVnVkR1Z5SUQwZ1pHRjBZVnQ1YkNBcUlITnZkWEpqWlZkcFpIUm9JQ3NnZUd4ZE93b2dJQ0FnSUNBZ0lHTnZibk4wSUc1bGFXZG9ZbTl5Y3lBOUlGc0tJQ0FnSUNBZ0lDQWdJR1JoZEdGYmVXd2dLaUJ6YjNWeVkyVlhhV1IwYUNBcklIaHNYU3dLSUNBZ0lDQWdJQ0FnSUdSaGRHRmJlV3dnS2lCemIzVnlZMlZYYVdSMGFDQXJJSGhvWFN3S0lDQWdJQ0FnSUNBZ0lHUmhkR0ZiZVdnZ0tpQnpiM1Z5WTJWWGFXUjBhQ0FySUhoc1hTd0tJQ0FnSUNBZ0lDQWdJR1JoZEdGYmVXZ2dLaUJ6YjNWeVkyVlhhV1IwYUNBcklIaG9YUW9nSUNBZ0lDQWdJRjA3Q2lBZ0lDQWdJQ0FnYm1WcFoyaGliM0p6TG1admNrVmhZMmdvS0c1bGFXZG9ZbTl5TENCcGJtUmxlQ2tnUFQ0Z2V3b2dJQ0FnSUNBZ0lDQWdhV1lnS0dselRtOWtZWFJoS0c1bGFXZG9ZbTl5S1NrZ2V3b2dJQ0FnSUNBZ0lDQWdJQ0J1WldsbmFHSnZjbk5iYVc1a1pYaGRJRDBnWTJWdWRHVnlPd29nSUNBZ0lDQWdJQ0FnZlFvZ0lDQWdJQ0FnSUgwcE93b2dJQ0FnSUNBZ0lHbG1JQ2hwYzA1dlpHRjBZU2hqWlc1MFpYSXBLU0I3Q2lBZ0lDQWdJQ0FnSUNCdVpYZEJjbkpoZVZ0NUlDb2dkR0Z5WjJWMFYybGtkR2dnS3lCNFhTQTlJRzV2WkdGMFlUc0tJQ0FnSUNBZ0lDQWdJR052Ym5ScGJuVmxPd29nSUNBZ0lDQWdJSDBLSUNBZ0lDQWdJQ0JqYjI1emRDQmJiR3dzSUdoc0xDQnNhQ3dnYUdoZElEMGdibVZwWjJoaWIzSnpPd29nSUNBZ0lDQWdJR052Ym5OMElIWXdJRDBnYkdWeWNDaHNiQ3dnYUd3c0lIUjRSbkpoWTNScGIyNHBPd29nSUNBZ0lDQWdJR052Ym5OMElIWXhJRDBnYkdWeWNDaHNhQ3dnYUdnc0lIUjRSbkpoWTNScGIyNHBPd29nSUNBZ0lDQWdJR052Ym5OMElIWmhiSFZsSUQwZ2JHVnljQ2gyTUN3Z2RqRXNJSFI1S1RzS0lDQWdJQ0FnSUNCdVpYZEJjbkpoZVZ0NUlDb2dkR0Z5WjJWMFYybGtkR2dnS3lCNFhTQTlJSFpoYkhWbE93b2dJQ0FnSUNCOUNpQWdJQ0I5Q2lBZ0lDQnlaWFIxY200Z2JtVjNRWEp5WVhrN0NpQWdmUW9LSUNCdmJtMWxjM05oWjJVZ1BTQm1kVzVqZEdsdmJpaGxLU0I3Q2lBZ0lDQmpiMjV6ZENCN0lHUmhkR0VzSUc5d2RHbHZibk1zSUdsa0lIMGdQU0JsTG1SaGRHRTdDaUFnSUNCamIyNXpkQ0J5WlhOMWJIUWdQU0J5WlhOaGJYQnNaVVJoZEdFb1pHRjBZU3dnYjNCMGFXOXVjeWs3Q2lBZ0lDQndiM04wVFdWemMyRm5aU2g3SUdSaGRHRTZJSEpsYzNWc2RDd2dhV1FnZlNrN0NpQWdmVHNLQ24wcEtDazdDaTh2SXlCemIzVnlZMlZOWVhCd2FXNW5WVkpNUFhkdmNtdGxjaTVxY3k1dFlYQUtDZz09JywgbnVsbCwgZmFsc2UpO1xuLyogZXNsaW50LWVuYWJsZSAqL1xuXG5jb25zdCBkZWZhdWx0UG9vbFNpemUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiID8gbmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3kgfHwgMiA6IDI7XG5jbGFzcyBXb3JrZXJQb29sIHtcbiAgd29ya2VycztcbiAgc2l6ZTtcbiAgbWVzc2FnZUlkO1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbc2l6ZV0gVGhlIHNpemUgb2YgdGhlIHBvb2wuIERlZmF1bHRzIHRvIHRoZSBudW1iZXIgb2YgQ1BVc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGUuIFdoZW4gdGhpcyBwYXJhbWV0ZXIgaXMgYG51bGxgIG9yIDAsIHRoZW4gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgIGRlY29kaW5nIHdpbGwgYmUgZG9uZSBpbiB0aGUgbWFpbiB0aHJlYWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzaXplID0gZGVmYXVsdFBvb2xTaXplKSB7XG4gICAgdGhpcy53b3JrZXJzID0gbnVsbDtcbiAgICB0aGlzLnNpemUgPSBzaXplID8/IDA7XG4gICAgdGhpcy5tZXNzYWdlSWQgPSAwO1xuICAgIGlmIChzaXplKSB7XG4gICAgICB0aGlzLndvcmtlcnMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIHRoaXMud29ya2Vycy5wdXNoKHsgd29ya2VyOiBXb3JrZXJGYWN0b3J5KCksIGlkbGU6IHRydWUgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFzeW5jIHJlc2FtcGxlKGRhdGEsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5zaXplID09PSAwID8gcmVzYW1wbGVEYXRhKGRhdGEsIG9wdGlvbnMpIDogbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGNvbnN0IHdvcmtlciA9IHRoaXMud29ya2Vycy5maW5kKChjYW5kaWRhdGUpID0+IGNhbmRpZGF0ZS5pZGxlKSB8fCB0aGlzLndvcmtlcnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy5zaXplKV07XG4gICAgICB3b3JrZXIuaWRsZSA9IGZhbHNlO1xuICAgICAgY29uc3QgaWQgPSB0aGlzLm1lc3NhZ2VJZCsrO1xuICAgICAgY29uc3Qgb25NZXNzYWdlID0gKGUpID0+IHtcbiAgICAgICAgaWYgKGUuZGF0YS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICB3b3JrZXIuaWRsZSA9IHRydWU7XG4gICAgICAgICAgcmVzb2x2ZShlLmRhdGEuZGF0YSk7XG4gICAgICAgICAgd29ya2VyLndvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbk1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgd29ya2VyLndvcmtlci5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbk1lc3NhZ2UpO1xuICAgICAgd29ya2VyLndvcmtlci5wb3N0TWVzc2FnZSh7IGRhdGEsIG9wdGlvbnMsIGlkIH0pO1xuICAgIH0pO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMud29ya2Vycykge1xuICAgICAgdGhpcy53b3JrZXJzLmZvckVhY2goKHdvcmtlcikgPT4ge1xuICAgICAgICB3b3JrZXIud29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLndvcmtlcnMgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBjYW52YXMgPSBjcmVhdGVDYW5hdmFzKDI1NiwgMjU2KTtcbmNsYXNzIFRJRkZJbWFnZXJ5UHJvdmlkZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmhhc0FscGhhQ2hhbm5lbCA9IG9wdGlvbnMuaGFzQWxwaGFDaGFubmVsID8/IHRydWU7XG4gICAgdGhpcy5tYXhpbXVtTGV2ZWwgPSBvcHRpb25zLm1heGltdW1MZXZlbCA/PyAxODtcbiAgICB0aGlzLm1pbmltdW1MZXZlbCA9IG9wdGlvbnMubWluaW11bUxldmVsID8/IDA7XG4gICAgdGhpcy5jcmVkaXQgPSBuZXcgQ3JlZGl0KG9wdGlvbnMuY3JlZGl0IHx8IFwiXCIsIGZhbHNlKTtcbiAgICB0aGlzLmVycm9yRXZlbnQgPSBuZXcgRXZlbnQoKTtcbiAgICB0aGlzLl9jYWNoZVNpemUgPSBvcHRpb25zLmNhY2hlU2l6ZSA/PyAxMDA7XG4gICAgdGhpcy53b3JrZXJQb29sID0gbmV3IFdvcmtlclBvb2wob3B0aW9ucy53b3JrZXJQb29sU2l6ZSk7XG4gICAgdGhpcy5nZW90aWZmV29ya2VyUG9vbCA9IG5ldyBQb29sKG9wdGlvbnMud29ya2VyUG9vbFNpemUpO1xuICAgIHRoaXMucmVhZHkgPSBmYWxzZTtcbiAgICBpZiAoZGVmaW5lZChvcHRpb25zLnVybCkpIHtcbiAgICAgIHRoaXMucmVhZHlQcm9taXNlID0gdGhpcy5fYnVpbGQob3B0aW9ucy51cmwsIG9wdGlvbnMpLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZWFkeTtcbiAgdGlsaW5nU2NoZW1lO1xuICByZWN0YW5nbGU7XG4gIHRpbGVTaXplO1xuICB0aWxlV2lkdGg7XG4gIHRpbGVIZWlnaHQ7XG4gIG1heGltdW1MZXZlbDtcbiAgbWluaW11bUxldmVsO1xuICBjcmVkaXQ7XG4gIGVycm9yRXZlbnQ7XG4gIHJlYWR5UHJvbWlzZTtcbiAgYmFuZHM7XG4gIG5vRGF0YTtcbiAgaGFzQWxwaGFDaGFubmVsO1xuICBwbG90O1xuICByZW5kZXJPcHRpb25zO1xuICByZWFkU2FtcGxlcztcbiAgcmVxdWVzdExldmVscztcbiAgYmJveDtcbiAgX2Rlc3Ryb3llZCA9IGZhbHNlO1xuICBfc291cmNlO1xuICBfaW1hZ2VDb3VudDtcbiAgX2ltYWdlcyA9IFtdO1xuICBfaW1hZ2VzQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBfY2FjaGVTaXplO1xuICBfaXNUaWxlZDtcbiAgX3Byb2o7XG4gIG9yaWdpbjtcbiAgcmV2ZXJzZVkgPSBmYWxzZTtcbiAgc2FtcGxlcztcbiAgd29ya2VyUG9vbDtcbiAgZ2VvdGlmZldvcmtlclBvb2w7XG4gIGdldCBpc0Rlc3Ryb3llZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVzdHJveWVkO1xuICB9XG4gIGFzeW5jIF9idWlsZCh1cmwsIG9wdGlvbnMgPSB7fSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgeyB0aWxlU2l6ZSwgcmVuZGVyT3B0aW9ucywgcHJvakZ1bmMsIHJlcXVlc3RPcHRpb25zIH0gPSBvcHRpb25zO1xuICAgIGxldCBzb3VyY2UgPSBhd2FpdCAodXJsIGluc3RhbmNlb2YgRmlsZSB8fCB1cmwgaW5zdGFuY2VvZiBCbG9iID8gZnJvbUJsb2IodXJsKSA6IGZyb21VcmwodXJsLCByZXF1ZXN0T3B0aW9ucykpO1xuICAgIGxldCBpbWFnZSA9IGF3YWl0IHNvdXJjZS5nZXRJbWFnZSgpO1xuICAgIHRoaXMuX2lzVGlsZWQgPSBpbWFnZS5pc1RpbGVkO1xuICAgIGlmICghdGhpcy5faXNUaWxlZCAmJiB0eXBlb2YgdXJsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBzb3VyY2UgPSBhd2FpdCBmcm9tQmxvYihhd2FpdCAoYXdhaXQgZmV0Y2godXJsKSkuYmxvYigpKTtcbiAgICAgIGltYWdlID0gYXdhaXQgc291cmNlLmdldEltYWdlKCk7XG4gICAgfVxuICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLm9yaWdpbiA9IHRoaXMuX2dldE9yaWdpbihpbWFnZSk7XG4gICAgdGhpcy5iYm94ID0gaW1hZ2UuZ2V0Qm91bmRpbmdCb3goKTtcbiAgICB0aGlzLnJldmVyc2VZID0gdGhpcy5fY2hlY2tJZlJldmVyc2VkKGltYWdlKTtcbiAgICBjb25zdCBbd2VzdCwgc291dGgsIGVhc3QsIG5vcnRoXSA9IHRoaXMuYmJveDtcbiAgICBjb25zdCBwcmpDb2RlID0gKyhpbWFnZS5nZW9LZXlzLlByb2plY3RlZENTVHlwZUdlb0tleSA/PyBpbWFnZS5nZW9LZXlzLkdlb2dyYXBoaWNUeXBlR2VvS2V5KTtcbiAgICB0aGlzLl9wcm9qID0gcHJvakZ1bmMgPT0gbnVsbCA/IHZvaWQgMCA6IHByb2pGdW5jKHByakNvZGUpO1xuICAgIGlmIChwcmpDb2RlID09PSAzODU3IHx8IHByakNvZGUgPT09IDkwMDkxMykge1xuICAgICAgdGhpcy50aWxpbmdTY2hlbWUgPSBuZXcgV2ViTWVyY2F0b3JUaWxpbmdTY2hlbWUoe1xuICAgICAgICByZWN0YW5nbGVOb3J0aGVhc3RJbk1ldGVyczogbmV3IENhcnRlc2lhbjIoZWFzdCwgbm9ydGgpLFxuICAgICAgICByZWN0YW5nbGVTb3V0aHdlc3RJbk1ldGVyczogbmV3IENhcnRlc2lhbjIod2VzdCwgc291dGgpXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHByakNvZGUgPT09IDQzMjYpIHtcbiAgICAgIHRoaXMudGlsaW5nU2NoZW1lID0gbmV3IEdlb2dyYXBoaWNUaWxpbmdTY2hlbWUoe1xuICAgICAgICByZWN0YW5nbGU6IFJlY3RhbmdsZS5mcm9tRGVncmVlcyguLi50aGlzLmJib3gpLFxuICAgICAgICBudW1iZXJPZkxldmVsWmVyb1RpbGVzWDogMSxcbiAgICAgICAgbnVtYmVyT2ZMZXZlbFplcm9UaWxlc1k6IDFcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mICgoX2EgPSB0aGlzLl9wcm9qKSA9PSBudWxsID8gdm9pZCAwIDogX2EucHJvamVjdCkgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgKChfYiA9IHRoaXMuX3Byb2opID09IG51bGwgPyB2b2lkIDAgOiBfYi51bnByb2plY3QpID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUud2FybihgW0V4cGVyaW1lbnRhbF0gUmVwcm9qZWN0aW9uIEVQU0c6JHtwcmpDb2RlfWApO1xuICAgICAgdGhpcy50aWxpbmdTY2hlbWUgPSBuZXcgVElGRkltYWdlcnlQcm92aWRlclRpbGluZ1NjaGVtZSh7XG4gICAgICAgIHJlY3RhbmdsZU5vcnRoZWFzdEluTWV0ZXJzOiBuZXcgQ2FydGVzaWFuMihlYXN0LCBub3J0aCksXG4gICAgICAgIHJlY3RhbmdsZVNvdXRod2VzdEluTWV0ZXJzOiBuZXcgQ2FydGVzaWFuMih3ZXN0LCBzb3V0aCksXG4gICAgICAgIC4uLnRoaXMuX3Byb2pcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBEZXZlbG9wZXJFcnJvcihgVW5zcHBvcnRlZCBwcm9qZWN0aW9uIHR5cGU6IEVQU0c6JHtwcmpDb2RlfSwgcGxlYXNlIGFkZCBwcm9qRnVuYyBwYXJhbWV0ZXIgdG8gaGFuZGxlIHByb2plY3Rpb25gKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICB0aGlzLnJlY3RhbmdsZSA9IHRoaXMudGlsaW5nU2NoZW1lLnJlY3RhbmdsZTtcbiAgICBpZiAodGhpcy5yZWN0YW5nbGUuZWFzdCA8IHRoaXMucmVjdGFuZ2xlLndlc3QpIHtcbiAgICAgIHRoaXMucmVjdGFuZ2xlLmVhc3QgKz0gTWF0aCQxLlRXT19QSTtcbiAgICB9XG4gICAgdGhpcy5faW1hZ2VDb3VudCA9IGF3YWl0IHNvdXJjZS5nZXRJbWFnZUNvdW50KCk7XG4gICAgdGhpcy50aWxlU2l6ZSA9IHRoaXMudGlsZVdpZHRoID0gdGlsZVNpemUgfHwgKHRoaXMuX2lzVGlsZWQgPyBpbWFnZS5nZXRUaWxlV2lkdGgoKSA6IGltYWdlLmdldFdpZHRoKCkpIHx8IDI1NjtcbiAgICB0aGlzLnRpbGVIZWlnaHQgPSB0aWxlU2l6ZSB8fCAodGhpcy5faXNUaWxlZCA/IGltYWdlLmdldFRpbGVIZWlnaHQoKSA6IGltYWdlLmdldEhlaWdodCgpKSB8fCAyNTY7XG4gICAgY29uc29sZS5sb2codGhpcy50aWxlV2lkdGgsIHRoaXMudGlsZUhlaWdodCk7XG4gICAgdGhpcy5yZXF1ZXN0TGV2ZWxzID0gdGhpcy5faXNUaWxlZCA/IGF3YWl0IHRoaXMuX2dldENvZ0xldmVscygpIDogWzBdO1xuICAgIHRoaXMuX2ltYWdlcyA9IG5ldyBBcnJheSh0aGlzLl9pbWFnZUNvdW50KS5maWxsKG51bGwpO1xuICAgIGNvbnN0IHNhbXBsZXMgPSBpbWFnZS5nZXRTYW1wbGVzUGVyUGl4ZWwoKTtcbiAgICB0aGlzLnNhbXBsZXMgPSBzYW1wbGVzO1xuICAgIHRoaXMucmVuZGVyT3B0aW9ucyA9IHJlbmRlck9wdGlvbnMgPz8ge307XG4gICAgY29uc3Qgbm9EYXRhID0gaW1hZ2UuZ2V0R0RBTE5vRGF0YSgpO1xuICAgIHRoaXMubm9EYXRhID0gdGhpcy5yZW5kZXJPcHRpb25zLm5vZGF0YSA/PyBub0RhdGE7XG4gICAgaWYgKHNhbXBsZXMgPCAzICYmIHRoaXMucmVuZGVyT3B0aW9ucy5jb252ZXJ0VG9SR0IpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IERldmVsb3BlckVycm9yKFwiQ2FuIG5vdCByZW5kZXIgdGhlIGltYWdlIGFzIFJHQiwgcGxlYXNlIGNoZWNrIHRoZSBjb252ZXJ0VG9SR0IgcGFyYW1ldGVyXCIpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmICghdGhpcy5yZW5kZXJPcHRpb25zLnNpbmdsZSAmJiAhdGhpcy5yZW5kZXJPcHRpb25zLm11bHRpICYmICF0aGlzLnJlbmRlck9wdGlvbnMuY29udmVydFRvUkdCKSB7XG4gICAgICBpZiAoc2FtcGxlcyA+IDIpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJPcHRpb25zID0ge1xuICAgICAgICAgIGNvbnZlcnRUb1JHQjogdHJ1ZSxcbiAgICAgICAgICAuLi50aGlzLnJlbmRlck9wdGlvbnNcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVuZGVyT3B0aW9ucyA9IHtcbiAgICAgICAgICBzaW5nbGU6IHtcbiAgICAgICAgICAgIGJhbmQ6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIC4uLnRoaXMucmVuZGVyT3B0aW9uc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5yZW5kZXJPcHRpb25zLnNpbmdsZSkge1xuICAgICAgdGhpcy5yZW5kZXJPcHRpb25zLnNpbmdsZS5iYW5kID0gdGhpcy5yZW5kZXJPcHRpb25zLnNpbmdsZS5iYW5kID8/IDE7XG4gICAgfVxuICAgIGNvbnN0IHsgc2luZ2xlLCBtdWx0aSwgY29udmVydFRvUkdCIH0gPSB0aGlzLnJlbmRlck9wdGlvbnM7XG4gICAgdGhpcy5yZWFkU2FtcGxlcyA9IG11bHRpID8gW211bHRpLnIuYmFuZCAtIDEsIG11bHRpLmcuYmFuZCAtIDEsIG11bHRpLmIuYmFuZCAtIDFdIDogY29udmVydFRvUkdCID8gWzAsIDEsIDJdIDogW3NpbmdsZS5iYW5kIC0gMV07XG4gICAgaWYgKHNpbmdsZSA9PSBudWxsID8gdm9pZCAwIDogc2luZ2xlLmV4cHJlc3Npb24pIHtcbiAgICAgIHRoaXMucmVhZFNhbXBsZXMgPSBmaW5kQW5kU29ydEJhbmROdW1iZXJzKHNpbmdsZS5leHByZXNzaW9uKTtcbiAgICB9XG4gICAgY29uc3QgYmFuZHMgPSB7fTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLnJlYWRTYW1wbGVzLm1hcChhc3luYyAoaSkgPT4ge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGltYWdlLmdldEdEQUxNZXRhZGF0YShpKTtcbiAgICAgIGNvbnN0IGJhbmROdW0gPSBpICsgMTtcbiAgICAgIGlmICgoZWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogZWxlbWVudC5TVEFUSVNUSUNTX01JTklNVU0pICYmIChlbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBlbGVtZW50LlNUQVRJU1RJQ1NfTUFYSU1VTSkpIHtcbiAgICAgICAgYmFuZHNbYmFuZE51bV0gPSB7XG4gICAgICAgICAgbWluOiArZWxlbWVudC5TVEFUSVNUSUNTX01JTklNVU0sXG4gICAgICAgICAgbWF4OiArZWxlbWVudC5TVEFUSVNUSUNTX01BWElNVU1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjb252ZXJ0VG9SR0IpIHtcbiAgICAgICAgICBiYW5kc1tiYW5kTnVtXSA9IHtcbiAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgIG1heDogMjU1XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXVsdGkpIHtcbiAgICAgICAgICBjb25zdCBpbnB1dEJhbmQgPSBtdWx0aVtPYmplY3Qua2V5cyhtdWx0aSkuZmluZCgoa2V5KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EyO1xuICAgICAgICAgICAgcmV0dXJuICgoX2EyID0gbXVsdGlba2V5XSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5iYW5kKSA9PT0gYmFuZE51bTtcbiAgICAgICAgICB9KV07XG4gICAgICAgICAgaWYgKChpbnB1dEJhbmQgPT0gbnVsbCA/IHZvaWQgMCA6IGlucHV0QmFuZC5taW4pICE9PSB2b2lkIDAgJiYgKGlucHV0QmFuZCA9PSBudWxsID8gdm9pZCAwIDogaW5wdXRCYW5kLm1heCkgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgY29uc3QgeyBtaW4sIG1heCB9ID0gaW5wdXRCYW5kO1xuICAgICAgICAgICAgYmFuZHNbYmFuZE51bV0gPSB7XG4gICAgICAgICAgICAgIG1pbixcbiAgICAgICAgICAgICAgbWF4XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2luZ2xlICYmICFzaW5nbGUuZXhwcmVzc2lvbiAmJiBzaW5nbGUuYmFuZCA9PT0gYmFuZE51bSAmJiBzaW5nbGUuZG9tYWluKSB7XG4gICAgICAgICAgYmFuZHNbYmFuZE51bV0gPSB7XG4gICAgICAgICAgICBtaW46IHNpbmdsZS5kb21haW5bMF0sXG4gICAgICAgICAgICBtYXg6IHNpbmdsZS5kb21haW5bMV1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHNpbmdsZSA9PSBudWxsID8gdm9pZCAwIDogc2luZ2xlLmV4cHJlc3Npb24pICYmICFiYW5kc1tiYW5kTnVtXSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgQ2FuIG5vdCBnZXQgYmFuZCR7YmFuZE51bX0gbWluL21heCwgdHJ5IHRvIGNhbGN1bGF0ZSBtaW4vbWF4IHZhbHVlcywgb3Igc2V0dGluZyAke3NpbmdsZSA/IFwiZG9tYWluXCIgOiBcIm1pbiAvIG1heFwifWApO1xuICAgICAgICAgIGNvbnN0IHByZXZpZXdJbWFnZSA9IGF3YWl0IHNvdXJjZS5nZXRJbWFnZSh0aGlzLnJlcXVlc3RMZXZlbHNbMF0pO1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSAoYXdhaXQgcHJldmlld0ltYWdlLnJlYWRSYXN0ZXJzKHtcbiAgICAgICAgICAgIHNhbXBsZXM6IFtpXSxcbiAgICAgICAgICAgIHBvb2w6IHRoaXMuZ2VvdGlmZldvcmtlclBvb2xcbiAgICAgICAgICB9KSlbMF0uZmlsdGVyKChpdGVtKSA9PiAhaXNOYU4oaXRlbSkpO1xuICAgICAgICAgIGJhbmRzW2JhbmROdW1dID0gZ2V0TWluTWF4KGRhdGEsIG5vRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSk7XG4gICAgdGhpcy5iYW5kcyA9IGJhbmRzO1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5yZW5kZXJPcHRpb25zLnNpbmdsZSkge1xuICAgICAgICBjb25zdCBiYW5kID0gdGhpcy5iYW5kc1tzaW5nbGUuYmFuZF07XG4gICAgICAgIGlmICghc2luZ2xlLmV4cHJlc3Npb24gJiYgIWJhbmQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoYEludmFsaWQgYmFuZCR7c2luZ2xlLmJhbmR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG9tYWluID0gc2luZ2xlLmRvbWFpbiA/PyBbYmFuZC5taW4sIGJhbmQubWF4XTtcbiAgICAgICAgdGhpcy5wbG90ID0gbmV3IHBsb3Qoe1xuICAgICAgICAgIGNhbnZhcyxcbiAgICAgICAgICAuLi5zaW5nbGUsXG4gICAgICAgICAgZG9tYWluXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBsb3Quc2V0Tm9EYXRhVmFsdWUodGhpcy5ub0RhdGEpO1xuICAgICAgICBjb25zdCB7IGV4cHJlc3Npb24sIGNvbG9ycywgY29sb3JTY2FsZUltYWdlIH0gPSBzaW5nbGU7XG4gICAgICAgIHRoaXMucGxvdC5zZXRFeHByZXNzaW9uKGV4cHJlc3Npb24pO1xuICAgICAgICBpZiAoY29sb3JzKSB7XG4gICAgICAgICAgY29uc3QgY29sb3JTY2FsZSA9IGdlbmVyYXRlQ29sb3JTY2FsZShjb2xvcnMsIChzaW5nbGUgPT0gbnVsbCA/IHZvaWQgMCA6IHNpbmdsZS51c2VSZWFsVmFsdWUpID8gZG9tYWluIDogWzAsIDFdKTtcbiAgICAgICAgICBhZGRDb2xvclNjYWxlKFwidGVtcFwiLCBjb2xvclNjYWxlLmNvbG9ycywgY29sb3JTY2FsZS5wb3NpdGlvbnMpO1xuICAgICAgICAgIHRoaXMucGxvdC5zZXRDb2xvclNjYWxlKFwidGVtcFwiKTtcbiAgICAgICAgfSBlbHNlIGlmICghY29sb3JTY2FsZUltYWdlKSB7XG4gICAgICAgICAgdGhpcy5wbG90LnNldENvbG9yU2NhbGUoKHNpbmdsZSA9PSBudWxsID8gdm9pZCAwIDogc2luZ2xlLmNvbG9yU2NhbGUpID8/IFwiYmxhY2t3aGl0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICB0aGlzLmVycm9yRXZlbnQucmFpc2VFdmVudChlKTtcbiAgICB9XG4gICAgdGhpcy5yZWFkeVByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZyb21VcmwodXJsLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBUSUZGSW1hZ2VyeVByb3ZpZGVyKG9wdGlvbnMpO1xuICAgIGF3YWl0IHByb3ZpZGVyLl9idWlsZCh1cmwsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICB1cmw6IHZvaWQgMFxuICAgIH0pO1xuICAgIHJldHVybiBwcm92aWRlcjtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBvcmlnaW4gb2YgYW4gaW1hZ2UuICBJZiB0aGUgaW1hZ2UgZG9lcyBub3QgaGF2ZSBhbiBhZmZpbmUgdHJhbnNmb3JtLFxuICAgKiB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSBwaXhlbCBib3VuZHMgaXMgcmV0dXJuZWQuXG4gICAqIEBwYXJhbSB7R2VvVElGRkltYWdlfSBpbWFnZSBUaGUgaW1hZ2UuXG4gICAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IFRoZSBpbWFnZSBvcmlnaW4uXG4gICAqL1xuICBfZ2V0T3JpZ2luKGltYWdlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBpbWFnZS5nZXRPcmlnaW4oKS5zbGljZSgwLCAyKTtcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICByZXR1cm4gWzAsIGltYWdlLmZpbGVEaXJlY3RvcnkuSW1hZ2VMZW5ndGhdO1xuICAgIH1cbiAgfVxuICBfY2hlY2tJZlJldmVyc2VkKGltYWdlKSB7XG4gICAgY29uc3QgcGl4ZWxTY2FsZSA9IGltYWdlLmdldEZpbGVEaXJlY3RvcnkoKS5Nb2RlbFBpeGVsU2NhbGU7XG4gICAgaWYgKHBpeGVsU2NhbGUpIHtcbiAgICAgIGNvbnN0IHBpeGVsU2NhbGVZID0gcGl4ZWxTY2FsZVsxXTtcbiAgICAgIGlmIChwaXhlbFNjYWxlWSA8IDApXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCB0cmFuc2Zvcm1hdGlvbiA9IGltYWdlLmdldEZpbGVEaXJlY3RvcnkoKS5Nb2RlbFRyYW5zZm9ybWF0aW9uO1xuICAgIGlmICh0cmFuc2Zvcm1hdGlvbikge1xuICAgICAgY29uc3Qgb3JpZ2luWCA9IHRyYW5zZm9ybWF0aW9uWzNdO1xuICAgICAgY29uc3Qgb3JpZ2luWSA9IHRyYW5zZm9ybWF0aW9uWzddO1xuICAgICAgaWYgKG9yaWdpblkgPiBvcmlnaW5YKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBnZXQgc3VpdGFibGUgY29nIGxldmVsc1xuICAgKi9cbiAgYXN5bmMgX2dldENvZ0xldmVscygpIHtcbiAgICBjb25zdCBsZXZlbHMgPSBbXTtcbiAgICBsZXQgbWF4aW11bUxldmVsID0gdGhpcy5faW1hZ2VDb3VudCAtIDE7XG4gICAgZm9yIChsZXQgaSA9IHRoaXMuX2ltYWdlQ291bnQgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgaW1hZ2UgPSB0aGlzLl9pbWFnZXNbaV0gPSBhd2FpdCB0aGlzLl9zb3VyY2UuZ2V0SW1hZ2UoaSk7XG4gICAgICBjb25zdCB3aWR0aCA9IGltYWdlLmdldFdpZHRoKCk7XG4gICAgICBjb25zdCBoZWlnaHQgPSBpbWFnZS5nZXRIZWlnaHQoKTtcbiAgICAgIGNvbnN0IHNpemUgPSBNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGlmIChpID09PSB0aGlzLl9pbWFnZUNvdW50IC0gMSkge1xuICAgICAgICBjb25zdCBmaXJzdEltYWdlTGV2ZWwgPSBNYXRoLmNlaWwoKHNpemUgLSB0aGlzLnRpbGVTaXplKSAvIHRoaXMudGlsZVNpemUpO1xuICAgICAgICBsZXZlbHMucHVzaCguLi5uZXcgQXJyYXkoZmlyc3RJbWFnZUxldmVsKS5maWxsKGkpKTtcbiAgICAgIH1cbiAgICAgIGlmIChzaXplID4gdGhpcy50aWxlU2l6ZSAqIDAuNSkge1xuICAgICAgICBtYXhpbXVtTGV2ZWwgPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IG5vd0NvZ0xldmVsID0gbWF4aW11bUxldmVsO1xuICAgIHdoaWxlIChub3dDb2dMZXZlbCA+PSAwKSB7XG4gICAgICBsZXZlbHMucHVzaChub3dDb2dMZXZlbC0tKTtcbiAgICB9XG4gICAgcmV0dXJuIGxldmVscztcbiAgfVxuICAvKipcbiAgICogR2V0IHRpbGUgZGF0YVxuICAgKiBAcGFyYW0geCBcbiAgICogQHBhcmFtIHkgXG4gICAqIEBwYXJhbSB6IFxuICAgKi9cbiAgYXN5bmMgX2xvYWRUaWxlKHJlcXgsIHJlcXksIHJlcXopIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHggPSByZXF4LCB5ID0gcmVxeSwgeiA9IHJlcXosIHN0YXJ0WCA9IHJlcXgsIHN0YXJ0WSA9IHJlcXk7XG4gICAgY29uc3QgbWF4Q29nTGV2ZWwgPSB0aGlzLnJlcXVlc3RMZXZlbHMubGVuZ3RoIC0gMTtcbiAgICBpZiAoeiA+IG1heENvZ0xldmVsKSB7XG4gICAgICB6ID0gbWF4Q29nTGV2ZWw7XG4gICAgICB4ID0geCA+PiByZXF6IC0gbWF4Q29nTGV2ZWw7XG4gICAgICB5ID0geSA+PiByZXF6IC0gbWF4Q29nTGV2ZWw7XG4gICAgICBzdGFydFggPSB4IDw8IHJlcXogLSB6O1xuICAgICAgc3RhcnRZID0geSA8PCByZXF6IC0gejtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnJlcXVlc3RMZXZlbHNbel07XG4gICAgbGV0IGltYWdlID0gdGhpcy5faW1hZ2VzW2luZGV4XTtcbiAgICBpZiAoIWltYWdlKSB7XG4gICAgICBpbWFnZSA9IHRoaXMuX2ltYWdlc1tpbmRleF0gPSBhd2FpdCB0aGlzLl9zb3VyY2UuZ2V0SW1hZ2UoaW5kZXgpO1xuICAgIH1cbiAgICBjb25zdCB3aWR0aCA9IGltYWdlLmdldFdpZHRoKCk7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2UuZ2V0SGVpZ2h0KCk7XG4gICAgY29uc3QgdGlsZVhOdW0gPSB0aGlzLnRpbGluZ1NjaGVtZS5nZXROdW1iZXJPZlhUaWxlc0F0TGV2ZWwoeik7XG4gICAgY29uc3QgdGlsZVlOdW0gPSB0aGlzLnRpbGluZ1NjaGVtZS5nZXROdW1iZXJPZllUaWxlc0F0TGV2ZWwoeik7XG4gICAgY29uc3QgdGlsZVBpeGVsID0ge1xuICAgICAgeFdpZHRoOiB3aWR0aCAvIHRpbGVYTnVtLFxuICAgICAgeVdpZHRoOiBoZWlnaHQgLyB0aWxlWU51bVxuICAgIH07XG4gICAgbGV0IHdpbmRvdyA9IFtcbiAgICAgIE1hdGgucm91bmQoeCAqIHRpbGVQaXhlbC54V2lkdGgpLFxuICAgICAgTWF0aC5yb3VuZCh5ICogdGlsZVBpeGVsLnlXaWR0aCksXG4gICAgICBNYXRoLnJvdW5kKCh4ICsgMSkgKiB0aWxlUGl4ZWwueFdpZHRoKSxcbiAgICAgIE1hdGgucm91bmQoKHkgKyAxKSAqIHRpbGVQaXhlbC55V2lkdGgpXG4gICAgXTtcbiAgICBpZiAodGhpcy5fcHJvaiAmJiB0aGlzLnRpbGluZ1NjaGVtZSBpbnN0YW5jZW9mIFRJRkZJbWFnZXJ5UHJvdmlkZXJUaWxpbmdTY2hlbWUpIHtcbiAgICAgIGNvbnN0IHRhcmdldFJlY3QgPSB0aGlzLnRpbGluZ1NjaGVtZS50aWxlWFlUb05hdGl2ZVJlY3RhbmdsZTIoeCwgeSwgeik7XG4gICAgICBjb25zdCBuYXRpdmVSZWN0ID0gdGhpcy50aWxpbmdTY2hlbWUubmF0aXZlUmVjdGFuZ2xlO1xuICAgICAgdGFyZ2V0UmVjdC53ZXN0IC09IG5hdGl2ZVJlY3Qud2lkdGggLyB3aWR0aDtcbiAgICAgIHRhcmdldFJlY3QuZWFzdCArPSBuYXRpdmVSZWN0LndpZHRoIC8gd2lkdGg7XG4gICAgICB0YXJnZXRSZWN0LnNvdXRoIC09IG5hdGl2ZVJlY3QuaGVpZ2h0IC8gaGVpZ2h0O1xuICAgICAgdGFyZ2V0UmVjdC5ub3J0aCArPSBuYXRpdmVSZWN0LmhlaWdodCAvIGhlaWdodDtcbiAgICAgIHdpbmRvdyA9IFtcbiAgICAgICAgfn4oKHRhcmdldFJlY3Qud2VzdCAtIG5hdGl2ZVJlY3Qud2VzdCkgLyBuYXRpdmVSZWN0LndpZHRoICogd2lkdGgpLFxuICAgICAgICB+figobmF0aXZlUmVjdC5ub3J0aCAtIHRhcmdldFJlY3Qubm9ydGgpIC8gbmF0aXZlUmVjdC5oZWlnaHQgKiBoZWlnaHQpLFxuICAgICAgICB+figodGFyZ2V0UmVjdC5lYXN0IC0gbmF0aXZlUmVjdC53ZXN0KSAvIG5hdGl2ZVJlY3Qud2lkdGggKiB3aWR0aCksXG4gICAgICAgIH5+KChuYXRpdmVSZWN0Lm5vcnRoIC0gdGFyZ2V0UmVjdC5zb3V0aCkgLyBuYXRpdmVSZWN0LmhlaWdodCAqIGhlaWdodClcbiAgICAgIF07XG4gICAgfVxuICAgIGlmICh0aGlzLnJldmVyc2VZKSB7XG4gICAgICB3aW5kb3cgPSBbd2luZG93WzBdLCBoZWlnaHQgLSB3aW5kb3dbM10sIHdpbmRvd1syXSwgaGVpZ2h0IC0gd2luZG93WzFdXTtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyID0gMTtcbiAgICB3aW5kb3cgPSBbd2luZG93WzBdIC0gYnVmZmVyLCB3aW5kb3dbMV0gLSBidWZmZXIsIHdpbmRvd1syXSArIGJ1ZmZlciwgd2luZG93WzNdICsgYnVmZmVyXTtcbiAgICBjb25zdCBzb3VyY2VXaWR0aCA9IHdpbmRvd1syXSAtIHdpbmRvd1swXSwgc291cmNlSGVpZ2h0ID0gd2luZG93WzNdIC0gd2luZG93WzFdO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICB3aW5kb3csXG4gICAgICBwb29sOiB0aGlzLmdlb3RpZmZXb3JrZXJQb29sLFxuICAgICAgc2FtcGxlczogdGhpcy5yZWFkU2FtcGxlcyxcbiAgICAgIGZpbGxWYWx1ZTogdGhpcy5ub0RhdGEsXG4gICAgICBpbnRlcmxlYXZlOiBmYWxzZVxuICAgIH07XG4gICAgbGV0IHJlcztcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMucmVuZGVyT3B0aW9ucy5jb252ZXJ0VG9SR0IpIHtcbiAgICAgICAgcmVzID0gYXdhaXQgaW1hZ2UucmVhZFJHQihvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcyA9IGF3YWl0IGltYWdlLnJlYWRSYXN0ZXJzKG9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5yZXZlcnNlWSkge1xuICAgICAgICAgIHJlcyA9IGF3YWl0IFByb21pc2UuYWxsKHJlcy5tYXAoKGFycmF5KSA9PiByZXZlcnNlQXJyYXkoeyBhcnJheSwgd2lkdGg6IHJlcy53aWR0aCwgaGVpZ2h0OiByZXMuaGVpZ2h0IH0pKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICgoKF9hID0gdGhpcy5fcHJvaikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnByb2plY3QpICYmIHRoaXMudGlsaW5nU2NoZW1lIGluc3RhbmNlb2YgVElGRkltYWdlcnlQcm92aWRlclRpbGluZ1NjaGVtZSkge1xuICAgICAgICBjb25zdCBzb3VyY2VSZWN0ID0gdGhpcy50aWxpbmdTY2hlbWUudGlsZVhZVG9OYXRpdmVSZWN0YW5nbGUyKHgsIHksIHopO1xuICAgICAgICBjb25zdCB0YXJnZXRSZWN0ID0gdGhpcy50aWxpbmdTY2hlbWUudGlsZVhZVG9SZWN0YW5nbGUoeCwgeSwgeik7XG4gICAgICAgIGNvbnN0IHNvdXJjZUJCb3ggPSBbc291cmNlUmVjdC53ZXN0LCBzb3VyY2VSZWN0LnNvdXRoLCBzb3VyY2VSZWN0LmVhc3QsIHNvdXJjZVJlY3Qubm9ydGhdO1xuICAgICAgICBjb25zdCB0YXJnZXRCQm94ID0gW3RhcmdldFJlY3Qud2VzdCwgdGFyZ2V0UmVjdC5zb3V0aCwgdGFyZ2V0UmVjdC5lYXN0LCB0YXJnZXRSZWN0Lm5vcnRoXS5tYXAoTWF0aCQxLnRvRGVncmVlcyk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHByakRhdGEgPSByZXByb2plY3Rpb24oe1xuICAgICAgICAgICAgZGF0YTogcmVzW2ldLFxuICAgICAgICAgICAgc291cmNlV2lkdGgsXG4gICAgICAgICAgICBzb3VyY2VIZWlnaHQsXG4gICAgICAgICAgICBub2RhdGE6IHRoaXMubm9EYXRhLFxuICAgICAgICAgICAgcHJvamVjdDogdGhpcy5fcHJvai5wcm9qZWN0LFxuICAgICAgICAgICAgc291cmNlQkJveCxcbiAgICAgICAgICAgIHRhcmdldEJCb3hcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXN1bHQucHVzaChwcmpEYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXMgPSByZXN1bHQ7XG4gICAgICB9XG4gICAgICBjb25zdCB0aWxlTnVtID0gMSA8PCByZXF6IC0gejtcbiAgICAgIGNvbnN0IHgwID0gKHJlcXggLSBzdGFydFgpIC8gdGlsZU51bTtcbiAgICAgIGNvbnN0IHkwID0gKHJlcXkgLSBzdGFydFkpIC8gdGlsZU51bTtcbiAgICAgIGNvbnN0IHN0ZXAgPSAxIC8gKDEgPDwgcmVxeiAtIHopO1xuICAgICAgY29uc3QgeDEgPSB4MCArIHN0ZXA7XG4gICAgICBjb25zdCB5MSA9IHkwICsgc3RlcDtcbiAgICAgIHJlcyA9IGF3YWl0IFByb21pc2UuYWxsKHJlcy5tYXAoYXN5bmMgKGRhdGEpID0+IHRoaXMud29ya2VyUG9vbC5yZXNhbXBsZShkYXRhLCB7XG4gICAgICAgIHNvdXJjZVdpZHRoLFxuICAgICAgICBzb3VyY2VIZWlnaHQsXG4gICAgICAgIHRhcmdldFdpZHRoOiB0aGlzLnRpbGVXaWR0aCxcbiAgICAgICAgdGFyZ2V0SGVpZ2h0OiB0aGlzLnRpbGVIZWlnaHQsXG4gICAgICAgIHdpbmRvdzogW3gwLCB5MCwgeDEsIHkxXSxcbiAgICAgICAgbWV0aG9kOiB0aGlzLnJlbmRlck9wdGlvbnMucmVzYW1wbGVNZXRob2QsXG4gICAgICAgIGJ1ZmZlcixcbiAgICAgICAgbm9kYXRhOiB0aGlzLm5vRGF0YVxuICAgICAgfSkpKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHJlcyxcbiAgICAgICAgd2lkdGg6IHRoaXMudGlsZVdpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMudGlsZUhlaWdodFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5lcnJvckV2ZW50LnJhaXNlRXZlbnQoZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIGFzeW5jIHJlcXVlc3RJbWFnZSh4LCB5LCB6KSB7XG4gICAgaWYgKCF0aGlzLnJlYWR5KSB7XG4gICAgICB0aHJvdyBuZXcgRGV2ZWxvcGVyRXJyb3IoXG4gICAgICAgIFwicmVxdWVzdEltYWdlIG11c3Qgbm90IGJlIGNhbGxlZCBiZWZvcmUgdGhlIGltYWdlcnkgcHJvdmlkZXIgaXMgcmVhZHkuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh6IDwgdGhpcy5taW5pbXVtTGV2ZWwgfHwgeiA+IHRoaXMubWF4aW11bUxldmVsKVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICBjb25zdCBjYWNoZUtleSA9IGAke3h9XyR7eX1fJHt6fWA7XG4gICAgaWYgKHRoaXMuX2ltYWdlc0NhY2hlLmhhcyhjYWNoZUtleSkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbWFnZXNDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgIH1cbiAgICBjb25zdCB7IHNpbmdsZSwgbXVsdGksIGNvbnZlcnRUb1JHQiB9ID0gdGhpcy5yZW5kZXJPcHRpb25zO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIGRhdGEgfSA9IGF3YWl0IHRoaXMuX2xvYWRUaWxlKHgsIHksIHopO1xuICAgICAgaWYgKHRoaXMuX2Rlc3Ryb3llZCB8fCAhd2lkdGggfHwgIWhlaWdodCkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgbGV0IHJlc3VsdDtcbiAgICAgIGlmIChtdWx0aSB8fCBjb252ZXJ0VG9SR0IpIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICByZW5kZXJPcHRpb25zOiBtdWx0aSA/PyBbXCJyXCIsIFwiZ1wiLCBcImJcIl0ucmVkdWNlKChwcmUsIHZhbCwgaW5kZXgpID0+ICh7XG4gICAgICAgICAgICAuLi5wcmUsXG4gICAgICAgICAgICBbdmFsXToge1xuICAgICAgICAgICAgICBiYW5kOiBpbmRleCArIDEsXG4gICAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgICAgbWF4OiAyNTVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwge30pLFxuICAgICAgICAgIGJhbmRzOiB0aGlzLmJhbmRzLFxuICAgICAgICAgIG5vRGF0YTogdGhpcy5ub0RhdGEsXG4gICAgICAgICAgY29sb3JNYXBwaW5nOiBPYmplY3QuZW50cmllcyh0aGlzLnJlbmRlck9wdGlvbnMuY29sb3JNYXBwaW5nID8/IHsgXCJibGFja1wiOiBcInRyYW5zcGFyZW50XCIgfSkubWFwKCh2YWwpID0+IHZhbC5tYXAoc3RyaW5nQ29sb3JUb1JnYmEpKVxuICAgICAgICB9O1xuICAgICAgICByZXN1bHQgPSBhd2FpdCBnZW5lcmF0ZUltYWdlKG9wdHMpO1xuICAgICAgfSBlbHNlIGlmIChzaW5nbGUgJiYgdGhpcy5wbG90KSB7XG4gICAgICAgIGNvbnN0IHsgYmFuZCA9IDEgfSA9IHNpbmdsZTtcbiAgICAgICAgdGhpcy5wbG90LnJlbW92ZUFsbERhdGFzZXQoKTtcbiAgICAgICAgdGhpcy5yZWFkU2FtcGxlcy5mb3JFYWNoKChzYW1wbGUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgdGhpcy5wbG90LmFkZERhdGFzZXQoYGIke3NhbXBsZSArIDF9YCwgZGF0YVtpbmRleF0sIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHNpbmdsZS5leHByZXNzaW9uKSB7XG4gICAgICAgICAgdGhpcy5wbG90LnJlbmRlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGxvdC5yZW5kZXJEYXRhc2V0KGBiJHtiYW5kfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbnYgPSBjcmVhdGVDYW5hdmFzKHRoaXMudGlsZVdpZHRoLCB0aGlzLnRpbGVIZWlnaHQpO1xuICAgICAgICBjb25zdCBjdHggPSBjYW52LmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLnBsb3QuY2FudmFzLCAwLCAwKTtcbiAgICAgICAgcmVzdWx0ID0gY2FudjtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ltYWdlc0NhY2hlLnNpemUgPj0gdGhpcy5fY2FjaGVTaXplKSB7XG4gICAgICAgICAgY29uc3Qgb2xkZXN0S2V5ID0gdGhpcy5faW1hZ2VzQ2FjaGUua2V5cygpLm5leHQoKS52YWx1ZTtcbiAgICAgICAgICB0aGlzLl9pbWFnZXNDYWNoZS5kZWxldGUob2xkZXN0S2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbWFnZXNDYWNoZS5zZXQoY2FjaGVLZXksIHJlc3VsdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICB0aGlzLmVycm9yRXZlbnQucmFpc2VFdmVudChlKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG4gIGFzeW5jIHBpY2tGZWF0dXJlcyh4LCB5LCB6b29tLCBsb25naXR1ZGUsIGxhdGl0dWRlKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZW5hYmxlUGlja0ZlYXR1cmVzKVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICBjb25zdCB6ID0gem9vbSA+IHRoaXMubWF4aW11bUxldmVsID8gdGhpcy5tYXhpbXVtTGV2ZWwgOiB6b29tO1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5yZXF1ZXN0TGV2ZWxzW3pdO1xuICAgIGxldCBpbWFnZSA9IHRoaXMuX2ltYWdlc1tpbmRleF07XG4gICAgaWYgKCFpbWFnZSkge1xuICAgICAgaW1hZ2UgPSB0aGlzLl9pbWFnZXNbaW5kZXhdID0gYXdhaXQgdGhpcy5fc291cmNlLmdldEltYWdlKGluZGV4KTtcbiAgICB9XG4gICAgY29uc3Qgd2lkdGggPSBpbWFnZS5nZXRXaWR0aCgpO1xuICAgIGNvbnN0IGhlaWdodCA9IGltYWdlLmdldEhlaWdodCgpO1xuICAgIGxldCBwb3NYLCBwb3NZLCB3aW5kb3c7XG4gICAgY29uc3QgeyB3ZXN0LCBzb3V0aCwgbm9ydGgsIHdpZHRoOiBsb25XaWR0aCB9ID0gdGhpcy5yZWN0YW5nbGU7XG4gICAgbGV0IGxvbkdhcCA9IGxvbmdpdHVkZSAtIHdlc3Q7XG4gICAgaWYgKGxvbmdpdHVkZSA8IHdlc3QpIHtcbiAgICAgIGxvbkdhcCArPSBNYXRoJDEuVFdPX1BJO1xuICAgIH1cbiAgICBwb3NYID0gfn4oTWF0aC5hYnMobG9uR2FwIC8gbG9uV2lkdGgpICogd2lkdGgpO1xuICAgIHBvc1kgPSB+fihNYXRoLmFicygobm9ydGggLSBsYXRpdHVkZSkgLyAobm9ydGggLSBzb3V0aCkpICogaGVpZ2h0KTtcbiAgICB3aW5kb3cgPSBbcG9zWCwgcG9zWSwgcG9zWCArIDEsIHBvc1kgKyAxXTtcbiAgICBpZiAodGhpcy5yZXZlcnNlWSkge1xuICAgICAgcG9zWSA9IGhlaWdodCAtIHBvc1k7XG4gICAgICB3aW5kb3cgPSBbcG9zWCwgcG9zWSAtIDEsIHBvc1ggKyAxLCBwb3NZXTtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIHdpbmRvdyxcbiAgICAgIGhlaWdodDogMSxcbiAgICAgIHdpZHRoOiAxLFxuICAgICAgcG9vbDogdGhpcy5nZW90aWZmV29ya2VyUG9vbCxcbiAgICAgIGludGVybGVhdmU6IGZhbHNlXG4gICAgfTtcbiAgICBsZXQgcmVzO1xuICAgIGlmICh0aGlzLnJlbmRlck9wdGlvbnMuY29udmVydFRvUkdCKSB7XG4gICAgICByZXMgPSBhd2FpdCBpbWFnZS5yZWFkUkdCKG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSBhd2FpdCBpbWFnZS5yZWFkUmFzdGVycyhvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3QgZmVhdHVyZUluZm8gPSBuZXcgSW1hZ2VyeUxheWVyRmVhdHVyZUluZm8oKTtcbiAgICBmZWF0dXJlSW5mby5uYW1lID0gYGxvbjokeyhsb25naXR1ZGUgLyBNYXRoLlBJICogMTgwKS50b0ZpeGVkKDYpfSwgbGF0OiR7KGxhdGl0dWRlIC8gTWF0aC5QSSAqIDE4MCkudG9GaXhlZCg2KX1gO1xuICAgIGNvbnN0IGRhdGEgPSB7fTtcbiAgICByZXMgPT0gbnVsbCA/IHZvaWQgMCA6IHJlcy5mb3JFYWNoKChpdGVtLCBpbmRleDIpID0+IHtcbiAgICAgIGRhdGFbaW5kZXgyXSA9IGl0ZW0gPT0gbnVsbCA/IHZvaWQgMCA6IGl0ZW1bMF07XG4gICAgfSk7XG4gICAgZmVhdHVyZUluZm8uZGF0YSA9IGRhdGE7XG4gICAgaWYgKHJlcykge1xuICAgICAgZmVhdHVyZUluZm8uY29uZmlndXJlRGVzY3JpcHRpb25Gcm9tUHJvcGVydGllcyhkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIFtmZWF0dXJlSW5mb107XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHRoaXMuX2ltYWdlc0NhY2hlKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLl9pbWFnZXNDYWNoZSkge1xuICAgICAgICBkZWxldGUgdGhpcy5faW1hZ2VzQ2FjaGVba2V5XTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ltYWdlc0NhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLndvcmtlclBvb2wpIHtcbiAgICAgIHRoaXMud29ya2VyUG9vbC5kZXN0cm95KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnBsb3QgJiYgdGhpcy5wbG90LmdsKSB7XG4gICAgICBmb3IgKGNvbnN0IHByb2dyYW1LZXkgaW4gdGhpcy5wbG90LnByb2dyYW1DYWNoZSkge1xuICAgICAgICB0aGlzLnBsb3QuZ2wuZGVsZXRlUHJvZ3JhbSh0aGlzLnBsb3QucHJvZ3JhbUNhY2hlW3Byb2dyYW1LZXldKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGxvdC5nbC5kZWxldGVCdWZmZXIodGhpcy5wbG90LnBvc2l0aW9uQnVmZmVyKTtcbiAgICB9XG4gICAgKF9hID0gdGhpcy5wbG90KSA9PSBudWxsID8gdm9pZCAwIDogX2EuZGVzdHJveSgpO1xuICAgIHRoaXMuX2ltYWdlcyA9IFtdO1xuICAgIHRoaXMuX3NvdXJjZSA9IHZvaWQgMDtcbiAgICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG59XG5cbmV4cG9ydCB7IFRJRkZJbWFnZXJ5UHJvdmlkZXIsIGNvbG9yc2NhbGVzLCBUSUZGSW1hZ2VyeVByb3ZpZGVyIGFzIGRlZmF1bHQsIHJlbmRlckNvbG9yU2NhbGVUb0NhbnZhcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/terriajs-tiff-imagery-provider/dist/index.js\n");

/***/ })

}]);