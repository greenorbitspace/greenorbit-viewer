import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { action } from "mobx";
import { observer } from "mobx-react";
import Slider from "rc-slider";
import { useState } from "react";
import { useTranslation } from "react-i18next";
import styled from "styled-components";
import SplitDirection from "terriajs-cesium/Source/Scene/SplitDirection";
import MappableMixin from "../../../ModelMixins/MappableMixin";
import Cesium from "../../../Models/Cesium";
import ViewerMode, { MapViewers, setViewerMode } from "../../../Models/ViewerMode";
import Box from "../../../Styled/Box";
import Button, { RawButton } from "../../../Styled/Button";
import Checkbox from "../../../Styled/Checkbox";
import { GLYPHS, StyledIcon } from "../../../Styled/Icon";
import Spacing from "../../../Styled/Spacing";
import Text, { TextSpan } from "../../../Styled/Text";
import { useViewState } from "../../Context";
import { useRefForTerria } from "../../Hooks/useRefForTerria";
import MenuPanel from "../../StandardUserInterface/customizable/MenuPanel";
import Styles from "./setting-panel.scss";
const sides = {
    left: "settingPanel.terrain.left",
    both: "settingPanel.terrain.both",
    right: "settingPanel.terrain.right"
};
const SettingPanel = observer(() => {
    const { t } = useTranslation();
    const viewState = useViewState();
    const { terria } = viewState;
    const settingButtonRef = useRefForTerria(SETTING_PANEL_NAME, viewState);
    const [hoverBaseMap, setHoverBaseMap] = useState(null);
    const activeMapName = hoverBaseMap
        ? hoverBaseMap
        : terria.mainViewer.baseMap
            ? terria.mainViewer.baseMap.name
            : "(None)";
    const selectBaseMap = (baseMap, event) => {
        event.stopPropagation();
        if (!MappableMixin.isMixedInto(baseMap))
            return;
        terria.mainViewer.setBaseMap(baseMap);
        // We store the user's chosen basemap for future use, but it's up to the instance to decide
        // whether to use that at start up.
        if (baseMap) {
            const baseMapId = baseMap.uniqueId;
            if (baseMapId) {
                terria.setLocalProperty("basemap", baseMapId);
            }
        }
    };
    const mouseEnterBaseMap = (baseMap) => {
        var _a;
        setHoverBaseMap((_a = baseMap.item) === null || _a === void 0 ? void 0 : _a.name);
    };
    const mouseLeaveBaseMap = () => {
        setHoverBaseMap(null);
    };
    const selectViewer = action((viewer, event) => {
        const mainViewer = terria.mainViewer;
        event.stopPropagation();
        showTerrainOnSide(sides.both, undefined);
        setViewerMode(viewer, mainViewer);
        // We store the user's chosen viewer mode for future use.
        terria.setLocalProperty("viewermode", viewer);
        terria.currentViewer.notifyRepaintRequired();
    });
    const showTerrainOnSide = action((side, event) => {
        event === null || event === void 0 ? void 0 : event.stopPropagation();
        switch (side) {
            case sides.left:
                terria.terrainSplitDirection = SplitDirection.LEFT;
                terria.showSplitter = true;
                break;
            case sides.right:
                terria.terrainSplitDirection = SplitDirection.RIGHT;
                terria.showSplitter = true;
                break;
            case sides.both:
                terria.terrainSplitDirection = SplitDirection.NONE;
                break;
        }
        terria.currentViewer.notifyRepaintRequired();
    });
    const toggleDepthTestAgainstTerrainEnabled = action((event) => {
        event.stopPropagation();
        terria.depthTestAgainstTerrainEnabled =
            !terria.depthTestAgainstTerrainEnabled;
        terria.currentViewer.notifyRepaintRequired();
    });
    const onBaseMaximumScreenSpaceErrorChange = (bmsse) => {
        terria.setBaseMaximumScreenSpaceError(bmsse);
        terria.setLocalProperty("baseMaximumScreenSpaceError", bmsse.toString());
    };
    const toggleUseNativeResolution = () => {
        terria.setUseNativeResolution(!terria.useNativeResolution);
        terria.setLocalProperty("useNativeResolution", terria.useNativeResolution);
    };
    const qualityLabels = {
        0: t("settingPanel.qualityLabels.maximumPerformance"),
        1: t("settingPanel.qualityLabels.balancedPerformance"),
        2: t("settingPanel.qualityLabels.lowerPerformance")
    };
    const currentViewer = terria.mainViewer.viewerMode === ViewerMode.Cesium
        ? terria.mainViewer.viewerOptions.useTerrain
            ? "3d"
            : "3dsmooth"
        : "2d";
    const useNativeResolution = terria.useNativeResolution;
    const nativeResolutionLabel = t("settingPanel.nativeResolutionLabel", {
        resolution1: useNativeResolution
            ? t("settingPanel.native")
            : t("settingPanel.screen"),
        resolution2: useNativeResolution
            ? t("settingPanel.screen")
            : t("settingPanel.native")
    });
    const dropdownTheme = {
        inner: Styles.dropdownInner,
        icon: "map"
    };
    const isCesiumWithTerrain = terria.mainViewer.viewerMode === ViewerMode.Cesium &&
        terria.mainViewer.viewerOptions.useTerrain &&
        terria.currentViewer &&
        terria.currentViewer instanceof Cesium &&
        terria.currentViewer.scene &&
        terria.currentViewer.scene.globe;
    const supportsDepthTestAgainstTerrain = isCesiumWithTerrain;
    const depthTestAgainstTerrainEnabled = supportsDepthTestAgainstTerrain && terria.depthTestAgainstTerrainEnabled;
    const depthTestAgainstTerrainLabel = depthTestAgainstTerrainEnabled
        ? t("settingPanel.terrain.showUndergroundFeatures")
        : t("settingPanel.terrain.hideUndergroundFeatures");
    if (terria.configParameters.useCesiumIonTerrain ||
        terria.configParameters.cesiumTerrainUrl) {
        MapViewers["3d"].available = true;
    }
    const supportsSide = isCesiumWithTerrain;
    let currentSide = sides.both;
    if (supportsSide) {
        switch (terria.terrainSplitDirection) {
            case SplitDirection.LEFT:
                currentSide = sides.left;
                break;
            case SplitDirection.RIGHT:
                currentSide = sides.right;
                break;
        }
    }
    const timelineStack = terria.timelineStack;
    const alwaysShowTimelineLabel = timelineStack.alwaysShowingTimeline
        ? t("settingPanel.timeline.alwaysShowLabel")
        : t("settingPanel.timeline.hideLabel");
    return (
    //@ts-expect-error - not yet ready to tackle tsfying MenuPanel
    _jsx(MenuPanel, { theme: dropdownTheme, btnRef: settingButtonRef, btnTitle: t("settingPanel.btnTitle"), btnText: t("settingPanel.btnText"), viewState: viewState, smallScreen: viewState.useSmallScreenInterface, children: _jsxs(Box, { padded: true, column: true, children: [_jsx(Box, { paddedVertically: 1, children: _jsx(Text, { as: "label", children: t("settingPanel.mapView") }) }), _jsx(FlexGrid, { gap: 1, elementsNo: 3, children: Object.entries(MapViewers).map(([key, viewerMode]) => (_jsx(SettingsButton, { isActive: key === currentViewer, onClick: (event) => selectViewer(key, event), children: _jsx(Text, { mini: true, children: t(viewerMode.label) }) }, key))) }), !!supportsSide && (_jsxs(_Fragment, { children: [_jsx(Spacing, { bottom: 2 }), _jsxs(Box, { column: true, children: [_jsx(Box, { paddedVertically: 1, children: _jsx(Text, { as: "label", children: t("settingPanel.terrain.sideLabel") }) }), _jsx(FlexGrid, { gap: 1, elementsNo: 3, children: Object.values(sides).map((side) => (_jsx(SettingsButton, { isActive: side === currentSide, onClick: (event) => showTerrainOnSide(side, event), children: _jsx(Text, { mini: true, children: t(side) }) }, side))) })] }), !!supportsDepthTestAgainstTerrain && (_jsxs(_Fragment, { children: [_jsx(Spacing, { bottom: 2 }), _jsx(Checkbox, { textProps: { small: true }, id: "depthTestAgainstTerrain", title: depthTestAgainstTerrainLabel, isChecked: depthTestAgainstTerrainEnabled, onChange: toggleDepthTestAgainstTerrainEnabled, children: _jsx(TextSpan, { children: t("settingPanel.terrain.hideUnderground") }) })] }))] })), _jsxs(_Fragment, { children: [_jsx(Spacing, { bottom: 2 }), _jsxs(Box, { column: true, children: [_jsx(Box, { paddedVertically: 1, children: _jsx(Text, { as: "label", children: t("settingPanel.baseMap") }) }), _jsx(Box, { paddedVertically: 1, children: _jsx(Text, { as: "label", mini: true, children: activeMapName }) }), _jsx(FlexGrid, { gap: 1, elementsNo: 4, children: terria.baseMapsModel.baseMapItems.map((baseMap) => {
                                        var _a;
                                        return (_jsxs(StyledBasemapButton, { isActive: baseMap.item === terria.mainViewer.baseMap, onClick: (event) => selectBaseMap(baseMap.item, event), onMouseEnter: () => mouseEnterBaseMap(baseMap), onMouseLeave: mouseLeaveBaseMap, onFocus: () => mouseEnterBaseMap(baseMap), children: [baseMap.item === terria.mainViewer.baseMap ? (_jsx(Box, { position: "absolute", topRight: true, children: _jsx(StyledIcon, { light: true, glyph: GLYPHS.selected, styledWidth: "22px" }) })) : null, _jsx(StyledImage, { fullWidth: true, alt: baseMap.item ? baseMap.item.name : "", src: baseMap.image })] }, (_a = baseMap.item) === null || _a === void 0 ? void 0 : _a.uniqueId));
                                    }) })] })] }), _jsxs(_Fragment, { children: [_jsx(Spacing, { bottom: 2 }), _jsxs(Box, { column: true, children: [_jsx(Box, { paddedVertically: 1, children: _jsx(Text, { as: "label", children: t("settingPanel.timeline.title") }) }), _jsx(Checkbox, { textProps: { small: true }, id: "alwaysShowTimeline", isChecked: timelineStack.alwaysShowingTimeline, title: alwaysShowTimelineLabel, onChange: () => {
                                        timelineStack.setAlwaysShowTimeline(!timelineStack.alwaysShowingTimeline);
                                    }, children: _jsx(TextSpan, { children: t("settingPanel.timeline.alwaysShow") }) })] })] }), terria.mainViewer.viewerMode !== ViewerMode.Leaflet && (_jsxs(_Fragment, { children: [_jsx(Spacing, { bottom: 2 }), _jsxs(Box, { column: true, children: [_jsx(Box, { paddedVertically: 1, children: _jsx(Text, { as: "label", children: t("settingPanel.imageOptimisation") }) }), _jsx(Checkbox, { textProps: { small: true }, id: "mapUseNativeResolution", isChecked: useNativeResolution, title: nativeResolutionLabel, onChange: () => toggleUseNativeResolution(), children: _jsx(TextSpan, { children: t("settingPanel.nativeResolutionHeader") }) }), _jsx(Spacing, { bottom: 2 }), _jsx(Box, { paddedVertically: 1, children: _jsx(Text, { as: "label", children: t("settingPanel.mapQuality") }) }), _jsxs(Box, { verticalCenter: true, children: [_jsx(Text, { mini: true, children: t("settingPanel.qualityLabel") }), _jsx(Slider, { min: 1, max: 3, step: 0.1, value: terria.baseMaximumScreenSpaceError, onChange: (val) => onBaseMaximumScreenSpaceErrorChange(val), marks: { 2: "" }, "aria-valuetext": qualityLabels, css: `
                    margin: 0 10px;
                    margin-top: 5px;
                  ` }), _jsx(Text, { mini: true, children: t("settingPanel.performanceLabel") })] })] })] }))] }) }));
});
export const SETTING_PANEL_NAME = "MenuBarMapSettingsButton";
export default SettingPanel;
const FlexGrid = styled(Box).attrs({ flexWrap: true }) `
  gap: ${(props) => props.gap * 5}px;
  > * {
    flex: ${(props) => `1 0 ${getCalcWidth(props.elementsNo, props.gap)}`};
    max-width: ${(props) => getCalcWidth(props.elementsNo, props.gap)};
  }
`;
const getCalcWidth = (elementsNo, gap) => `calc(${100 / elementsNo}% - ${gap * 5}px)`;
const SettingsButton = styled(Button) `
  background-color: ${(props) => props.theme.overlay};
  border: 1px solid
    ${(props) => (props.isActive ? "rgba(255, 255, 255, 0.5)" : "transparent")};
`;
const StyledBasemapButton = styled(RawButton) `
  border-radius: 4px;
  position: relative;
  border: 2px solid
    ${(props) => props.isActive ? props.theme.turquoiseBlue : "rgba(255, 255, 255, 0.5)"};
`;
const StyledImage = styled(Box).attrs({
    as: "img"
}) `
  border-radius: inherit;
`;
//# sourceMappingURL=SettingPanel.js.map