var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import i18next from "i18next";
import { computed, makeObservable } from "mobx";
import proj4 from "proj4";
import URI from "urijs";
import isDefined from "../../../Core/isDefined";
import loadJson from "../../../Core/loadJson";
import replaceUnderscores from "../../../Core/replaceUnderscores";
import Proj4Definitions from "../../../Map/Vector/Proj4Definitions";
import { hasUnsupportedStylesForProtomaps } from "../../../Map/Vector/Protomaps/tableStyleToProtomaps";
import ArcGisFeatureServerCatalogItemTraits from "../../../Traits/TraitsClasses/ArcGisFeatureServerCatalogItemTraits";
import { InfoSectionTraits } from "../../../Traits/TraitsClasses/CatalogMemberTraits";
import { RectangleTraits } from "../../../Traits/TraitsClasses/MappableTraits";
import TableColorStyleTraits, { EnumColorTraits } from "../../../Traits/TraitsClasses/Table/ColorStyleTraits";
import TableColumnTraits from "../../../Traits/TraitsClasses/Table/ColumnTraits";
import TableOutlineStyleTraits, { BinOutlineSymbolTraits, EnumOutlineSymbolTraits } from "../../../Traits/TraitsClasses/Table/OutlineStyleTraits";
import TablePointSizeStyleTraits from "../../../Traits/TraitsClasses/Table/PointSizeStyleTraits";
import TablePointStyleTraits, { BinPointSymbolTraits, EnumPointSymbolTraits } from "../../../Traits/TraitsClasses/Table/PointStyleTraits";
import TableStyleTraits from "../../../Traits/TraitsClasses/Table/StyleTraits";
import createStratumInstance from "../../Definition/createStratumInstance";
import LoadableStratum from "../../Definition/LoadableStratum";
import StratumOrder from "../../Definition/StratumOrder";
import proxyCatalogItemUrl from "../proxyCatalogItemUrl";
import { esriStyleToTableStyle } from "./esriStyleToTableStyle";
const fieldTypeToTableColumn = {
    esriFieldTypeSmallInteger: "scalar",
    esriFieldTypeInteger: "scalar",
    esriFieldTypeSingle: "scalar",
    esriFieldTypeDouble: "scalar",
    esriFieldTypeString: "text",
    esriFieldTypeDate: "time",
    esriFieldTypeOID: "scalar",
    esriFieldTypeGeometry: "hidden",
    esriFieldTypeBlob: "hidden",
    esriFieldTypeRaster: "hidden",
    esriFieldTypeGUID: "hidden",
    esriFieldTypeGlobalID: "hidden",
    esriFieldTypeXML: "hidden",
    esriFieldTypeBigInteger: "scalar"
};
export class ArcGisFeatureServerStratum extends LoadableStratum(ArcGisFeatureServerCatalogItemTraits) {
    constructor(_item, _featureServer) {
        super();
        Object.defineProperty(this, "_item", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _item
        });
        Object.defineProperty(this, "_featureServer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _featureServer
        });
        makeObservable(this);
    }
    duplicateLoadableStratum(newModel) {
        return new ArcGisFeatureServerStratum(newModel, this._featureServer);
    }
    static async load(item) {
        if (item.url === undefined) {
            return new ArcGisFeatureServerStratum(item, undefined);
        }
        const metaUrl = buildMetadataUrl(item);
        const featureServer = await loadJson(metaUrl);
        return new ArcGisFeatureServerStratum(item, featureServer);
    }
    get shortReport() {
        var _a;
        // Show notice if reached
        if (((_a = this._item.readyData) === null || _a === void 0 ? void 0 : _a.features) !== undefined &&
            this._item.readyData.features.length >= this._item.maxFeatures) {
            return i18next.t("models.arcGisFeatureServerCatalogItem.reachedMaxFeatureLimit", this._item);
        }
        return undefined;
    }
    get maxScaleDenominator() {
        var _a;
        return (_a = this._featureServer) === null || _a === void 0 ? void 0 : _a.minScale;
    }
    get minScaleDenominator() {
        var _a;
        return (_a = this._featureServer) === null || _a === void 0 ? void 0 : _a.maxScale;
    }
    get name() {
        var _a;
        if (((_a = this._featureServer) === null || _a === void 0 ? void 0 : _a.name) !== undefined &&
            this._featureServer.name.length > 0) {
            return replaceUnderscores(this._featureServer.name);
        }
    }
    get dataCustodian() {
        var _a, _b, _c;
        if (((_a = this._featureServer) === null || _a === void 0 ? void 0 : _a.documentInfo) &&
            ((_b = this._featureServer) === null || _b === void 0 ? void 0 : _b.documentInfo.Author) &&
            ((_c = this._featureServer) === null || _c === void 0 ? void 0 : _c.documentInfo.Author.length) > 0) {
            return this._featureServer.documentInfo.Author;
        }
    }
    get rectangle() {
        var _a, _b, _c, _d;
        const extent = (_a = this._featureServer) === null || _a === void 0 ? void 0 : _a.extent;
        const wkidCode = (_c = (_b = extent === null || extent === void 0 ? void 0 : extent.spatialReference) === null || _b === void 0 ? void 0 : _b.latestWkid) !== null && _c !== void 0 ? _c : (_d = extent === null || extent === void 0 ? void 0 : extent.spatialReference) === null || _d === void 0 ? void 0 : _d.wkid;
        if (isDefined(extent) && isDefined(wkidCode)) {
            const wkid = "EPSG:" + wkidCode;
            if (!isDefined(Proj4Definitions[wkid])) {
                return undefined;
            }
            const source = Proj4Definitions[wkid];
            const dest = "EPSG:4326";
            let p = proj4(source, dest, [extent.xmin, extent.ymin]);
            const west = p[0];
            const south = p[1];
            p = proj4(source, dest, [extent.xmax, extent.ymax]);
            const east = p[0];
            const north = p[1];
            const rectangle = { west: west, south: south, east: east, north: north };
            return createStratumInstance(RectangleTraits, rectangle);
        }
        return undefined;
    }
    get info() {
        var _a, _b;
        return [
            createStratumInstance(InfoSectionTraits, {
                name: i18next.t("models.arcGisMapServerCatalogItem.dataDescription"),
                content: (_a = this._featureServer) === null || _a === void 0 ? void 0 : _a.description
            }),
            createStratumInstance(InfoSectionTraits, {
                name: i18next.t("models.arcGisMapServerCatalogItem.copyrightText"),
                content: (_b = this._featureServer) === null || _b === void 0 ? void 0 : _b.copyrightText
            })
        ];
    }
    get supportsPagination() {
        if (this._featureServer === undefined ||
            this._featureServer.advancedQueryCapabilities === undefined) {
            return false;
        }
        return !!this._featureServer.advancedQueryCapabilities.supportsPagination;
    }
    get activeStyle() {
        return "ESRI";
    }
    get styles() {
        var _a, _b, _c, _d, _e, _f;
        const renderer = (_b = (_a = this._featureServer) === null || _a === void 0 ? void 0 : _a.drawingInfo) === null || _b === void 0 ? void 0 : _b.renderer;
        if (!renderer)
            return [];
        const rendererType = renderer.type;
        if (rendererType === "simple") {
            const simpleRenderer = renderer;
            const symbol = simpleRenderer.symbol;
            if ((_c = simpleRenderer.visualVariables) === null || _c === void 0 ? void 0 : _c.length) {
                console.warn(`WARNING: Terria does not support visual variables in ArcGisFeatureService SimpleRenderers`);
            }
            if (!symbol)
                return [];
            const symbolStyle = esriStyleToTableStyle(symbol, simpleRenderer.label);
            return [
                createStratumInstance(TableStyleTraits, {
                    id: "ESRI",
                    hidden: false,
                    color: createStratumInstance(TableColorStyleTraits, {
                        nullColor: (_d = symbolStyle.color) !== null && _d !== void 0 ? _d : "#ffffff"
                    }),
                    pointSize: symbolStyle.pointSize,
                    point: createStratumInstance(TablePointStyleTraits, {
                        null: symbolStyle.point
                    }),
                    outline: createStratumInstance(TableOutlineStyleTraits, {
                        null: symbolStyle.outline
                    })
                })
            ];
        }
        else if (rendererType === "uniqueValue") {
            const uniqueValueRenderer = renderer;
            const symbolStyles = uniqueValueRenderer.uniqueValueInfos.map((v) => {
                return esriStyleToTableStyle(v.symbol, v.label);
            });
            const defaultSymbolStyle = esriStyleToTableStyle(uniqueValueRenderer.defaultSymbol, undefined);
            // Only include color if there are any styles which aren't esriPMS
            const includeColor = !!uniqueValueRenderer.uniqueValueInfos.find((u) => { var _a; return ((_a = u.symbol) === null || _a === void 0 ? void 0 : _a.type) !== "esriPMS"; });
            if (uniqueValueRenderer.field2 || uniqueValueRenderer.field3) {
                console.warn(`WARNING: Terria only supports ArcGisFeatureService UniqueValueRenderers with a single field (\`field1\`), not multiple fields (\`field2\` or \`field3\`)`);
            }
            if ((_e = uniqueValueRenderer.visualVariables) === null || _e === void 0 ? void 0 : _e.length) {
                console.warn(`WARNING: Terria does not support visual variables in ArcGisFeatureService UniqueValueRenderers`);
            }
            if (uniqueValueRenderer.valueExpression) {
                console.warn(`WARNING: Terria does not support value expressions in ArcGisFeatureService UniqueValueRenderers`);
            }
            if (!uniqueValueRenderer.field1) {
                console.warn(`WARNING: Terria does not support empty field1 in UniqueValueRenderers, using default style`);
                return [];
            }
            return [
                createStratumInstance(TableStyleTraits, {
                    id: "ESRI",
                    hidden: false,
                    color: includeColor
                        ? createStratumInstance(TableColorStyleTraits, {
                            colorColumn: uniqueValueRenderer.field1,
                            mapType: "enum",
                            enumColors: uniqueValueRenderer.uniqueValueInfos.map((v, i) => {
                                var _a;
                                return createStratumInstance(EnumColorTraits, {
                                    value: v.value,
                                    color: (_a = symbolStyles[i].color) !== null && _a !== void 0 ? _a : "#ffffff"
                                });
                            }),
                            nullColor: defaultSymbolStyle.color
                        })
                        : createStratumInstance(TableColorStyleTraits, {
                            nullColor: "#FFFFFF"
                        }),
                    pointSize: createStratumInstance(TablePointSizeStyleTraits, {}),
                    point: createStratumInstance(TablePointStyleTraits, {
                        mapType: "enum",
                        column: uniqueValueRenderer.field1,
                        enum: uniqueValueRenderer.uniqueValueInfos.map((v, i) => createStratumInstance(EnumPointSymbolTraits, {
                            value: v.value,
                            ...symbolStyles[i].point
                        })),
                        null: defaultSymbolStyle.point
                    }),
                    outline: createStratumInstance(TableOutlineStyleTraits, {
                        mapType: "enum",
                        column: uniqueValueRenderer.field1,
                        enum: uniqueValueRenderer.uniqueValueInfos.map((v, i) => createStratumInstance(EnumOutlineSymbolTraits, {
                            value: v.value,
                            ...symbolStyles[i].outline
                        })),
                        null: defaultSymbolStyle.outline
                    })
                })
            ];
        }
        else if (rendererType === "classBreaks") {
            const classBreaksRenderer = renderer;
            if ((_f = classBreaksRenderer.visualVariables) === null || _f === void 0 ? void 0 : _f.length) {
                console.warn(`WARNING: Terria does not support visual variables in ArcGisFeatureService ClassBreakRenderers`);
            }
            if (classBreaksRenderer.valueExpression) {
                console.warn(`WARNING: Terria does not support value expressions in ArcGisFeatureService ClassBreakRenderers`);
            }
            const symbolStyles = classBreaksRenderer.classBreakInfos.map((c) => esriStyleToTableStyle(c.symbol, c.label));
            const defaultSymbolStyle = esriStyleToTableStyle(classBreaksRenderer.defaultSymbol, undefined);
            // Only include color if there are any styles which aren't esriPMS
            const includeColor = !!classBreaksRenderer.classBreakInfos.find((u) => { var _a; return ((_a = u.symbol) === null || _a === void 0 ? void 0 : _a.type) !== "esriPMS"; });
            return [
                createStratumInstance(TableStyleTraits, {
                    id: "ESRI",
                    hidden: false,
                    color: includeColor
                        ? createStratumInstance(TableColorStyleTraits, {
                            mapType: "bin",
                            colorColumn: classBreaksRenderer.field,
                            binColors: symbolStyles.map((s) => { var _a; return (_a = s.color) !== null && _a !== void 0 ? _a : ""; }),
                            binMaximums: classBreaksRenderer.classBreakInfos.map((c) => c.classMaxValue),
                            nullColor: defaultSymbolStyle.color
                        })
                        : createStratumInstance(TableColorStyleTraits, {
                            nullColor: "#FFFFFF"
                        }),
                    pointSize: createStratumInstance(TablePointSizeStyleTraits, {}),
                    point: createStratumInstance(TablePointStyleTraits, {
                        mapType: "bin",
                        column: classBreaksRenderer.field,
                        bin: classBreaksRenderer.classBreakInfos.map((c, i) => createStratumInstance(BinPointSymbolTraits, {
                            maxValue: c.classMaxValue,
                            ...symbolStyles[i].point
                        })),
                        null: defaultSymbolStyle.point
                    }),
                    outline: createStratumInstance(TableOutlineStyleTraits, {
                        mapType: "bin",
                        column: classBreaksRenderer.field,
                        bin: classBreaksRenderer.classBreakInfos.map((c, i) => createStratumInstance(BinOutlineSymbolTraits, {
                            maxValue: c.classMaxValue,
                            ...symbolStyles[i].outline
                        })),
                        null: defaultSymbolStyle.outline
                    })
                })
            ];
        }
        else {
            console.warn(`WARNING: Terria does not support ArcGisFeatureService renderers of type ${rendererType}`);
        }
    }
    // Map ESRI fields to Terria columns. This just sets the name, title and type of the column
    get columns() {
        var _a, _b, _c;
        return ((_c = (_b = (_a = this._featureServer) === null || _a === void 0 ? void 0 : _a.fields) === null || _b === void 0 ? void 0 : _b.filter((field) => {
            if (!fieldTypeToTableColumn[field.type]) {
                console.warn(`WARNING: Terria does not support ESRI field type ${field.type}`);
                return false;
            }
            return true;
        }).map((field) => {
            var _a;
            return createStratumInstance(TableColumnTraits, {
                name: field.name,
                title: field.alias,
                type: (_a = fieldTypeToTableColumn[field.type]) === null || _a === void 0 ? void 0 : _a.toString()
            });
        })) !== null && _c !== void 0 ? _c : []);
    }
    get featuresPerRequest() {
        var _a;
        return (_a = this._featureServer) === null || _a === void 0 ? void 0 : _a.maxRecordCount;
    }
    get featuresPerTileRequest() {
        var _a;
        return (_a = this._featureServer) === null || _a === void 0 ? void 0 : _a.tileMaxRecordCount;
    }
    get maxRecordCountFactor() {
        var _a;
        return (_a = this._featureServer) === null || _a === void 0 ? void 0 : _a.maxRecordCountFactor;
    }
    get supportsQuantization() {
        var _a;
        return !!((_a = this._featureServer) === null || _a === void 0 ? void 0 : _a.supportsCoordinatesQuantization);
    }
    /** Enable tileRequests by default if supported and no unsupported point/label styles are used */
    get tileRequests() {
        var _a, _b;
        if (this._item.forceCesiumPrimitives)
            return false;
        const supportsPbfTiles = ((_a = this._featureServer) === null || _a === void 0 ? void 0 : _a.supportsTilesAndBasicQueriesMode) &&
            typeof ((_b = this._featureServer) === null || _b === void 0 ? void 0 : _b.supportedQueryFormats) === "string" &&
            this._featureServer.supportedQueryFormats
                .toLowerCase()
                .includes("pbf");
        if (supportsPbfTiles) {
            return !hasUnsupportedStylesForProtomaps(this._item);
        }
        return undefined;
    }
    get objectIdField() {
        var _a;
        return (_a = this._featureServer) === null || _a === void 0 ? void 0 : _a.objectIdField;
    }
    // Add properties/columns to outFields if they are needed for styling. Otherwise, these properties won't be in tile features
    get outFields() {
        var _a, _b;
        return Array.from(new Set([
            this._item.objectIdField,
            this._item.activeTableStyle.tableColorMap.colorTraits.colorColumn,
            (_a = this._item.activeTableStyle.outlineStyleMap.traits) === null || _a === void 0 ? void 0 : _a.column,
            (_b = this._item.activeTableStyle.pointStyleMap.traits) === null || _b === void 0 ? void 0 : _b.column
        ])).filter((t) => !!t);
    }
}
Object.defineProperty(ArcGisFeatureServerStratum, "stratumName", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "featureServer"
});
__decorate([
    computed
], ArcGisFeatureServerStratum.prototype, "shortReport", null);
__decorate([
    computed
], ArcGisFeatureServerStratum.prototype, "maxScaleDenominator", null);
__decorate([
    computed
], ArcGisFeatureServerStratum.prototype, "minScaleDenominator", null);
__decorate([
    computed
], ArcGisFeatureServerStratum.prototype, "name", null);
__decorate([
    computed
], ArcGisFeatureServerStratum.prototype, "dataCustodian", null);
__decorate([
    computed
], ArcGisFeatureServerStratum.prototype, "rectangle", null);
__decorate([
    computed
], ArcGisFeatureServerStratum.prototype, "info", null);
__decorate([
    computed
], ArcGisFeatureServerStratum.prototype, "supportsPagination", null);
__decorate([
    computed
], ArcGisFeatureServerStratum.prototype, "activeStyle", null);
__decorate([
    computed
], ArcGisFeatureServerStratum.prototype, "styles", null);
__decorate([
    computed
], ArcGisFeatureServerStratum.prototype, "columns", null);
__decorate([
    computed
], ArcGisFeatureServerStratum.prototype, "tileRequests", null);
__decorate([
    computed
], ArcGisFeatureServerStratum.prototype, "outFields", null);
function buildMetadataUrl(catalogItem) {
    return proxyCatalogItemUrl(catalogItem, new URI(catalogItem.url).addQuery("f", "json").toString());
}
StratumOrder.addLoadStratum(ArcGisFeatureServerStratum.stratumName);
//# sourceMappingURL=ArcGisFeatureServerStratum.js.map