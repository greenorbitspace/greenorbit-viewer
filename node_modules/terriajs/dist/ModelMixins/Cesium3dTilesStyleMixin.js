var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import Cesium3DTileStyle from "terriajs-cesium/Source/Scene/Cesium3DTileStyle";
import isDefined from "../Core/isDefined";
import Cesium3dTilesTraits from "../Traits/TraitsClasses/Cesium3dTilesTraits";
import clone from "terriajs-cesium/Source/Core/clone";
import { computed, makeObservable, override, runInAction, toJS } from "mobx";
import Color from "terriajs-cesium/Source/Core/Color";
import LoadableStratum from "../Models/Definition/LoadableStratum";
import StratumOrder from "../Models/Definition/StratumOrder";
class Cesium3dTilesStyleStratum extends LoadableStratum(Cesium3dTilesTraits) {
    constructor(...args) {
        super(...args);
        makeObservable(this);
    }
    duplicateLoadableStratum(model) {
        return new Cesium3dTilesStyleStratum(model);
    }
    get opacity() {
        return 1.0;
    }
}
__decorate([
    computed
], Cesium3dTilesStyleStratum.prototype, "opacity", null);
// Register the I3SStratum
StratumOrder.instance.addLoadStratum(Cesium3dTilesStyleStratum.name);
const DEFAULT_HIGHLIGHT_COLOR = "#ff3f00";
function Cesium3dTilesStyleMixin(Base) {
    class Cesium3dTilesStyleMixin extends Base {
        constructor(...args) {
            super(...args);
            makeObservable(this);
            runInAction(() => {
                this.strata.set(Cesium3dTilesStyleStratum.name, new Cesium3dTilesStyleStratum());
            });
        }
        get hasCesium3dTilesStyleMixin() {
            return true;
        }
        /**
         * The color to use for highlighting features in this catalog item.
         *
         */
        get highlightColor() {
            return super.highlightColor || DEFAULT_HIGHLIGHT_COLOR;
        }
        get showExpressionFromFilters() {
            if (!isDefined(this.filters)) {
                return;
            }
            const terms = this.filters.map((filter) => {
                if (!isDefined(filter.property)) {
                    return "";
                }
                // Escape single quotes, cast property value to number
                const property = "Number(${feature['" + filter.property.replace(/'/g, "\\'") + "']})";
                const min = isDefined(filter.minimumValue) &&
                    isDefined(filter.minimumShown) &&
                    filter.minimumShown > filter.minimumValue
                    ? property + " >= " + filter.minimumShown
                    : "";
                const max = isDefined(filter.maximumValue) &&
                    isDefined(filter.maximumShown) &&
                    filter.maximumShown < filter.maximumValue
                    ? property + " <= " + filter.maximumShown
                    : "";
                return [min, max].filter((x) => x.length > 0).join(" && ");
            });
            const showExpression = terms.filter((x) => x.length > 0).join("&&");
            if (showExpression.length > 0) {
                return showExpression;
            }
        }
        get cesiumTileStyle() {
            if (!isDefined(this.style) &&
                (!isDefined(this.opacity) || this.opacity === 1) &&
                !isDefined(this.showExpressionFromFilters)) {
                return;
            }
            const style = clone(toJS(this.style) || {});
            const opacity = clone(toJS(this.opacity));
            if (!isDefined(style.defines)) {
                style.defines = { opacity };
            }
            else {
                style.defines = Object.assign(style.defines, { opacity });
            }
            // Rewrite color expression to also use the models opacity setting
            if (!isDefined(style.color)) {
                // Some tilesets (eg. point clouds) have a ${COLOR} variable which
                // stores the current color of a feature, so if we have that, we should
                // use it, and only change the opacity.  We have to do it
                // component-wise because `undefined` is mapped to a large float value
                // (czm_infinity) in glsl in Cesium and so can only be compared with
                // another float value.
                //
                // There is also a subtle bug which prevents us from using an
                // expression in the alpha part of the rgba().  eg, using the
                // expression '${COLOR}.a === undefined ? ${opacity} : ${COLOR}.a * ${opacity}'
                // to generate an opacity value will cause Cesium to generate wrong
                // translucency values making the tileset translucent even when the
                // computed opacity is 1.0. It also makes the whole of the point cloud
                // appear white when zoomed out to some distance.  So for now, the only
                // solution is to discard the opacity from the tileset and only use the
                // value from the opacity trait.
                style.color =
                    "(rgba(" +
                        "(${COLOR}.r === undefined ? 1 : ${COLOR}.r) * 255," +
                        "(${COLOR}.g === undefined ? 1 : ${COLOR}.g) * 255," +
                        "(${COLOR}.b === undefined ? 1 : ${COLOR}.b) * 255," +
                        "${opacity}" +
                        "))";
            }
            else if (typeof style.color === "string") {
                // Check if the color specified is just a css color
                const cssColor = Color.fromCssColorString(style.color);
                if (isDefined(cssColor)) {
                    style.color = `color('${style.color}', \${opacity})`;
                }
            }
            if (isDefined(this.showExpressionFromFilters)) {
                style.show = toJS(this.showExpressionFromFilters);
            }
            return new Cesium3DTileStyle(style);
        }
    }
    __decorate([
        override
    ], Cesium3dTilesStyleMixin.prototype, "highlightColor", null);
    __decorate([
        computed
    ], Cesium3dTilesStyleMixin.prototype, "showExpressionFromFilters", null);
    __decorate([
        computed
    ], Cesium3dTilesStyleMixin.prototype, "cesiumTileStyle", null);
    return Cesium3dTilesStyleMixin;
}
(function (Cesium3dTilesStyleMixin) {
    function isMixedInto(model) {
        return model && model.hasCesium3dTilesStyleMixin;
    }
    Cesium3dTilesStyleMixin.isMixedInto = isMixedInto;
})(Cesium3dTilesStyleMixin || (Cesium3dTilesStyleMixin = {}));
export default Cesium3dTilesStyleMixin;
//# sourceMappingURL=Cesium3dTilesStyleMixin.js.map