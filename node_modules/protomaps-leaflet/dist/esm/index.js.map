{"version":3,"sources":["../../src/frontends/static.ts","../../src/default_style/style.ts","../../src/symbolizer.ts","../../src/attribute.ts","../../src/line.ts","../../src/text.ts","../../src/tilecache.ts","../../src/labeler.ts","../../src/view.ts","../../src/painter.ts","../../src/frontends/leaflet.ts","../../src/task.ts"],"sourcesContent":["import Point from \"@mapbox/point-geometry\";\n\nimport { namedFlavor } from \"@protomaps/basemaps\";\nimport { PMTiles } from \"pmtiles\";\nimport { labelRules, paintRules } from \"../default_style/style\";\nimport { LabelRule, Labeler } from \"../labeler\";\nimport { PaintRule, paint } from \"../painter\";\nimport { PreparedTile, SourceOptions, View, sourcesToViews } from \"../view\";\n\nconst R = 6378137;\nconst MAX_LATITUDE = 85.0511287798;\nconst MAXCOORD = R * Math.PI;\n\nconst project = (latlng: Point): Point => {\n  const d = Math.PI / 180;\n  const constrainedLat = Math.max(\n    Math.min(MAX_LATITUDE, latlng.y),\n    -MAX_LATITUDE,\n  );\n  const sin = Math.sin(constrainedLat * d);\n  return new Point(R * latlng.x * d, (R * Math.log((1 + sin) / (1 - sin))) / 2);\n};\n\nconst unproject = (point: Point) => {\n  const d = 180 / Math.PI;\n  return {\n    lat: (2 * Math.atan(Math.exp(point.y / R)) - Math.PI / 2) * d,\n    lng: (point.x * d) / R,\n  };\n};\n\nconst instancedProject = (origin: Point, displayZoom: number) => {\n  return (latlng: Point) => {\n    const projected = project(latlng);\n    const normalized = new Point(\n      (projected.x + MAXCOORD) / (MAXCOORD * 2),\n      1 - (projected.y + MAXCOORD) / (MAXCOORD * 2),\n    );\n    return normalized.mult(2 ** displayZoom * 256).sub(origin);\n  };\n};\n\nconst instancedUnproject = (origin: Point, displayZoom: number) => {\n  return (point: Point) => {\n    const normalized = new Point(point.x, point.y)\n      .add(origin)\n      .div(2 ** displayZoom * 256);\n    const projected = new Point(\n      normalized.x * (MAXCOORD * 2) - MAXCOORD,\n      (1 - normalized.y) * (MAXCOORD * 2) - MAXCOORD,\n    );\n    return unproject(projected);\n  };\n};\n\nexport const getZoom = (degreesLng: number, cssPixels: number): number => {\n  const d = cssPixels * (360 / degreesLng);\n  return Math.log2(d / 256);\n};\n\ninterface StaticOptions {\n  debug?: string;\n  lang?: string;\n  maxDataZoom?: number;\n  url?: PMTiles | string;\n  sources?: Record<string, SourceOptions>;\n  paintRules?: PaintRule[];\n  labelRules?: LabelRule[];\n  backgroundColor?: string;\n  flavor?: string;\n}\n\nexport class Static {\n  paintRules: PaintRule[];\n  labelRules: LabelRule[];\n  views: Map<string, View>;\n  debug?: string;\n  backgroundColor?: string;\n\n  constructor(options: StaticOptions) {\n    if (options.flavor) {\n      const flavor = namedFlavor(options.flavor);\n      this.paintRules = paintRules(flavor);\n      this.labelRules = labelRules(flavor, options.lang || \"en\");\n      this.backgroundColor = flavor.background;\n    } else {\n      this.paintRules = options.paintRules || [];\n      this.labelRules = options.labelRules || [];\n      this.backgroundColor = options.backgroundColor;\n    }\n\n    this.views = sourcesToViews(options);\n    this.debug = options.debug || \"\";\n  }\n\n  async drawContext(\n    ctx: CanvasRenderingContext2D,\n    width: number,\n    height: number,\n    latlng: Point,\n    displayZoom: number,\n  ) {\n    const center = project(latlng);\n    const normalizedCenter = new Point(\n      (center.x + MAXCOORD) / (MAXCOORD * 2),\n      1 - (center.y + MAXCOORD) / (MAXCOORD * 2),\n    );\n\n    // the origin of the painter call in global Z coordinates\n    const origin = normalizedCenter\n      .clone()\n      .mult(2 ** displayZoom * 256)\n      .sub(new Point(width / 2, height / 2));\n\n    // the bounds of the painter call in global Z coordinates\n    const bbox = {\n      minX: origin.x,\n      minY: origin.y,\n      maxX: origin.x + width,\n      maxY: origin.y + height,\n    };\n\n    const promises = [];\n    for (const [k, v] of this.views) {\n      const promise = v.getBbox(displayZoom, bbox);\n      promises.push({ key: k, promise: promise });\n    }\n    const tileResponses = await Promise.all(\n      promises.map((o) => {\n        return o.promise.then(\n          (v: PreparedTile[]) => {\n            return { status: \"fulfilled\", value: v, key: o.key };\n          },\n          (error: Error) => {\n            return { status: \"rejected\", value: [], reason: error, key: o.key };\n          },\n        );\n      }),\n    );\n\n    const preparedTilemap = new Map<string, PreparedTile[]>();\n    for (const tileResponse of tileResponses) {\n      if (tileResponse.status === \"fulfilled\") {\n        preparedTilemap.set(tileResponse.key, tileResponse.value);\n      }\n    }\n\n    const start = performance.now();\n    const labeler = new Labeler(\n      displayZoom,\n      ctx,\n      this.labelRules,\n      16,\n      undefined,\n    ); // because need ctx to measure\n\n    const layoutTime = labeler.add(preparedTilemap);\n\n    if (this.backgroundColor) {\n      ctx.save();\n      ctx.fillStyle = this.backgroundColor;\n      ctx.fillRect(0, 0, width, height);\n      ctx.restore();\n    }\n\n    const paintRules = this.paintRules;\n\n    const p = paint(\n      ctx,\n      displayZoom,\n      preparedTilemap,\n      labeler.index,\n      paintRules,\n      bbox,\n      origin,\n      true,\n      this.debug,\n    );\n\n    if (this.debug) {\n      ctx.save();\n      ctx.translate(-origin.x, -origin.y);\n      ctx.strokeStyle = this.debug;\n      ctx.fillStyle = this.debug;\n      ctx.font = \"12px sans-serif\";\n      let idx = 0;\n      for (const [k, v] of preparedTilemap) {\n        for (const preparedTile of v) {\n          ctx.strokeRect(\n            preparedTile.origin.x,\n            preparedTile.origin.y,\n            preparedTile.dim,\n            preparedTile.dim,\n          );\n          const dt = preparedTile.dataTile;\n          ctx.fillText(\n            `${k + (k ? \" \" : \"\") + dt.z} ${dt.x} ${dt.y}`,\n            preparedTile.origin.x + 4,\n            preparedTile.origin.y + 14 * (1 + idx),\n          );\n        }\n        idx++;\n      }\n      ctx.restore();\n    }\n\n    // TODO this API isn't so elegant\n    return {\n      elapsed: performance.now() - start,\n      project: instancedProject(origin, displayZoom),\n      unproject: instancedUnproject(origin, displayZoom),\n    };\n  }\n\n  async drawCanvas(\n    canvas: HTMLCanvasElement,\n    latlng: Point,\n    displayZoom: number,\n    options: StaticOptions = {},\n  ) {\n    const dpr = window.devicePixelRatio;\n    const width = canvas.clientWidth;\n    const height = canvas.clientHeight;\n    if (!(canvas.width === width * dpr && canvas.height === height * dpr)) {\n      canvas.width = width * dpr;\n      canvas.height = height * dpr;\n    }\n    if (options.lang) canvas.lang = options.lang;\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) {\n      console.error(\"Failed to initialize canvas2d context.\");\n      return;\n    }\n    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    return this.drawContext(ctx, width, height, latlng, displayZoom);\n  }\n\n  async drawContextBounds(\n    ctx: CanvasRenderingContext2D,\n    topLeft: Point,\n    bottomRight: Point,\n    width: number,\n    height: number,\n  ) {\n    const deltaDegrees = bottomRight.x - topLeft.x;\n    const center = new Point(\n      (topLeft.x + bottomRight.x) / 2,\n      (topLeft.y + bottomRight.y) / 2,\n    );\n    return this.drawContext(\n      ctx,\n      width,\n      height,\n      center,\n      getZoom(deltaDegrees, width),\n    );\n  }\n\n  async drawCanvasBounds(\n    canvas: HTMLCanvasElement,\n    topLeft: Point,\n    bottomRight: Point,\n    width: number,\n    options: StaticOptions = {},\n  ) {\n    const deltaDegrees = bottomRight.x - topLeft.x;\n    const center = new Point(\n      (topLeft.x + bottomRight.x) / 2,\n      (topLeft.y + bottomRight.y) / 2,\n    );\n    return this.drawCanvas(\n      canvas,\n      center,\n      getZoom(deltaDegrees, width),\n      options,\n    );\n  }\n}\n","import { type Flavor } from \"@protomaps/basemaps\";\nimport { mix } from \"color2k\";\nimport { LabelRule } from \"../labeler\";\nimport { PaintRule } from \"../painter\";\nimport {\n  CenteredTextSymbolizer,\n  CircleSymbolizer,\n  GroupSymbolizer,\n  LineLabelSymbolizer,\n  LineSymbolizer,\n  OffsetTextSymbolizer,\n  PolygonSymbolizer,\n  exp,\n  linear,\n} from \"../symbolizer\";\nimport { Feature, GeomType, JsonObject } from \"../tilecache\";\n\nconst getString = (props: JsonObject, key: string): string => {\n  const val = props[key];\n  if (typeof val === \"string\") return val;\n  return \"\";\n};\n\nconst getNumber = (props: JsonObject, key: string): number => {\n  const val = props[key];\n  if (typeof val === \"number\") return val;\n  return 0;\n};\n\nexport const paintRules = (t: Flavor): PaintRule[] => {\n  return [\n    {\n      dataLayer: \"earth\",\n      symbolizer: new PolygonSymbolizer({\n        fill: t.earth,\n      }),\n    },\n    ...(t.landcover\n      ? [\n          {\n            dataLayer: \"landcover\",\n            symbolizer: new PolygonSymbolizer({\n              fill: (z, f) => {\n                const landcover = t.landcover;\n                if (!landcover || !f) return \"\";\n                const kind = getString(f.props, \"kind\");\n                if (kind === \"grassland\") return landcover.grassland;\n                if (kind === \"barren\") return landcover.barren;\n                if (kind === \"urban_area\") return landcover.urban_area;\n                if (kind === \"farmland\") return landcover.farmland;\n                if (kind === \"glacier\") return landcover.glacier;\n                if (kind === \"scrub\") return landcover.scrub;\n                return landcover.forest;\n              },\n              opacity: (z, f) => {\n                if (z === 8) return 0.5;\n                return 1;\n              },\n            }),\n          },\n        ]\n      : []),\n    {\n      dataLayer: \"landuse\",\n      symbolizer: new PolygonSymbolizer({\n        fill: (z, f) => {\n          return mix(t.park_a, t.park_b, Math.min(Math.max(z / 12.0, 12), 0));\n        },\n      }),\n      filter: (z, f) => {\n        const kind = getString(f.props, \"kind\");\n        return [\"allotments\", \"village_green\", \"playground\"].includes(kind);\n      },\n    },\n    {\n      dataLayer: \"landuse\",\n      symbolizer: new PolygonSymbolizer({\n        fill: t.park_b,\n        opacity: (z, f) => {\n          if (z < 8) return 0;\n          if (z === 8) return 0.5;\n          return 1;\n        },\n      }),\n      filter: (z, f) => {\n        const kind = getString(f.props, \"kind\");\n        return [\n          \"national_park\",\n          \"park\",\n          \"cemetery\",\n          \"protected_area\",\n          \"nature_reserve\",\n          \"forest\",\n          \"golf_course\",\n        ].includes(kind);\n      },\n    },\n    {\n      dataLayer: \"landuse\",\n      symbolizer: new PolygonSymbolizer({\n        fill: t.hospital,\n      }),\n      filter: (z, f) => {\n        return f.props.kind === \"hospital\";\n      },\n    },\n    {\n      dataLayer: \"landuse\",\n      symbolizer: new PolygonSymbolizer({\n        fill: t.industrial,\n      }),\n      filter: (z, f) => {\n        return f.props.kind === \"industrial\";\n      },\n    },\n    {\n      dataLayer: \"landuse\",\n      symbolizer: new PolygonSymbolizer({\n        fill: t.school,\n      }),\n      filter: (z, f) => {\n        const kind = getString(f.props, \"kind\");\n        return [\"school\", \"university\", \"college\"].includes(kind);\n      },\n    },\n    {\n      dataLayer: \"landuse\",\n      symbolizer: new PolygonSymbolizer({\n        fill: t.beach,\n      }),\n      filter: (z, f) => {\n        return f.props.kind === \"beach\";\n      },\n    },\n    {\n      dataLayer: \"landuse\",\n      symbolizer: new PolygonSymbolizer({\n        fill: t.zoo,\n      }),\n      filter: (z, f) => {\n        return f.props.kind === \"zoo\";\n      },\n    },\n    {\n      dataLayer: \"landuse\",\n      symbolizer: new PolygonSymbolizer({\n        fill: t.zoo,\n      }),\n      filter: (z, f) => {\n        const kind = getString(f.props, \"kind\");\n        return [\"military\", \"naval_base\", \"airfield\"].includes(kind);\n      },\n    },\n    {\n      dataLayer: \"landuse\",\n      symbolizer: new PolygonSymbolizer({\n        fill: (z, f) => {\n          return mix(t.wood_a, t.wood_b, Math.min(Math.max(z / 12.0, 12), 0));\n        },\n        opacity: (z, f) => {\n          if (z < 8) return 0;\n          if (z === 8) return 0.5;\n          return 1;\n        },\n      }),\n      filter: (z, f) => {\n        const kind = getString(f.props, \"kind\");\n        return [\"wood\", \"nature_reserve\", \"forest\"].includes(kind);\n      },\n    },\n    {\n      dataLayer: \"landuse\",\n      symbolizer: new PolygonSymbolizer({\n        fill: (z, f) => {\n          return mix(t.scrub_a, t.scrub_b, Math.min(Math.max(z / 12.0, 12), 0));\n        },\n      }),\n      filter: (z, f) => {\n        const kind = getString(f.props, \"kind\");\n        return [\"scrub\", \"grassland\", \"grass\"].includes(kind);\n      },\n    },\n    {\n      dataLayer: \"landuse\",\n      symbolizer: new PolygonSymbolizer({\n        fill: t.scrub_b,\n      }),\n      filter: (z, f) => {\n        const kind = getString(f.props, \"kind\");\n        return [\"scrub\", \"grassland\", \"grass\"].includes(kind);\n      },\n    },\n    {\n      dataLayer: \"landuse\",\n      symbolizer: new PolygonSymbolizer({\n        fill: t.glacier,\n      }),\n      filter: (z, f) => {\n        return f.props.kind === \"glacier\";\n      },\n    },\n    {\n      dataLayer: \"landuse\",\n      symbolizer: new PolygonSymbolizer({\n        fill: t.sand,\n        opacity: (z, f) => {\n          if (z < 8) return 0;\n          if (z === 8) return 0.5;\n          return 1;\n        },\n      }),\n      filter: (z, f) => {\n        return f.props.kind === \"sand\";\n      },\n    },\n    {\n      dataLayer: \"landuse\",\n      symbolizer: new PolygonSymbolizer({\n        fill: t.aerodrome,\n      }),\n      filter: (z, f) => {\n        return f.props.kind === \"aerodrome\";\n      },\n    },\n    {\n      dataLayer: \"water\",\n      symbolizer: new PolygonSymbolizer({\n        fill: t.water,\n      }),\n      filter: (z, f) => {\n        return f.geomType === GeomType.Polygon;\n      },\n    },\n    {\n      dataLayer: \"roads\",\n      symbolizer: new LineSymbolizer({\n        color: t.runway,\n        width: (z, f) => {\n          return exp(1.6, [\n            [11, 0],\n            [13, 4],\n            [19, 30],\n          ])(z);\n        },\n      }),\n      filter: (z, f) => {\n        return f.props.kind_detail === \"runway\";\n      },\n    },\n    {\n      dataLayer: \"roads\",\n      symbolizer: new LineSymbolizer({\n        color: t.runway,\n        width: (z, f) => {\n          return exp(1.6, [\n            [14, 0],\n            [14.5, 1],\n            [16, 6],\n          ])(z);\n        },\n      }),\n      filter: (z, f) => {\n        return f.props.kind_detail === \"taxiway\";\n      },\n    },\n    {\n      dataLayer: \"roads\",\n      symbolizer: new LineSymbolizer({\n        color: t.pier,\n        width: (z, f) => {\n          return exp(1.6, [\n            [13, 0],\n            [13.5, 0, 5],\n            [21, 16],\n          ])(z);\n        },\n      }),\n      filter: (z, f) => {\n        return f.props.kind === \"path\" && f.props.kind_detail === \"pier\";\n      },\n    },\n    {\n      dataLayer: \"water\",\n      minzoom: 14,\n      symbolizer: new LineSymbolizer({\n        color: t.water,\n        width: (z, f) => {\n          return exp(1.6, [\n            [9, 0],\n            [9.5, 1.0],\n            [18, 12],\n          ])(z);\n        },\n      }),\n      filter: (z, f) => {\n        return f.geomType === GeomType.Line && f.props.kind === \"river\";\n      },\n    },\n    {\n      dataLayer: \"water\",\n      minzoom: 14,\n      symbolizer: new LineSymbolizer({\n        color: t.water,\n        width: 0.5,\n      }),\n      filter: (z, f) => {\n        return f.geomType === GeomType.Line && f.props.kind === \"stream\";\n      },\n    },\n    {\n      dataLayer: \"landuse\",\n      symbolizer: new PolygonSymbolizer({\n        fill: t.pedestrian,\n      }),\n      filter: (z, f) => {\n        return f.props.kind === \"pedestrian\";\n      },\n    },\n    {\n      dataLayer: \"landuse\",\n      symbolizer: new PolygonSymbolizer({\n        fill: t.pier,\n      }),\n      filter: (z, f) => {\n        return f.props.kind === \"pier\";\n      },\n    },\n    {\n      dataLayer: \"buildings\",\n      symbolizer: new PolygonSymbolizer({\n        fill: t.buildings,\n        opacity: 0.5,\n      }),\n    },\n    {\n      dataLayer: \"roads\",\n      symbolizer: new LineSymbolizer({\n        color: t.major,\n        width: (z, f) => {\n          return exp(1.6, [\n            [14, 0],\n            [20, 7],\n          ])(z);\n        },\n      }),\n      filter: (z, f) => {\n        const kind = getString(f.props, \"kind\");\n        return [\"other\", \"path\"].includes(kind);\n      },\n    },\n    {\n      dataLayer: \"roads\",\n      symbolizer: new LineSymbolizer({\n        color: t.major,\n        width: (z, f) => {\n          return exp(1.6, [\n            [13, 0],\n            [18, 8],\n          ])(z);\n        },\n      }),\n      filter: (z, f) => {\n        return f.props.kind === \"minor_road\";\n      },\n    },\n    {\n      dataLayer: \"roads\",\n      symbolizer: new LineSymbolizer({\n        color: t.major,\n        width: (z, f) => {\n          return exp(1.6, [\n            [6, 0],\n            [12, 1.6],\n            [15, 3],\n            [18, 13],\n          ])(z);\n        },\n      }),\n      filter: (z, f) => {\n        return f.props.kind === \"major_road\";\n      },\n    },\n    {\n      dataLayer: \"roads\",\n      symbolizer: new LineSymbolizer({\n        color: t.major,\n        width: (z, f) => {\n          return exp(1.6, [\n            [3, 0],\n            [6, 1.1],\n            [12, 1.6],\n            [15, 5],\n            [18, 15],\n          ])(z);\n        },\n      }),\n      filter: (z, f) => {\n        return f.props.kind === \"highway\";\n      },\n    },\n    {\n      dataLayer: \"boundaries\",\n      symbolizer: new LineSymbolizer({\n        color: t.boundaries,\n        width: 1,\n      }),\n      filter: (z, f) => {\n        const minAdminLevel = f.props.kind_detail;\n        return typeof minAdminLevel === \"number\" && minAdminLevel <= 2;\n      },\n    },\n    {\n      dataLayer: \"roads\",\n      symbolizer: new LineSymbolizer({\n        dash: [0.3, 0.75],\n        color: t.railway,\n        dashWidth: (z, f) => {\n          return exp(1.6, [\n            [4, 0],\n            [7, 0.15],\n            [19, 9],\n          ])(z);\n        },\n        opacity: 0.5,\n      }),\n      filter: (z, f) => {\n        return f.props.kind === \"rail\";\n      },\n    },\n    {\n      dataLayer: \"boundaries\",\n      symbolizer: new LineSymbolizer({\n        color: t.boundaries,\n        width: 0.5,\n      }),\n      filter: (z, f) => {\n        const minAdminLevel = f.props.kind_detail;\n        return typeof minAdminLevel === \"number\" && minAdminLevel > 2;\n      },\n    },\n  ];\n};\n\nexport const labelRules = (t: Flavor, lang: string): LabelRule[] => {\n  const nametags = [`name:${lang}`, \"name\"];\n\n  return [\n    // {\n    //   id: \"neighbourhood\",\n    //   dataLayer: \"places\",\n    //   symbolizer: languageStack(\n    //     new CenteredTextSymbolizer({\n    //       labelProps: nametags,\n    //       fill: params.neighbourhoodLabel,\n    //       font: \"500 10px sans-serif\",\n    //       textTransform: \"uppercase\",\n    //     }),\n    //     params.neighbourhoodLabel,\n    //   ),\n    //   filter: (z, f) => {\n    //     return f.props[\"kind\"] === \"neighbourhood\";\n    //   },\n    // },\n    {\n      dataLayer: \"roads\",\n      symbolizer: new LineLabelSymbolizer({\n        labelProps: nametags,\n        fill: t.roads_label_minor,\n        font: \"400 12px sans-serif\",\n        width: 2,\n        stroke: t.roads_label_minor_halo,\n      }),\n      // TODO: sort by minzoom\n      minzoom: 16,\n      filter: (z, f) => {\n        const kind = getString(f.props, \"kind\");\n        return [\"minor_road\", \"other\", \"path\"].includes(kind);\n      },\n    },\n    {\n      dataLayer: \"roads\",\n      symbolizer: new LineLabelSymbolizer({\n        labelProps: nametags,\n        fill: t.roads_label_major,\n        font: \"400 12px sans-serif\",\n        width: 2,\n        stroke: t.roads_label_major_halo,\n      }),\n      // TODO: sort by minzoom\n      minzoom: 12,\n      filter: (z, f) => {\n        const kind = getString(f.props, \"kind\");\n        return [\"highway\", \"major_road\"].includes(kind);\n      },\n    },\n    {\n      dataLayer: \"roads\",\n      symbolizer: new LineLabelSymbolizer({\n        labelProps: nametags,\n        fill: t.roads_label_major,\n        font: \"400 12px sans-serif\",\n        width: 2,\n        stroke: t.roads_label_major_halo,\n      }),\n      // TODO: sort by minzoom\n      minzoom: 12,\n      filter: (z, f) => {\n        const kind = getString(f.props, \"kind\");\n        return [\"highway\", \"major_road\"].includes(kind);\n      },\n    },\n    {\n      dataLayer: \"water\",\n      symbolizer: new CenteredTextSymbolizer({\n        labelProps: nametags,\n        fill: t.ocean_label,\n        lineHeight: 1.5,\n        letterSpacing: 1,\n        font: (z, f) => {\n          const size = linear([\n            [3, 10],\n            [10, 12],\n          ])(z);\n          return `400 ${size}px sans-serif`;\n        },\n        textTransform: \"uppercase\",\n      }),\n      filter: (z, f) => {\n        const kind = getString(f.props, \"kind\");\n        return (\n          f.geomType === GeomType.Point &&\n          [\"ocean\", \"bay\", \"strait\", \"fjord\"].includes(kind)\n        );\n      },\n    },\n    {\n      dataLayer: \"water\",\n      symbolizer: new CenteredTextSymbolizer({\n        labelProps: nametags,\n        fill: t.ocean_label,\n        lineHeight: 1.5,\n        letterSpacing: 1,\n        font: (z, f) => {\n          const size = linear([\n            [3, 10],\n            [6, 12],\n            [10, 12],\n          ])(z);\n          return `400 ${size}px sans-serif`;\n        },\n      }),\n      filter: (z, f) => {\n        const kind = getString(f.props, \"kind\");\n        return (\n          f.geomType === GeomType.Point &&\n          [\"sea\", \"lake\", \"water\"].includes(kind)\n        );\n      },\n    },\n    {\n      dataLayer: \"places\",\n      symbolizer: new CenteredTextSymbolizer({\n        labelProps: (z, f) => {\n          if (z < 6) {\n            return [`ref:${lang}`, \"ref\"];\n          }\n          return nametags;\n        },\n        fill: t.state_label,\n        stroke: t.state_label_halo,\n        width: 1,\n        lineHeight: 1.5,\n        font: (z: number, f?: Feature) => {\n          return \"400 12px sans-serif\";\n        },\n        textTransform: \"uppercase\",\n      }),\n      filter: (z, f) => {\n        return f.props.kind === \"region\";\n      },\n    },\n    {\n      dataLayer: \"places\",\n      symbolizer: new CenteredTextSymbolizer({\n        labelProps: nametags,\n        fill: t.country_label,\n        lineHeight: 1.5,\n        font: (z: number, f?: Feature) => {\n          if (z < 6) return \"600 12px sans-serif\";\n          return \"600 12px sans-serif\";\n        },\n        textTransform: \"uppercase\",\n      }),\n      filter: (z, f) => {\n        return f.props.kind === \"country\";\n      },\n    },\n    {\n      // places_locality\n      dataLayer: \"places\",\n      minzoom: 9,\n      symbolizer: new CenteredTextSymbolizer({\n        labelProps: nametags,\n        fill: t.city_label,\n        lineHeight: 1.5,\n        font: (z: number, f?: Feature) => {\n          if (!f) return \"400 12px sans-serif\";\n          const minZoom = f.props.min_zoom;\n          let weight = 400;\n          if (minZoom && minZoom <= 5) {\n            weight = 600;\n          }\n          let size = 12;\n          const popRank = f.props.population_rank;\n          if (popRank && popRank > 9) {\n            size = 16;\n          }\n          return `${weight} ${size}px sans-serif`;\n        },\n      }),\n      sort: (a, b) => {\n        const aRank = getNumber(a, \"min_zoom\");\n        const bRank = getNumber(b, \"min_zoom\");\n        return aRank - bRank;\n      },\n      filter: (z, f) => {\n        return f.props.kind === \"locality\";\n      },\n    },\n    {\n      dataLayer: \"places\",\n      maxzoom: 8,\n      symbolizer: new GroupSymbolizer([\n        new CircleSymbolizer({\n          radius: 2,\n          fill: t.city_label,\n          stroke: t.city_label_halo,\n          width: 1.5,\n        }),\n        new OffsetTextSymbolizer({\n          labelProps: nametags,\n          fill: t.city_label,\n          stroke: t.city_label_halo,\n          width: 1,\n          offsetX: 6,\n          offsetY: 4.5,\n          font: (z, f) => {\n            return \"400 12px sans-serif\";\n          },\n        }),\n      ]),\n      filter: (z, f) => {\n        return f.props.kind === \"locality\";\n      },\n    },\n  ];\n};\n","import Point from \"@mapbox/point-geometry\";\nimport {\n  ArrayAttr,\n  AttrOption,\n  FontAttr,\n  FontAttrOptions,\n  NumberAttr,\n  StringAttr,\n  TextAttr,\n  TextAttrOptions,\n} from \"./attribute\";\nimport { Label, Layout } from \"./labeler\";\nimport { lineCells, simpleLabel } from \"./line\";\nimport { Sheet } from \"./task\";\nimport { linebreak } from \"./text\";\nimport { Bbox, Feature, GeomType } from \"./tilecache\";\n\nexport interface PaintSymbolizer {\n  before?(ctx: CanvasRenderingContext2D, z: number): void;\n  draw(\n    ctx: CanvasRenderingContext2D,\n    geom: Point[][],\n    z: number,\n    feature: Feature,\n  ): void;\n}\n\nexport enum Justify {\n  Left = 1,\n  Center = 2,\n  Right = 3,\n}\n\nexport enum TextPlacements {\n  N = 1,\n  Ne = 2,\n  E = 3,\n  Se = 4,\n  S = 5,\n  Sw = 6,\n  W = 7,\n  Nw = 8,\n}\n\nexport interface DrawExtra {\n  justify: Justify;\n}\n\nexport interface LabelSymbolizer {\n  /* the symbolizer can, but does not need to, inspect index to determine the right position\n   * if return undefined, no label is added\n   * return a label, but if the label collides it is not added\n   */\n  place(layout: Layout, geom: Point[][], feature: Feature): Label[] | undefined;\n}\n\nexport const createPattern = (\n  width: number,\n  height: number,\n  fn: (canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D) => void,\n) => {\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  canvas.width = width;\n  canvas.height = height;\n  if (ctx !== null) fn(canvas, ctx);\n  return canvas;\n};\n\nexport class PolygonSymbolizer implements PaintSymbolizer {\n  pattern?: CanvasImageSource;\n  fill: StringAttr;\n  opacity: NumberAttr;\n  stroke: StringAttr;\n  width: NumberAttr;\n  perFeature: boolean;\n  doStroke: boolean;\n\n  constructor(options: {\n    pattern?: CanvasImageSource;\n    fill?: AttrOption<string>;\n    opacity?: AttrOption<number>;\n    stroke?: AttrOption<string>;\n    width?: AttrOption<number>;\n    perFeature?: boolean;\n  }) {\n    this.pattern = options.pattern;\n    this.fill = new StringAttr(options.fill, \"black\");\n    this.opacity = new NumberAttr(options.opacity, 1);\n    this.stroke = new StringAttr(options.stroke, \"black\");\n    this.width = new NumberAttr(options.width, 0);\n    this.perFeature =\n      (this.fill.perFeature ||\n        this.opacity.perFeature ||\n        this.stroke.perFeature ||\n        this.width.perFeature ||\n        options.perFeature) ??\n      false;\n    this.doStroke = false;\n  }\n\n  public before(ctx: CanvasRenderingContext2D, z: number) {\n    if (!this.perFeature) {\n      ctx.globalAlpha = this.opacity.get(z);\n      ctx.fillStyle = this.fill.get(z);\n      ctx.strokeStyle = this.stroke.get(z);\n      const width = this.width.get(z);\n      if (width > 0) this.doStroke = true;\n      ctx.lineWidth = width;\n    }\n    if (this.pattern) {\n      const patten = ctx.createPattern(this.pattern, \"repeat\");\n      if (patten) ctx.fillStyle = patten;\n    }\n  }\n\n  public draw(\n    ctx: CanvasRenderingContext2D,\n    geom: Point[][],\n    z: number,\n    f: Feature,\n  ) {\n    let doStroke = false;\n    if (this.perFeature) {\n      ctx.globalAlpha = this.opacity.get(z, f);\n      ctx.fillStyle = this.fill.get(z, f);\n      const width = this.width.get(z, f);\n      if (width) {\n        doStroke = true;\n        ctx.strokeStyle = this.stroke.get(z, f);\n        ctx.lineWidth = width;\n      }\n    }\n\n    const drawPath = () => {\n      ctx.fill();\n      if (doStroke || this.doStroke) {\n        ctx.stroke();\n      }\n    };\n\n    ctx.beginPath();\n    for (const poly of geom) {\n      for (let p = 0; p < poly.length; p++) {\n        const pt = poly[p];\n        if (p === 0) ctx.moveTo(pt.x, pt.y);\n        else ctx.lineTo(pt.x, pt.y);\n      }\n    }\n    drawPath();\n  }\n}\n\nexport function arr(base: number, a: number[]): (z: number) => number {\n  return (z) => {\n    const b = z - base;\n    if (b >= 0 && b < a.length) {\n      return a[b];\n    }\n    return 0;\n  };\n}\n\nfunction getStopIndex(input: number, stops: number[][]): number {\n  let idx = 0;\n  while (stops[idx + 1][0] < input) idx++;\n  return idx;\n}\n\nfunction interpolate(factor: number, start: number, end: number): number {\n  return factor * (end - start) + start;\n}\n\nfunction computeInterpolationFactor(\n  z: number,\n  idx: number,\n  base: number,\n  stops: number[][],\n): number {\n  const difference = stops[idx + 1][0] - stops[idx][0];\n  const progress = z - stops[idx][0];\n  if (difference === 0) return 0;\n  if (base === 1) return progress / difference;\n  return (base ** progress - 1) / (base ** difference - 1);\n}\n\nexport function exp(base: number, stops: number[][]): (z: number) => number {\n  return (z) => {\n    if (stops.length < 1) return 0;\n    if (z <= stops[0][0]) return stops[0][1];\n    if (z >= stops[stops.length - 1][0]) return stops[stops.length - 1][1];\n    const idx = getStopIndex(z, stops);\n    const factor = computeInterpolationFactor(z, idx, base, stops);\n    return interpolate(factor, stops[idx][1], stops[idx + 1][1]);\n  };\n}\n\nexport type Stop = [number, number] | [number, string] | [number, boolean];\nexport function step(\n  output0: number | string | boolean,\n  stops: Stop[],\n): (z: number) => number | string | boolean {\n  // Step computes discrete results by evaluating a piecewise-constant\n  // function defined by stops.\n  // Returns the output value of the stop with a stop input value just less than\n  // the input one. If the input value is less than the input of the first stop,\n  // output0 is returned\n  return (z) => {\n    if (stops.length < 1) return 0;\n    let retval = output0;\n    for (let i = 0; i < stops.length; i++) {\n      if (z >= stops[i][0]) retval = stops[i][1];\n    }\n    return retval;\n  };\n}\n\nexport function linear(stops: number[][]): (z: number) => number {\n  return exp(1, stops);\n}\n\nexport class LineSymbolizer implements PaintSymbolizer {\n  color: StringAttr;\n  width: NumberAttr;\n  opacity: NumberAttr;\n  dash: ArrayAttr<number> | null;\n  dashColor: StringAttr;\n  dashWidth: NumberAttr;\n  skip: boolean;\n  perFeature: boolean;\n  lineCap: StringAttr<CanvasLineCap>;\n  lineJoin: StringAttr<CanvasLineJoin>;\n\n  constructor(options: {\n    color?: AttrOption<string>;\n    width?: AttrOption<number>;\n    opacity?: AttrOption<number>;\n    dash?: number[];\n    dashColor?: AttrOption<string>;\n    dashWidth?: AttrOption<number>;\n    skip?: boolean;\n    perFeature?: boolean;\n    lineCap?: AttrOption<CanvasLineCap>;\n    lineJoin?: AttrOption<CanvasLineJoin>;\n  }) {\n    this.color = new StringAttr(options.color, \"black\");\n    this.width = new NumberAttr(options.width);\n    this.opacity = new NumberAttr(options.opacity);\n    this.dash = options.dash ? new ArrayAttr(options.dash) : null;\n    this.dashColor = new StringAttr(options.dashColor, \"black\");\n    this.dashWidth = new NumberAttr(options.dashWidth, 1.0);\n    this.lineCap = new StringAttr(options.lineCap, \"butt\");\n    this.lineJoin = new StringAttr(options.lineJoin, \"miter\");\n    this.skip = false;\n    this.perFeature = !!(\n      this.dash?.perFeature ||\n      this.color.perFeature ||\n      this.opacity.perFeature ||\n      this.width.perFeature ||\n      this.lineCap.perFeature ||\n      this.lineJoin.perFeature ||\n      options.perFeature\n    );\n  }\n\n  public before(ctx: CanvasRenderingContext2D, z: number) {\n    if (!this.perFeature) {\n      ctx.strokeStyle = this.color.get(z);\n      ctx.lineWidth = this.width.get(z);\n      ctx.globalAlpha = this.opacity.get(z);\n      ctx.lineCap = this.lineCap.get(z);\n      ctx.lineJoin = this.lineJoin.get(z);\n    }\n  }\n\n  public draw(\n    ctx: CanvasRenderingContext2D,\n    geom: Point[][],\n    z: number,\n    f: Feature,\n  ) {\n    if (this.skip) return;\n\n    const strokePath = () => {\n      if (this.perFeature) {\n        ctx.globalAlpha = this.opacity.get(z, f);\n        ctx.lineCap = this.lineCap.get(z, f);\n        ctx.lineJoin = this.lineJoin.get(z, f);\n      }\n      if (this.dash) {\n        ctx.save();\n        if (this.perFeature) {\n          ctx.lineWidth = this.dashWidth.get(z, f);\n          ctx.strokeStyle = this.dashColor.get(z, f);\n          ctx.setLineDash(this.dash.get(z, f));\n        } else {\n          ctx.setLineDash(this.dash.get(z));\n        }\n        ctx.stroke();\n        ctx.restore();\n      } else {\n        ctx.save();\n        if (this.perFeature) {\n          ctx.lineWidth = this.width.get(z, f);\n          ctx.strokeStyle = this.color.get(z, f);\n        }\n        ctx.stroke();\n        ctx.restore();\n      }\n    };\n\n    ctx.beginPath();\n    for (const ls of geom) {\n      for (let p = 0; p < ls.length; p++) {\n        const pt = ls[p];\n        if (p === 0) ctx.moveTo(pt.x, pt.y);\n        else ctx.lineTo(pt.x, pt.y);\n      }\n    }\n    strokePath();\n  }\n}\n\nexport interface IconSymbolizerOptions {\n  name: string;\n  sheet: Sheet;\n}\nexport class IconSymbolizer implements LabelSymbolizer {\n  name: string;\n  sheet: Sheet;\n  dpr: number;\n\n  constructor(options: IconSymbolizerOptions) {\n    this.name = options.name;\n    this.sheet = options.sheet;\n    this.dpr = window.devicePixelRatio;\n  }\n\n  public place(layout: Layout, geom: Point[][], feature: Feature) {\n    const pt = geom[0];\n    const a = new Point(geom[0][0].x, geom[0][0].y);\n    const loc = this.sheet.get(this.name);\n    const width = loc.w / this.dpr;\n    const height = loc.h / this.dpr;\n\n    const bbox = {\n      minX: a.x - width / 2,\n      minY: a.y - height / 2,\n      maxX: a.x + width / 2,\n      maxY: a.y + height / 2,\n    };\n\n    const draw = (ctx: CanvasRenderingContext2D) => {\n      ctx.globalAlpha = 1;\n      ctx.drawImage(\n        this.sheet.canvas,\n        loc.x,\n        loc.y,\n        loc.w,\n        loc.h,\n        -loc.w / 2 / this.dpr,\n        -loc.h / 2 / this.dpr,\n        loc.w / 2,\n        loc.h / 2,\n      );\n    };\n    return [{ anchor: a, bboxes: [bbox], draw: draw }];\n  }\n}\n\nexport class CircleSymbolizer implements LabelSymbolizer, PaintSymbolizer {\n  radius: NumberAttr;\n  fill: StringAttr;\n  stroke: StringAttr;\n  width: NumberAttr;\n  opacity: NumberAttr;\n\n  constructor(options: {\n    radius?: AttrOption<number>;\n    fill?: AttrOption<string>;\n    stroke?: AttrOption<string>;\n    width?: AttrOption<number>;\n    opacity?: AttrOption<number>;\n  }) {\n    this.radius = new NumberAttr(options.radius, 3);\n    this.fill = new StringAttr(options.fill, \"black\");\n    this.stroke = new StringAttr(options.stroke, \"white\");\n    this.width = new NumberAttr(options.width, 0);\n    this.opacity = new NumberAttr(options.opacity);\n  }\n\n  public draw(\n    ctx: CanvasRenderingContext2D,\n    geom: Point[][],\n    z: number,\n    f: Feature,\n  ) {\n    ctx.globalAlpha = this.opacity.get(z, f);\n\n    const radius = this.radius.get(z, f);\n    const width = this.width.get(z, f);\n    if (width > 0) {\n      ctx.strokeStyle = this.stroke.get(z, f);\n      ctx.lineWidth = width;\n      ctx.beginPath();\n      ctx.arc(geom[0][0].x, geom[0][0].y, radius + width / 2, 0, 2 * Math.PI);\n      ctx.stroke();\n    }\n\n    ctx.fillStyle = this.fill.get(z, f);\n    ctx.beginPath();\n    ctx.arc(geom[0][0].x, geom[0][0].y, radius, 0, 2 * Math.PI);\n    ctx.fill();\n  }\n\n  public place(layout: Layout, geom: Point[][], feature: Feature) {\n    const pt = geom[0];\n    const a = new Point(geom[0][0].x, geom[0][0].y);\n    const radius = this.radius.get(layout.zoom, feature);\n    const bbox = {\n      minX: a.x - radius,\n      minY: a.y - radius,\n      maxX: a.x + radius,\n      maxY: a.y + radius,\n    };\n\n    const draw = (ctx: CanvasRenderingContext2D) => {\n      this.draw(ctx, [[new Point(0, 0)]], layout.zoom, feature);\n    };\n    return [{ anchor: a, bboxes: [bbox], draw }];\n  }\n}\n\nexport class ShieldSymbolizer implements LabelSymbolizer {\n  font: FontAttr;\n  text: TextAttr;\n  background: StringAttr;\n  fill: StringAttr;\n  padding: NumberAttr;\n\n  constructor(\n    options: {\n      fill?: AttrOption<string>;\n      background?: AttrOption<string>;\n      padding?: AttrOption<number>;\n    } & FontAttrOptions &\n      TextAttrOptions,\n  ) {\n    this.font = new FontAttr(options);\n    this.text = new TextAttr(options);\n    this.fill = new StringAttr(options.fill, \"black\");\n    this.background = new StringAttr(options.background, \"white\");\n    this.padding = new NumberAttr(options.padding, 0); // TODO check falsy\n  }\n\n  public place(layout: Layout, geom: Point[][], f: Feature) {\n    const property = this.text.get(layout.zoom, f);\n    if (!property) return undefined;\n    const font = this.font.get(layout.zoom, f);\n    layout.scratch.font = font;\n    const metrics = layout.scratch.measureText(property);\n\n    const width = metrics.width;\n    const ascent = metrics.actualBoundingBoxAscent;\n    const descent = metrics.actualBoundingBoxDescent;\n\n    const pt = geom[0];\n    const a = new Point(geom[0][0].x, geom[0][0].y);\n    const p = this.padding.get(layout.zoom, f);\n    const bbox = {\n      minX: a.x - width / 2 - p,\n      minY: a.y - ascent - p,\n      maxX: a.x + width / 2 + p,\n      maxY: a.y + descent + p,\n    };\n\n    const draw = (ctx: CanvasRenderingContext2D) => {\n      ctx.globalAlpha = 1;\n      ctx.fillStyle = this.background.get(layout.zoom, f);\n      ctx.fillRect(\n        -width / 2 - p,\n        -ascent - p,\n        width + 2 * p,\n        ascent + descent + 2 * p,\n      );\n      ctx.fillStyle = this.fill.get(layout.zoom, f);\n      ctx.font = font;\n      ctx.fillText(property, -width / 2, 0);\n    };\n    return [{ anchor: a, bboxes: [bbox], draw: draw }];\n  }\n}\n\n// TODO make me work with multiple anchors\nexport class FlexSymbolizer implements LabelSymbolizer {\n  list: LabelSymbolizer[];\n\n  constructor(list: LabelSymbolizer[]) {\n    this.list = list;\n  }\n\n  public place(layout: Layout, geom: Point[][], feature: Feature) {\n    let labels = this.list[0].place(layout, geom, feature);\n    if (!labels) return undefined;\n    let label = labels[0];\n    const anchor = label.anchor;\n    let bbox = label.bboxes[0];\n    const height = bbox.maxY - bbox.minY;\n    const draws = [{ draw: label.draw, translate: { x: 0, y: 0 } }];\n\n    const newGeom = [[new Point(geom[0][0].x, geom[0][0].y + height)]];\n    for (let i = 1; i < this.list.length; i++) {\n      labels = this.list[i].place(layout, newGeom, feature);\n      if (labels) {\n        label = labels[0];\n        bbox = mergeBbox(bbox, label.bboxes[0]);\n        draws.push({ draw: label.draw, translate: { x: 0, y: height } });\n      }\n    }\n\n    const draw = (ctx: CanvasRenderingContext2D) => {\n      for (const sub of draws) {\n        ctx.save();\n        ctx.translate(sub.translate.x, sub.translate.y);\n        sub.draw(ctx);\n        ctx.restore();\n      }\n    };\n\n    return [{ anchor: anchor, bboxes: [bbox], draw: draw }];\n  }\n}\n\nconst mergeBbox = (b1: Bbox, b2: Bbox) => {\n  return {\n    minX: Math.min(b1.minX, b2.minX),\n    minY: Math.min(b1.minY, b2.minY),\n    maxX: Math.max(b1.maxX, b2.maxX),\n    maxY: Math.max(b1.maxY, b2.maxY),\n  };\n};\n\nexport class GroupSymbolizer implements LabelSymbolizer {\n  list: LabelSymbolizer[];\n\n  constructor(list: LabelSymbolizer[]) {\n    this.list = list;\n  }\n\n  public place(layout: Layout, geom: Point[][], feature: Feature) {\n    const first = this.list[0];\n    if (!first) return undefined;\n    let labels = first.place(layout, geom, feature);\n    if (!labels) return undefined;\n    let label = labels[0];\n    const anchor = label.anchor;\n    let bbox = label.bboxes[0];\n    const draws = [label.draw];\n\n    for (let i = 1; i < this.list.length; i++) {\n      labels = this.list[i].place(layout, geom, feature);\n      if (!labels) return undefined;\n      label = labels[0];\n      bbox = mergeBbox(bbox, label.bboxes[0]);\n      draws.push(label.draw);\n    }\n    const draw = (ctx: CanvasRenderingContext2D) => {\n      for (const d of draws) {\n        d(ctx);\n      }\n    };\n\n    return [{ anchor: anchor, bboxes: [bbox], draw: draw }];\n  }\n}\n\nexport class CenteredSymbolizer implements LabelSymbolizer {\n  symbolizer: LabelSymbolizer;\n\n  constructor(symbolizer: LabelSymbolizer) {\n    this.symbolizer = symbolizer;\n  }\n\n  public place(layout: Layout, geom: Point[][], feature: Feature) {\n    const a = geom[0][0];\n    const placed = this.symbolizer.place(layout, [[new Point(0, 0)]], feature);\n    if (!placed || placed.length === 0) return undefined;\n    const firstLabel = placed[0];\n    const bbox = firstLabel.bboxes[0];\n    const width = bbox.maxX - bbox.minX;\n    const height = bbox.maxY - bbox.minY;\n    const centered = {\n      minX: a.x - width / 2,\n      maxX: a.x + width / 2,\n      minY: a.y - height / 2,\n      maxY: a.y + height / 2,\n    };\n\n    const draw = (ctx: CanvasRenderingContext2D) => {\n      ctx.translate(-width / 2, height / 2 - bbox.maxY);\n      firstLabel.draw(ctx, { justify: Justify.Center });\n    };\n\n    return [{ anchor: a, bboxes: [centered], draw: draw }];\n  }\n}\n\nexport class Padding implements LabelSymbolizer {\n  symbolizer: LabelSymbolizer;\n  padding: NumberAttr;\n\n  constructor(padding: number, symbolizer: LabelSymbolizer) {\n    this.padding = new NumberAttr(padding, 0);\n    this.symbolizer = symbolizer;\n  }\n\n  public place(layout: Layout, geom: Point[][], feature: Feature) {\n    const placed = this.symbolizer.place(layout, geom, feature);\n    if (!placed || placed.length === 0) return undefined;\n    const padding = this.padding.get(layout.zoom, feature);\n    for (const label of placed) {\n      for (const bbox of label.bboxes) {\n        bbox.minX -= padding;\n        bbox.minY -= padding;\n        bbox.maxX += padding;\n        bbox.maxY += padding;\n      }\n    }\n    return placed;\n  }\n}\n\nexport interface TextSymbolizerOptions\n  extends FontAttrOptions,\n    TextAttrOptions {\n  fill?: AttrOption<string>;\n  stroke?: AttrOption<string>;\n  width?: AttrOption<number>;\n  lineHeight?: AttrOption<number>;\n  letterSpacing?: AttrOption<number>;\n  maxLineChars?: AttrOption<number>;\n  justify?: Justify;\n}\n\nexport class TextSymbolizer implements LabelSymbolizer {\n  font: FontAttr;\n  text: TextAttr;\n  fill: StringAttr;\n  stroke: StringAttr;\n  width: NumberAttr;\n  lineHeight: NumberAttr; // in ems\n  letterSpacing: NumberAttr; // in px\n  maxLineCodeUnits: NumberAttr;\n  justify?: Justify;\n\n  constructor(options: TextSymbolizerOptions) {\n    this.font = new FontAttr(options);\n    this.text = new TextAttr(options);\n\n    this.fill = new StringAttr(options.fill, \"black\");\n    this.stroke = new StringAttr(options.stroke, \"black\");\n    this.width = new NumberAttr(options.width, 0);\n    this.lineHeight = new NumberAttr(options.lineHeight, 1);\n    this.letterSpacing = new NumberAttr(options.letterSpacing, 0);\n    this.maxLineCodeUnits = new NumberAttr(options.maxLineChars, 15);\n    this.justify = options.justify;\n  }\n\n  public place(layout: Layout, geom: Point[][], feature: Feature) {\n    const property = this.text.get(layout.zoom, feature);\n    if (!property) return undefined;\n    const font = this.font.get(layout.zoom, feature);\n    layout.scratch.font = font;\n\n    const letterSpacing = this.letterSpacing.get(layout.zoom, feature);\n\n    // line breaking\n    const lines = linebreak(\n      property,\n      this.maxLineCodeUnits.get(layout.zoom, feature),\n    );\n    let longestLine = \"\";\n    let longestLineLen = 0;\n    for (const line of lines) {\n      if (line.length > longestLineLen) {\n        longestLineLen = line.length;\n        longestLine = line;\n      }\n    }\n\n    const metrics = layout.scratch.measureText(longestLine);\n    const width = metrics.width + letterSpacing * (longestLineLen - 1);\n\n    const ascent = metrics.actualBoundingBoxAscent;\n    const descent = metrics.actualBoundingBoxDescent;\n    const lineHeight =\n      (ascent + descent) * this.lineHeight.get(layout.zoom, feature);\n\n    const a = new Point(geom[0][0].x, geom[0][0].y);\n    const bbox = {\n      minX: a.x,\n      minY: a.y - ascent,\n      maxX: a.x + width,\n      maxY: a.y + descent + (lines.length - 1) * lineHeight,\n    };\n\n    // inside draw, the origin is the anchor\n    // and the anchor is the typographic baseline of the first line\n    const draw = (ctx: CanvasRenderingContext2D, extra?: DrawExtra) => {\n      ctx.globalAlpha = 1;\n      ctx.font = font;\n      ctx.fillStyle = this.fill.get(layout.zoom, feature);\n      const textStrokeWidth = this.width.get(layout.zoom, feature);\n\n      let y = 0;\n      for (const line of lines) {\n        let startX = 0;\n        if (\n          this.justify === Justify.Center ||\n          (extra && extra.justify === Justify.Center)\n        ) {\n          startX = (width - ctx.measureText(line).width) / 2;\n        } else if (\n          this.justify === Justify.Right ||\n          (extra && extra.justify === Justify.Right)\n        ) {\n          startX = width - ctx.measureText(line).width;\n        }\n        if (textStrokeWidth) {\n          ctx.lineWidth = textStrokeWidth * 2; // centered stroke\n          ctx.strokeStyle = this.stroke.get(layout.zoom, feature);\n          if (letterSpacing > 0) {\n            let xPos = startX;\n            for (const letter of line) {\n              ctx.strokeText(letter, xPos, y);\n              xPos += ctx.measureText(letter).width + letterSpacing;\n            }\n          } else {\n            ctx.strokeText(line, startX, y);\n          }\n        }\n        if (letterSpacing > 0) {\n          let xPos = startX;\n          for (const letter of line) {\n            ctx.fillText(letter, xPos, y);\n            xPos += ctx.measureText(letter).width + letterSpacing;\n          }\n        } else {\n          ctx.fillText(line, startX, y);\n        }\n        y += lineHeight;\n      }\n    };\n    return [{ anchor: a, bboxes: [bbox], draw: draw }];\n  }\n}\n\nexport class CenteredTextSymbolizer implements LabelSymbolizer {\n  centered: LabelSymbolizer;\n\n  constructor(options: TextSymbolizerOptions) {\n    this.centered = new CenteredSymbolizer(new TextSymbolizer(options));\n  }\n\n  public place(layout: Layout, geom: Point[][], feature: Feature) {\n    return this.centered.place(layout, geom, feature);\n  }\n}\n\nexport interface OffsetSymbolizerValues {\n  offsetX?: number;\n  offsetY?: number;\n  placements?: TextPlacements[];\n  justify?: Justify;\n}\n\nexport type DataDrivenOffsetSymbolizer = (\n  zoom: number,\n  feature: Feature,\n) => OffsetSymbolizerValues;\n\nexport interface OffsetSymbolizerOptions {\n  offsetX?: AttrOption<number>;\n  offsetY?: AttrOption<number>;\n  justify?: Justify;\n  placements?: TextPlacements[];\n  ddValues?: DataDrivenOffsetSymbolizer;\n}\n\nexport class OffsetSymbolizer implements LabelSymbolizer {\n  symbolizer: LabelSymbolizer;\n  offsetX: NumberAttr;\n  offsetY: NumberAttr;\n  justify?: Justify;\n  placements: TextPlacements[];\n  ddValues: DataDrivenOffsetSymbolizer;\n\n  constructor(symbolizer: LabelSymbolizer, options: OffsetSymbolizerOptions) {\n    this.symbolizer = symbolizer;\n    this.offsetX = new NumberAttr(options.offsetX, 0);\n    this.offsetY = new NumberAttr(options.offsetY, 0);\n    this.justify = options.justify ?? undefined;\n    this.placements = options.placements ?? [\n      TextPlacements.Ne,\n      TextPlacements.Sw,\n      TextPlacements.Nw,\n      TextPlacements.Se,\n      TextPlacements.N,\n      TextPlacements.E,\n      TextPlacements.S,\n      TextPlacements.W,\n    ];\n    this.ddValues =\n      options.ddValues ??\n      (() => {\n        return {};\n      });\n  }\n\n  public place(layout: Layout, geom: Point[][], feature: Feature) {\n    if (feature.geomType !== GeomType.Point) return undefined;\n    const anchor = geom[0][0];\n    const placed = this.symbolizer.place(layout, [[new Point(0, 0)]], feature);\n    if (!placed || placed.length === 0) return undefined;\n    const firstLabel = placed[0];\n    const fb = firstLabel.bboxes[0];\n\n    // Overwrite options values via the data driven function if exists\n    let offsetXvalue = this.offsetX;\n    let offsetYvalue = this.offsetY;\n    let justifyValue = this.justify;\n    let placements = this.placements;\n    const {\n      offsetX: ddOffsetX,\n      offsetY: ddOffsetY,\n      justify: ddJustify,\n      placements: ddPlacements,\n    } = this.ddValues(layout.zoom, feature) || {};\n    if (ddOffsetX) offsetXvalue = new NumberAttr(ddOffsetX, 0);\n    if (ddOffsetY) offsetYvalue = new NumberAttr(ddOffsetY, 0);\n    if (ddJustify) justifyValue = ddJustify;\n    if (ddPlacements) placements = ddPlacements;\n\n    const offsetX = offsetXvalue.get(layout.zoom, feature);\n    const offsetY = offsetYvalue.get(layout.zoom, feature);\n\n    const getBbox = (a: Point, o: Point) => {\n      return {\n        minX: a.x + o.x + fb.minX,\n        minY: a.y + o.y + fb.minY,\n        maxX: a.x + o.x + fb.maxX,\n        maxY: a.y + o.y + fb.maxY,\n      };\n    };\n\n    let origin = new Point(offsetX, offsetY);\n    let justify: Justify;\n    const draw = (ctx: CanvasRenderingContext2D) => {\n      ctx.translate(origin.x, origin.y);\n      firstLabel.draw(ctx, { justify: justify });\n    };\n\n    const placeLabelInPoint = (a: Point, o: Point) => {\n      const bbox = getBbox(a, o);\n      if (!layout.index.bboxCollides(bbox, layout.order))\n        return [{ anchor: anchor, bboxes: [bbox], draw: draw }];\n    };\n\n    for (const placement of placements) {\n      const xAxisOffset = this.computeXaxisOffset(offsetX, fb, placement);\n      const yAxisOffset = this.computeYaxisOffset(offsetY, fb, placement);\n      justify = this.computeJustify(justifyValue, placement);\n      origin = new Point(xAxisOffset, yAxisOffset);\n      return placeLabelInPoint(anchor, origin);\n    }\n\n    return undefined;\n  }\n\n  computeXaxisOffset(offsetX: number, fb: Bbox, placement: TextPlacements) {\n    const labelWidth = fb.maxX;\n    const labelHalfWidth = labelWidth / 2;\n    if ([TextPlacements.N, TextPlacements.S].includes(placement))\n      return offsetX - labelHalfWidth;\n    if (\n      [TextPlacements.Nw, TextPlacements.W, TextPlacements.Sw].includes(\n        placement,\n      )\n    )\n      return offsetX - labelWidth;\n    return offsetX;\n  }\n\n  computeYaxisOffset(offsetY: number, fb: Bbox, placement: TextPlacements) {\n    const labelHalfHeight = Math.abs(fb.minY);\n    const labelBottom = fb.maxY;\n    const labelCenterHeight = (fb.minY + fb.maxY) / 2;\n    if ([TextPlacements.E, TextPlacements.W].includes(placement))\n      return offsetY - labelCenterHeight;\n    if (\n      [TextPlacements.Nw, TextPlacements.Ne, TextPlacements.N].includes(\n        placement,\n      )\n    )\n      return offsetY - labelBottom;\n    if (\n      [TextPlacements.Sw, TextPlacements.Se, TextPlacements.S].includes(\n        placement,\n      )\n    )\n      return offsetY + labelHalfHeight;\n    return offsetY;\n  }\n\n  computeJustify(fixedJustify: Justify | undefined, placement: TextPlacements) {\n    if (fixedJustify) return fixedJustify;\n    if ([TextPlacements.N, TextPlacements.S].includes(placement))\n      return Justify.Center;\n    if (\n      [TextPlacements.Ne, TextPlacements.E, TextPlacements.Se].includes(\n        placement,\n      )\n    )\n      return Justify.Left;\n    return Justify.Right;\n  }\n}\n\nexport class OffsetTextSymbolizer implements LabelSymbolizer {\n  symbolizer: LabelSymbolizer;\n\n  constructor(options: OffsetSymbolizerOptions & TextSymbolizerOptions) {\n    this.symbolizer = new OffsetSymbolizer(\n      new TextSymbolizer(options),\n      options,\n    );\n  }\n\n  public place(layout: Layout, geom: Point[][], feature: Feature) {\n    return this.symbolizer.place(layout, geom, feature);\n  }\n}\n\nexport enum LineLabelPlacement {\n  Above = 1,\n  Center = 2,\n  Below = 3,\n}\n\nexport class LineLabelSymbolizer implements LabelSymbolizer {\n  font: FontAttr;\n  text: TextAttr;\n\n  fill: StringAttr;\n  stroke: StringAttr;\n  width: NumberAttr;\n  offset: NumberAttr;\n  position: LineLabelPlacement;\n  maxLabelCodeUnits: NumberAttr;\n  repeatDistance: NumberAttr;\n\n  constructor(\n    options: {\n      radius?: AttrOption<number>;\n      fill?: AttrOption<string>;\n      stroke?: AttrOption<string>;\n      width?: AttrOption<number>;\n      offset?: AttrOption<number>;\n      maxLabelChars?: AttrOption<number>;\n      repeatDistance?: AttrOption<number>;\n      position?: LineLabelPlacement;\n    } & TextAttrOptions &\n      FontAttrOptions,\n  ) {\n    this.font = new FontAttr(options);\n    this.text = new TextAttr(options);\n\n    this.fill = new StringAttr(options.fill, \"black\");\n    this.stroke = new StringAttr(options.stroke, \"black\");\n    this.width = new NumberAttr(options.width, 0);\n    this.offset = new NumberAttr(options.offset, 0);\n    this.position = options.position ?? LineLabelPlacement.Above;\n    this.maxLabelCodeUnits = new NumberAttr(options.maxLabelChars, 40);\n    this.repeatDistance = new NumberAttr(options.repeatDistance, 250);\n  }\n\n  public place(layout: Layout, geom: Point[][], feature: Feature) {\n    const name = this.text.get(layout.zoom, feature);\n    if (!name) return undefined;\n    if (name.length > this.maxLabelCodeUnits.get(layout.zoom, feature))\n      return undefined;\n\n    const minLabelableDim = 20;\n    const fbbox = feature.bbox;\n    if (\n      fbbox.maxY - fbbox.minY < minLabelableDim &&\n      fbbox.maxX - fbbox.minX < minLabelableDim\n    )\n      return undefined;\n\n    const font = this.font.get(layout.zoom, feature);\n    layout.scratch.font = font;\n    const metrics = layout.scratch.measureText(name);\n    const width = metrics.width;\n    const height =\n      metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;\n\n    let repeatDistance = this.repeatDistance.get(layout.zoom, feature);\n    if (layout.overzoom > 4) repeatDistance *= 1 << (layout.overzoom - 4);\n\n    const cellSize = height * 2;\n\n    const labelCandidates = simpleLabel(geom, width, repeatDistance, cellSize);\n    if (labelCandidates.length === 0) return undefined;\n\n    const labels = [];\n    for (const candidate of labelCandidates) {\n      const dx = candidate.end.x - candidate.start.x;\n      const dy = candidate.end.y - candidate.start.y;\n\n      const cells = lineCells(\n        candidate.start,\n        candidate.end,\n        width,\n        cellSize / 2,\n      );\n      const bboxes = cells.map((c) => {\n        return {\n          minX: c.x - cellSize / 2,\n          minY: c.y - cellSize / 2,\n          maxX: c.x + cellSize / 2,\n          maxY: c.y + cellSize / 2,\n        };\n      });\n\n      const draw = (ctx: CanvasRenderingContext2D) => {\n        ctx.globalAlpha = 1;\n        // ctx.beginPath();\n        // ctx.moveTo(0, 0);\n        // ctx.lineTo(dx, dy);\n        // ctx.strokeStyle = \"red\";\n        // ctx.stroke();\n        ctx.rotate(Math.atan2(dy, dx));\n        if (dx < 0) {\n          ctx.scale(-1, -1);\n          ctx.translate(-width, 0);\n        }\n        let heightPlacement = 0;\n        if (this.position === LineLabelPlacement.Below)\n          heightPlacement += height;\n        else if (this.position === LineLabelPlacement.Center)\n          heightPlacement += height / 2;\n        ctx.translate(\n          0,\n          heightPlacement - this.offset.get(layout.zoom, feature),\n        );\n        ctx.font = font;\n        const lineWidth = this.width.get(layout.zoom, feature);\n        if (lineWidth) {\n          ctx.lineWidth = lineWidth;\n          ctx.strokeStyle = this.stroke.get(layout.zoom, feature);\n          ctx.strokeText(name, 0, 0);\n        }\n        ctx.fillStyle = this.fill.get(layout.zoom, feature);\n        ctx.fillText(name, 0, 0);\n      };\n      labels.push({\n        anchor: candidate.start,\n        bboxes: bboxes,\n        draw: draw,\n        deduplicationKey: name,\n        deduplicationDistance: repeatDistance,\n      });\n    }\n\n    return labels;\n  }\n}\n","import { Feature } from \"./tilecache\";\n\nexport type AttrOption<T> = T | ((z: number, f?: Feature) => T);\n\nexport class StringAttr<T extends string = string> {\n  str: AttrOption<T>;\n  perFeature: boolean;\n\n  constructor(c: AttrOption<T> | undefined, defaultValue: T) {\n    this.str = c ?? defaultValue;\n    this.perFeature = typeof this.str === \"function\" && this.str.length === 2;\n  }\n\n  public get(z: number, f?: Feature): T {\n    if (typeof this.str === \"function\") {\n      return this.str(z, f);\n    }\n    return this.str;\n  }\n}\n\nexport class NumberAttr {\n  value: AttrOption<number>;\n  perFeature: boolean;\n\n  constructor(c: AttrOption<number> | undefined, defaultValue = 1) {\n    this.value = c ?? defaultValue;\n    this.perFeature =\n      typeof this.value === \"function\" && this.value.length === 2;\n  }\n\n  public get(z: number, f?: Feature): number {\n    if (typeof this.value === \"function\") {\n      return this.value(z, f);\n    }\n    return this.value;\n  }\n}\n\nexport interface TextAttrOptions {\n  labelProps?: AttrOption<string[]>;\n  textTransform?: AttrOption<string>;\n}\n\nexport class TextAttr {\n  labelProps: AttrOption<string[]>;\n  textTransform?: AttrOption<string>;\n\n  constructor(options?: TextAttrOptions) {\n    this.labelProps = options?.labelProps ?? [\"name\"];\n    this.textTransform = options?.textTransform;\n  }\n\n  public get(z: number, f: Feature): string | undefined {\n    let retval: string | undefined;\n\n    let labelProps: string[];\n    if (typeof this.labelProps === \"function\") {\n      labelProps = this.labelProps(z, f);\n    } else {\n      labelProps = this.labelProps;\n    }\n    for (const property of labelProps) {\n      if (\n        Object.prototype.hasOwnProperty.call(f.props, property) &&\n        typeof f.props[property] === \"string\"\n      ) {\n        retval = f.props[property] as string;\n        break;\n      }\n    }\n    let transform: string | ((z: number, f: Feature) => string) | undefined;\n    if (typeof this.textTransform === \"function\") {\n      transform = this.textTransform(z, f);\n    } else {\n      transform = this.textTransform;\n    }\n    if (retval && transform === \"uppercase\") retval = retval.toUpperCase();\n    else if (retval && transform === \"lowercase\") retval = retval.toLowerCase();\n    else if (retval && transform === \"capitalize\") {\n      const wordsArray = retval.toLowerCase().split(\" \");\n      const capsArray = wordsArray.map((word: string) => {\n        return word[0].toUpperCase() + word.slice(1);\n      });\n      retval = capsArray.join(\" \");\n    }\n    return retval;\n  }\n}\n\nexport interface FontAttrOptions {\n  font?: AttrOption<string>;\n  fontFamily?: AttrOption<string>;\n  fontSize?: AttrOption<number>;\n  fontWeight?: AttrOption<number>;\n  fontStyle?: AttrOption<string>;\n}\n\nexport class FontAttr {\n  family?: AttrOption<string>;\n  size?: AttrOption<number>;\n  weight?: AttrOption<number>;\n  style?: AttrOption<string>;\n  font?: AttrOption<string>;\n\n  constructor(options?: FontAttrOptions) {\n    if (options?.font) {\n      this.font = options.font;\n    } else {\n      this.family = options?.fontFamily ?? \"sans-serif\";\n      this.size = options?.fontSize ?? 12;\n      this.weight = options?.fontWeight;\n      this.style = options?.fontStyle;\n    }\n  }\n\n  public get(z: number, f?: Feature) {\n    if (this.font) {\n      if (typeof this.font === \"function\") {\n        return this.font(z, f);\n      }\n      return this.font;\n    }\n    let style = \"\";\n    if (this.style) {\n      if (typeof this.style === \"function\") {\n        style = `${this.style(z, f)} `;\n      } else {\n        style = `${this.style} `;\n      }\n    }\n\n    let weight = \"\";\n    if (this.weight) {\n      if (typeof this.weight === \"function\") {\n        weight = `${this.weight(z, f)} `;\n      } else {\n        weight = `${this.weight} `;\n      }\n    }\n\n    let size: number | ((z: number, f: Feature) => number) | undefined;\n    if (typeof this.size === \"function\") {\n      size = this.size(z, f);\n    } else {\n      size = this.size;\n    }\n\n    let family: string | ((z: number, f: Feature) => string) | undefined;\n    if (typeof this.family === \"function\") {\n      family = this.family(z, f);\n    } else {\n      family = this.family;\n    }\n\n    return `${style}${weight}${size}px ${family}`;\n  }\n}\n\nexport class ArrayAttr<T = number> {\n  value: AttrOption<T[]>;\n  perFeature: boolean;\n\n  constructor(c: AttrOption<T[]>, defaultValue: T[] = []) {\n    this.value = c ?? defaultValue;\n    this.perFeature =\n      typeof this.value === \"function\" && this.value.length === 2;\n  }\n\n  public get(z: number, f?: Feature): T[] {\n    if (typeof this.value === \"function\") {\n      return this.value(z, f);\n    }\n    return this.value;\n  }\n}\n","import Point from \"@mapbox/point-geometry\";\n\nexport interface LabelableSegment {\n  length: number;\n  beginIndex: number;\n  beginDistance: number;\n  endIndex: number;\n  endDistance: number;\n}\n\n// code from https://github.com/naturalatlas/linelabel (Apache2)\nconst linelabel = (\n  pts: Point[],\n  maxAngleDelta: number,\n  targetLen: number,\n): LabelableSegment[] => {\n  const chunks = [];\n  let a: Point;\n  let b: Point;\n  let c: Point;\n  let i = 0;\n  let n = 0;\n  let d = 0;\n  let abmag = 0;\n  let bcmag = 0;\n  let abx = 0;\n  let aby = 0;\n  let bcx = 0;\n  let bcy = 0;\n  let dt = 0;\n  let iStart = 0;\n  let dStart = 0;\n\n  if (pts.length < 2) return [];\n  if (pts.length === 2) {\n    d = Math.sqrt((pts[1].x - pts[0].x) ** 2 + (pts[1].y - pts[0].y) ** 2);\n\n    return [\n      {\n        length: d,\n        beginIndex: 0,\n        beginDistance: 0,\n        endIndex: 2,\n        endDistance: d,\n      },\n    ];\n  }\n\n  abmag = Math.sqrt((pts[1].x - pts[0].x) ** 2 + (pts[1].y - pts[0].y) ** 2);\n  for (i = 1, n = pts.length - 1; i < n; i++) {\n    a = pts[i - 1];\n    b = pts[i];\n    c = pts[i + 1];\n    abx = b.x - a.x;\n    aby = b.y - a.y;\n    bcx = c.x - b.x;\n    bcy = c.y - b.y;\n    bcmag = Math.sqrt(bcx * bcx + bcy * bcy);\n    d += abmag;\n\n    dt = Math.acos((abx * bcx + aby * bcy) / (abmag * bcmag));\n    if (dt > maxAngleDelta || d - dStart > targetLen) {\n      chunks.push({\n        length: d - dStart,\n        beginDistance: dStart,\n        beginIndex: iStart,\n        endIndex: i + 1,\n        endDistance: d,\n      });\n      iStart = i;\n      dStart = d;\n    }\n    abmag = bcmag;\n  }\n\n  if (i - iStart > 0) {\n    chunks.push({\n      length: d - dStart + bcmag,\n      beginIndex: iStart,\n      beginDistance: dStart,\n      endIndex: i + 1,\n      endDistance: d + bcmag,\n    });\n  }\n  return chunks;\n};\n\nexport interface LabelCandidate {\n  start: Point;\n  end: Point;\n}\n\nexport function simpleLabel(\n  mls: Point[][],\n  minimum: number,\n  repeatDistance: number,\n  cellSize: number,\n): LabelCandidate[] {\n  const candidates = [];\n\n  for (const ls of mls) {\n    const segments = linelabel(ls, Math.PI / 45, minimum); // 4 degrees, close to a straight line\n    for (const segment of segments) {\n      if (segment.length >= minimum + cellSize) {\n        const start = new Point(\n          ls[segment.beginIndex].x,\n          ls[segment.beginIndex].y,\n        );\n        const end = ls[segment.endIndex - 1];\n        const normalized = new Point(\n          (end.x - start.x) / segment.length,\n          (end.y - start.y) / segment.length,\n        );\n\n        // offset from the start by cellSize to allow streets that meet at right angles\n        // to both be labeled.\n        for (\n          let i = cellSize;\n          i < segment.length - minimum;\n          i += repeatDistance\n        ) {\n          candidates.push({\n            start: start.add(normalized.mult(i)),\n            end: start.add(normalized.mult(i + minimum)),\n          });\n        }\n      }\n    }\n  }\n\n  return candidates;\n}\n\nexport function lineCells(a: Point, b: Point, length: number, spacing: number) {\n  // determine function of line\n  const dx = b.x - a.x;\n  const dy = b.y - a.y;\n  const dist = Math.sqrt((b.x - a.x) ** 2 + (b.y - a.y) ** 2);\n\n  const retval = [];\n  // starting from the anchor, generate square cells,\n  // guaranteeing to cover the endpoint\n  for (let i = 0; i < length + spacing; i += 2 * spacing) {\n    const factor = (i * 1) / dist;\n    retval.push({ x: a.x + factor * dx, y: a.y + factor * dy });\n  }\n  return retval;\n}\n","// TODO should be visual length in pixels, not strlen\nexport function linebreak(str: string, maxUnits: number): string[] {\n  if (str.length <= maxUnits) return [str];\n  const endIndex = maxUnits - 1;\n  const spaceBefore = str.lastIndexOf(\" \", endIndex);\n  const spaceAfter = str.indexOf(\" \", endIndex);\n  if (spaceBefore === -1 && spaceAfter === -1) {\n    return [str];\n  }\n  let first: string;\n  let after: string;\n  if (\n    spaceAfter === -1 ||\n    (spaceBefore >= 0 && endIndex - spaceBefore < spaceAfter - endIndex)\n  ) {\n    first = str.substring(0, spaceBefore);\n    after = str.substring(spaceBefore + 1, str.length);\n  } else {\n    first = str.substring(0, spaceAfter);\n    after = str.substring(spaceAfter + 1, str.length);\n  }\n  return [first, ...linebreak(after, maxUnits)];\n}\n\nconst CJK_CHARS =\n  \"\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3220-\\u3229\\u3248-\\u324F\\u3251-\\u325F\\u3280-\\u3289\\u32B1-\\u32BF\\u3400-\\u4DB5\\u4E00-\\u9FEA\\uF900-\\uFA6D\\uFA70-\\uFAD9\\u2000\";\nconst cjkTest = new RegExp(`^[${CJK_CHARS}]+$`);\n\nexport function isCjk(s: string) {\n  return cjkTest.test(s);\n}\n","import Point from \"@mapbox/point-geometry\";\nimport { VectorTile } from \"@mapbox/vector-tile\";\nimport Protobuf from \"pbf\";\nimport { PMTiles } from \"pmtiles\";\n\nexport type JsonValue =\n  | boolean\n  | number\n  | string\n  | null\n  | JsonArray\n  | JsonObject;\nexport interface JsonObject {\n  [key: string]: JsonValue;\n}\nexport interface JsonArray extends Array<JsonValue> {}\n\nexport enum GeomType {\n  Point = 1,\n  Line = 2,\n  Polygon = 3,\n}\n\nexport interface Bbox {\n  minX: number;\n  minY: number;\n  maxX: number;\n  maxY: number;\n}\n\nexport interface Feature {\n  readonly props: JsonObject;\n  readonly bbox: Bbox;\n  readonly geomType: GeomType;\n  readonly geom: Point[][];\n  readonly numVertices: number;\n}\n\nexport interface Zxy {\n  readonly z: number;\n  readonly x: number;\n  readonly y: number;\n}\n\nexport function toIndex(c: Zxy): string {\n  return `${c.x}:${c.y}:${c.z}`;\n}\n\nexport interface TileSource {\n  get(c: Zxy, tileSize: number): Promise<Map<string, Feature[]>>;\n}\n\ninterface ZoomAbort {\n  z: number;\n  controller: AbortController;\n}\n\n// reimplement loadGeometry with a scalefactor\n// so the general tile rendering case does not need rescaling.\nconst loadGeomAndBbox = (pbf: Protobuf, geometry: number, scale: number) => {\n  pbf.pos = geometry;\n  const end = pbf.readVarint() + pbf.pos;\n  let cmd = 1;\n  let length = 0;\n  let x = 0;\n  let y = 0;\n  let x1 = Infinity;\n  let x2 = -Infinity;\n  let y1 = Infinity;\n  let y2 = -Infinity;\n\n  const lines: Point[][] = [];\n  let line: Point[] = [];\n  while (pbf.pos < end) {\n    if (length <= 0) {\n      const cmdLen = pbf.readVarint();\n      cmd = cmdLen & 0x7;\n      length = cmdLen >> 3;\n    }\n    length--;\n    if (cmd === 1 || cmd === 2) {\n      x += pbf.readSVarint() * scale;\n      y += pbf.readSVarint() * scale;\n      if (x < x1) x1 = x;\n      if (x > x2) x2 = x;\n      if (y < y1) y1 = y;\n      if (y > y2) y2 = y;\n      if (cmd === 1) {\n        if (line.length > 0) lines.push(line);\n        line = [];\n      }\n      line.push(new Point(x, y));\n    } else if (cmd === 7) {\n      if (line) line.push(line[0].clone());\n    } else throw new Error(`unknown command ${cmd}`);\n  }\n  if (line) lines.push(line);\n  return { geom: lines, bbox: { minX: x1, minY: y1, maxX: x2, maxY: y2 } };\n};\n\nfunction parseTile(\n  buffer: ArrayBuffer,\n  tileSize: number,\n): Map<string, Feature[]> {\n  const v = new VectorTile(new Protobuf(buffer));\n  const result = new Map<string, Feature[]>();\n  for (const [key, value] of Object.entries(v.layers)) {\n    const features = [];\n    // biome-ignore lint: need to use private fields of vector-tile\n    const layer = value as any;\n    for (let i = 0; i < layer.length; i++) {\n      const loaded = loadGeomAndBbox(\n        layer.feature(i)._pbf,\n        layer.feature(i)._geometry,\n        tileSize / layer.extent,\n      );\n      let numVertices = 0;\n      for (const part of loaded.geom) numVertices += part.length;\n      features.push({\n        id: layer.feature(i).id,\n        geomType: layer.feature(i).type,\n        geom: loaded.geom,\n        numVertices: numVertices,\n        bbox: loaded.bbox,\n        props: layer.feature(i).properties,\n      });\n    }\n    result.set(key, features);\n  }\n  return result;\n}\n\nexport class PmtilesSource implements TileSource {\n  p: PMTiles;\n  zoomaborts: ZoomAbort[];\n  shouldCancelZooms: boolean;\n\n  constructor(url: string | PMTiles, shouldCancelZooms: boolean) {\n    if (typeof url === \"string\") {\n      this.p = new PMTiles(url);\n    } else {\n      this.p = url;\n    }\n    this.zoomaborts = [];\n    this.shouldCancelZooms = shouldCancelZooms;\n  }\n\n  public async get(c: Zxy, tileSize: number): Promise<Map<string, Feature[]>> {\n    if (this.shouldCancelZooms) {\n      this.zoomaborts = this.zoomaborts.filter((za) => {\n        if (za.z !== c.z) {\n          za.controller.abort();\n          return false;\n        }\n        return true;\n      });\n    }\n    const controller = new AbortController();\n    this.zoomaborts.push({ z: c.z, controller: controller });\n    const signal = controller.signal;\n\n    const result = await this.p.getZxy(c.z, c.x, c.y, signal);\n\n    if (result) {\n      return parseTile(result.data, tileSize);\n    }\n    return new Map<string, Feature[]>();\n  }\n}\n\nexport class ZxySource implements TileSource {\n  url: string;\n  zoomaborts: ZoomAbort[];\n  shouldCancelZooms: boolean;\n\n  constructor(url: string, shouldCancelZooms: boolean) {\n    this.url = url;\n    this.zoomaborts = [];\n    this.shouldCancelZooms = shouldCancelZooms;\n  }\n\n  public async get(c: Zxy, tileSize: number): Promise<Map<string, Feature[]>> {\n    if (this.shouldCancelZooms) {\n      this.zoomaborts = this.zoomaborts.filter((za) => {\n        if (za.z !== c.z) {\n          za.controller.abort();\n          return false;\n        }\n        return true;\n      });\n    }\n    const url = this.url\n      .replace(\"{z}\", c.z.toString())\n      .replace(\"{x}\", c.x.toString())\n      .replace(\"{y}\", c.y.toString());\n    const controller = new AbortController();\n    this.zoomaborts.push({ z: c.z, controller: controller });\n    const signal = controller.signal;\n    return new Promise((resolve, reject) => {\n      fetch(url, { signal: signal })\n        .then((resp) => {\n          return resp.arrayBuffer();\n        })\n        .then((buffer) => {\n          const result = parseTile(buffer, tileSize);\n          resolve(result);\n        })\n        .catch((e) => {\n          reject(e);\n        });\n    });\n  }\n}\n\ninterface CacheEntry {\n  used: number;\n  data: Map<string, Feature[]>;\n}\n\ninterface PromiseOptions {\n  resolve: (result: Map<string, Feature[]>) => void;\n  reject: (e: Error) => void;\n}\n\nexport interface PickedFeature {\n  feature: Feature;\n  layerName: string;\n}\n\nconst R = 6378137;\nconst MAX_LATITUDE = 85.0511287798;\nconst MAXCOORD = R * Math.PI;\n\nconst project = (latlng: number[]) => {\n  const d = Math.PI / 180;\n  const constrainedLat = Math.max(\n    Math.min(MAX_LATITUDE, latlng[0]),\n    -MAX_LATITUDE,\n  );\n  const sin = Math.sin(constrainedLat * d);\n  return new Point(\n    R * latlng[1] * d,\n    (R * Math.log((1 + sin) / (1 - sin))) / 2,\n  );\n};\n\nfunction sqr(x: number) {\n  return x * x;\n}\n\nfunction dist2(v: Point, w: Point) {\n  return sqr(v.x - w.x) + sqr(v.y - w.y);\n}\n\nfunction distToSegmentSquared(p: Point, v: Point, w: Point) {\n  const l2 = dist2(v, w);\n  if (l2 === 0) return dist2(p, v);\n  let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;\n  t = Math.max(0, Math.min(1, t));\n  return dist2(p, new Point(v.x + t * (w.x - v.x), v.y + t * (w.y - v.y)));\n}\n\nexport function isInRing(point: Point, ring: Point[]): boolean {\n  let inside = false;\n  for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n    const xi = ring[i].x;\n    const yi = ring[i].y;\n    const xj = ring[j].x;\n    const yj = ring[j].y;\n    const intersect =\n      yi > point.y !== yj > point.y &&\n      point.x < ((xj - xi) * (point.y - yi)) / (yj - yi) + xi;\n    if (intersect) inside = !inside;\n  }\n  return inside;\n}\n\nexport function isCcw(ring: Point[]): boolean {\n  let area = 0;\n  for (let i = 0; i < ring.length; i++) {\n    const j = (i + 1) % ring.length;\n    area += ring[i].x * ring[j].y;\n    area -= ring[j].x * ring[i].y;\n  }\n  return area < 0;\n}\n\nexport function pointInPolygon(point: Point, geom: Point[][]): boolean {\n  let isInCurrentExterior = false;\n  for (const ring of geom) {\n    if (isCcw(ring)) {\n      // it is an interior ring\n      if (isInRing(point, ring)) isInCurrentExterior = false;\n    } else {\n      // it is an exterior ring\n      if (isInCurrentExterior) return true;\n      if (isInRing(point, ring)) isInCurrentExterior = true;\n    }\n  }\n  return isInCurrentExterior;\n}\n\nexport function pointMinDistToPoints(point: Point, geom: Point[][]): number {\n  let min = Infinity;\n  for (const l of geom) {\n    const dist = Math.sqrt(dist2(point, l[0]));\n    if (dist < min) min = dist;\n  }\n  return min;\n}\n\nexport function pointMinDistToLines(point: Point, geom: Point[][]): number {\n  let min = Infinity;\n  for (const l of geom) {\n    for (let i = 0; i < l.length - 1; i++) {\n      const dist = Math.sqrt(distToSegmentSquared(point, l[i], l[i + 1]));\n      if (dist < min) min = dist;\n    }\n  }\n  return min;\n}\n\nexport class TileCache {\n  source: TileSource;\n  cache: Map<string, CacheEntry>;\n  inflight: Map<string, PromiseOptions[]>;\n  tileSize: number;\n\n  constructor(source: TileSource, tileSize: number) {\n    this.source = source;\n    this.cache = new Map<string, CacheEntry>();\n    this.inflight = new Map<string, PromiseOptions[]>();\n    this.tileSize = tileSize;\n  }\n\n  public async get(c: Zxy): Promise<Map<string, Feature[]>> {\n    const idx = toIndex(c);\n    return new Promise((resolve, reject) => {\n      const entry = this.cache.get(idx);\n      if (entry) {\n        entry.used = performance.now();\n        resolve(entry.data);\n      } else {\n        const ifentry = this.inflight.get(idx);\n        if (ifentry) {\n          ifentry.push({ resolve: resolve, reject: reject });\n        } else {\n          this.inflight.set(idx, []);\n          this.source\n            .get(c, this.tileSize)\n            .then((tile) => {\n              this.cache.set(idx, { used: performance.now(), data: tile });\n\n              const ifentry2 = this.inflight.get(idx);\n              if (ifentry2) {\n                for (const f of ifentry2) {\n                  f.resolve(tile);\n                }\n              }\n              this.inflight.delete(idx);\n              resolve(tile);\n\n              if (this.cache.size >= 64) {\n                let minUsed = +Infinity;\n                let minKey = undefined;\n                this.cache.forEach((value, key) => {\n                  if (value.used < minUsed) {\n                    minUsed = value.used;\n                    minKey = key;\n                  }\n                });\n                if (minKey) this.cache.delete(minKey);\n              }\n            })\n            .catch((e) => {\n              const ifentry2 = this.inflight.get(idx);\n              if (ifentry2) {\n                for (const f of ifentry2) {\n                  f.reject(e);\n                }\n              }\n              this.inflight.delete(idx);\n              reject(e);\n            });\n        }\n      }\n    });\n  }\n\n  public queryFeatures(\n    lng: number,\n    lat: number,\n    zoom: number,\n    brushSize: number,\n  ): PickedFeature[] {\n    const projected = project([lat, lng]);\n    const normalized = new Point(\n      (projected.x + MAXCOORD) / (MAXCOORD * 2),\n      1 - (projected.y + MAXCOORD) / (MAXCOORD * 2),\n    );\n    if (normalized.x > 1)\n      normalized.x = normalized.x - Math.floor(normalized.x);\n    const onZoom = normalized.mult(1 << zoom);\n    const tileX = Math.floor(onZoom.x);\n    const tileY = Math.floor(onZoom.y);\n    const idx = toIndex({ z: zoom, x: tileX, y: tileY });\n    const retval: PickedFeature[] = [];\n    const entry = this.cache.get(idx);\n    if (entry) {\n      const center = new Point(\n        (onZoom.x - tileX) * this.tileSize,\n        (onZoom.y - tileY) * this.tileSize,\n      );\n      for (const [layerName, layerArr] of entry.data.entries()) {\n        for (const feature of layerArr) {\n          if (feature.geomType === GeomType.Point) {\n            if (pointMinDistToPoints(center, feature.geom) < brushSize) {\n              retval.push({ feature, layerName: layerName });\n            }\n          } else if (feature.geomType === GeomType.Line) {\n            if (pointMinDistToLines(center, feature.geom) < brushSize) {\n              retval.push({ feature, layerName: layerName });\n            }\n          } else {\n            if (pointInPolygon(center, feature.geom)) {\n              retval.push({ feature, layerName: layerName });\n            }\n          }\n        }\n      }\n    }\n    return retval;\n  }\n}\n","import Point from \"@mapbox/point-geometry\";\nimport rBush from \"rbush\";\nimport { Filter } from \"./painter\";\nimport { DrawExtra, LabelSymbolizer } from \"./symbolizer\";\nimport { Bbox, JsonObject, toIndex } from \"./tilecache\";\nimport { PreparedTile, transformGeom } from \"./view\";\n\ntype TileInvalidationCallback = (tiles: Set<string>) => void;\n\n// the anchor should be contained within, or on the boundary of,\n// one of the bounding boxes. This is not enforced by library,\n// but is required for label deduplication.\nexport interface Label {\n  anchor: Point;\n  bboxes: Bbox[];\n  draw: (ctx: CanvasRenderingContext2D, drawExtra?: DrawExtra) => void;\n  deduplicationKey?: string;\n  deduplicationDistance?: number;\n}\n\nexport interface IndexedLabel {\n  anchor: Point;\n  bboxes: Bbox[];\n  draw: (ctx: CanvasRenderingContext2D) => void;\n  order: number;\n  tileKey: string;\n  deduplicationKey?: string;\n  deduplicationDistance?: number;\n}\n\ntype TreeItem = Bbox & { indexedLabel: IndexedLabel };\n\nexport interface Layout {\n  index: Index;\n  order: number;\n  scratch: CanvasRenderingContext2D;\n  zoom: number;\n  overzoom: number;\n}\n\nexport interface LabelRule {\n  id?: string;\n  minzoom?: number;\n  maxzoom?: number;\n  dataSource?: string;\n  dataLayer: string;\n  symbolizer: LabelSymbolizer;\n  filter?: Filter;\n  visible?: boolean;\n  sort?: (a: JsonObject, b: JsonObject) => number;\n}\n\nexport const covering = (\n  displayZoom: number,\n  tileWidth: number,\n  bbox: Bbox,\n) => {\n  const res = 256;\n  const f = tileWidth / res;\n\n  const minx = Math.floor(bbox.minX / res);\n  const miny = Math.floor(bbox.minY / res);\n  const maxx = Math.floor(bbox.maxX / res);\n  const maxy = Math.floor(bbox.maxY / res);\n  const leveldiff = Math.log2(f);\n\n  const retval = [];\n  for (let x = minx; x <= maxx; x++) {\n    const wrappedX = x % (1 << displayZoom);\n    for (let y = miny; y <= maxy; y++) {\n      retval.push({\n        display: toIndex({ z: displayZoom, x: wrappedX, y: y }),\n        key: toIndex({\n          z: displayZoom - leveldiff,\n          x: Math.floor(wrappedX / f),\n          y: Math.floor(y / f),\n        }),\n      });\n    }\n  }\n  return retval;\n};\n\nexport class Index {\n  tree: rBush<TreeItem>;\n  current: Map<string, Set<IndexedLabel>>;\n  dim: number;\n  maxLabeledTiles: number;\n\n  constructor(dim: number, maxLabeledTiles: number) {\n    this.tree = new rBush();\n    this.current = new Map();\n    this.dim = dim;\n    this.maxLabeledTiles = maxLabeledTiles;\n  }\n\n  public hasPrefix(tileKey: string): boolean {\n    for (const key of this.current.keys()) {\n      if (key.startsWith(tileKey)) return true;\n    }\n    return false;\n  }\n\n  public has(tileKey: string): boolean {\n    return this.current.has(tileKey);\n  }\n\n  public size(): number {\n    return this.current.size;\n  }\n\n  public keys() {\n    return this.current.keys();\n  }\n\n  public searchBbox(bbox: Bbox, order: number): Set<IndexedLabel> {\n    const labels = new Set<IndexedLabel>();\n    for (const match of this.tree.search(bbox)) {\n      if (match.indexedLabel.order <= order) {\n        labels.add(match.indexedLabel);\n      }\n    }\n    return labels;\n  }\n\n  public searchLabel(label: Label, order: number): Set<IndexedLabel> {\n    const labels = new Set<IndexedLabel>();\n    for (const bbox of label.bboxes) {\n      for (const match of this.tree.search(bbox)) {\n        if (match.indexedLabel.order <= order) {\n          labels.add(match.indexedLabel);\n        }\n      }\n    }\n    return labels;\n  }\n\n  public bboxCollides(bbox: Bbox, order: number): boolean {\n    for (const match of this.tree.search(bbox)) {\n      if (match.indexedLabel.order <= order) return true;\n    }\n    return false;\n  }\n\n  public labelCollides(label: Label, order: number): boolean {\n    for (const bbox of label.bboxes) {\n      for (const match of this.tree.search(bbox)) {\n        if (match.indexedLabel.order <= order) return true;\n      }\n    }\n    return false;\n  }\n\n  public deduplicationCollides(label: Label): boolean {\n    // create a bbox around anchor to find potential matches.\n    // this is depending on precondition: (anchor is contained within, or on boundary of, a label bbox)\n    if (!label.deduplicationKey || !label.deduplicationDistance) return false;\n    const dist = label.deduplicationDistance;\n    const testBbox = {\n      minX: label.anchor.x - dist,\n      minY: label.anchor.y - dist,\n      maxX: label.anchor.x + dist,\n      maxY: label.anchor.y + dist,\n    };\n    for (const collision of this.tree.search(testBbox)) {\n      if (collision.indexedLabel.deduplicationKey === label.deduplicationKey) {\n        if (collision.indexedLabel.anchor.dist(label.anchor) < dist) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  public makeEntry(tileKey: string) {\n    if (this.current.get(tileKey)) {\n      console.log(\"consistency error 1\");\n    }\n    const newSet = new Set<IndexedLabel>();\n    this.current.set(tileKey, newSet);\n  }\n\n  // can put in multiple due to antimeridian wrapping\n  public insert(label: Label, order: number, tileKey: string): void {\n    const indexedLabel = {\n      anchor: label.anchor,\n      bboxes: label.bboxes,\n      draw: label.draw,\n      order: order,\n      tileKey: tileKey,\n      deduplicationKey: label.deduplicationKey,\n      deduplicationDistance: label.deduplicationDistance,\n    };\n    let entry = this.current.get(tileKey);\n    if (!entry) {\n      const newSet = new Set<IndexedLabel>();\n      this.current.set(tileKey, newSet);\n      entry = newSet;\n    }\n    entry.add(indexedLabel);\n\n    let wrapsLeft = false;\n    let wrapsRight = false;\n    for (const bbox of label.bboxes) {\n      this.tree.insert({\n        minX: bbox.minX,\n        minY: bbox.minY,\n        maxX: bbox.maxX,\n        maxY: bbox.maxY,\n        indexedLabel: indexedLabel,\n      });\n      if (bbox.minX < 0) wrapsLeft = true;\n      if (bbox.maxX > this.dim) wrapsRight = true;\n    }\n\n    if (wrapsLeft || wrapsRight) {\n      const shift = wrapsLeft ? this.dim : -this.dim;\n\n      const newBboxes = [];\n      for (const bbox of label.bboxes) {\n        newBboxes.push({\n          minX: bbox.minX + shift,\n          minY: bbox.minY,\n          maxX: bbox.maxX + shift,\n          maxY: bbox.maxY,\n        });\n      }\n      const duplicateLabel = {\n        anchor: new Point(label.anchor.x + shift, label.anchor.y),\n        bboxes: newBboxes,\n        draw: label.draw,\n        order: order,\n        tileKey: tileKey,\n      };\n      const entry = this.current.get(tileKey);\n      if (entry) entry.add(duplicateLabel);\n      for (const bbox of newBboxes) {\n        this.tree.insert({\n          minX: bbox.minX,\n          minY: bbox.minY,\n          maxX: bbox.maxX,\n          maxY: bbox.maxY,\n          indexedLabel: duplicateLabel,\n        });\n      }\n    }\n  }\n\n  public pruneOrNoop(keyAdded: string) {\n    const added = keyAdded.split(\":\");\n    let maxKey = undefined;\n    let maxDist = 0;\n    let keysForDs = 0;\n\n    for (const existingKey of this.current.keys()) {\n      const existing = existingKey.split(\":\");\n      if (existing[3] === added[3]) {\n        keysForDs++;\n        const dist = Math.sqrt(\n          (+existing[0] - +added[0]) ** 2 + (+existing[1] - +added[1]) ** 2,\n        );\n        if (dist > maxDist) {\n          maxDist = dist;\n          maxKey = existingKey;\n        }\n      }\n\n      if (maxKey && keysForDs > this.maxLabeledTiles) {\n        this.pruneKey(maxKey);\n      }\n    }\n  }\n\n  public pruneKey(keyToRemove: string): void {\n    const indexedLabels = this.current.get(keyToRemove);\n    if (!indexedLabels) return; // TODO: not that clean...\n    const entriesToDelete = [];\n    for (const entry of this.tree.all()) {\n      if (indexedLabels.has(entry.indexedLabel)) {\n        entriesToDelete.push(entry);\n      }\n    }\n    for (const entry of entriesToDelete) {\n      this.tree.remove(entry);\n    }\n    this.current.delete(keyToRemove);\n  }\n\n  // NOTE: technically this is incorrect\n  // with antimeridian wrapping, since we should also remove\n  // the duplicate label; but i am having a hard time\n  // imagining where this will happen in practical usage\n  public removeLabel(labelToRemove: IndexedLabel): void {\n    const entriesToDelete = [];\n    for (const entry of this.tree.all()) {\n      if (labelToRemove === entry.indexedLabel) {\n        entriesToDelete.push(entry);\n      }\n    }\n    for (const entry of entriesToDelete) {\n      this.tree.remove(entry);\n    }\n    const c = this.current.get(labelToRemove.tileKey);\n    if (c) c.delete(labelToRemove);\n  }\n}\n\nexport class Labeler {\n  index: Index;\n  z: number;\n  scratch: CanvasRenderingContext2D;\n  labelRules: LabelRule[];\n  callback?: TileInvalidationCallback;\n\n  constructor(\n    z: number,\n    scratch: CanvasRenderingContext2D,\n    labelRules: LabelRule[],\n    maxLabeledTiles: number,\n    callback?: TileInvalidationCallback,\n  ) {\n    this.index = new Index((256 * 1) << z, maxLabeledTiles);\n    this.z = z;\n    this.scratch = scratch;\n    this.labelRules = labelRules;\n    this.callback = callback;\n  }\n\n  private layout(preparedTilemap: Map<string, PreparedTile[]>): number {\n    const start = performance.now();\n\n    const keysAdding = new Set<string>();\n    // if it already exists... short circuit\n    for (const [k, preparedTiles] of preparedTilemap) {\n      for (const preparedTile of preparedTiles) {\n        const key = `${toIndex(preparedTile.dataTile)}:${k}`;\n        if (!this.index.has(key)) {\n          this.index.makeEntry(key);\n          keysAdding.add(key);\n        }\n      }\n    }\n\n    const tilesInvalidated = new Set<string>();\n    for (const [order, rule] of this.labelRules.entries()) {\n      if (rule.visible === false) continue;\n      if (rule.minzoom && this.z < rule.minzoom) continue;\n      if (rule.maxzoom && this.z > rule.maxzoom) continue;\n\n      const dsName = rule.dataSource || \"\";\n      const preparedTiles = preparedTilemap.get(dsName);\n      if (!preparedTiles) continue;\n\n      for (const preparedTile of preparedTiles) {\n        const key = `${toIndex(preparedTile.dataTile)}:${dsName}`;\n        if (!keysAdding.has(key)) continue;\n\n        const layer = preparedTile.data.get(rule.dataLayer);\n        if (layer === undefined) continue;\n\n        const feats = layer;\n        if (rule.sort)\n          feats.sort((a, b) => {\n            if (rule.sort) {\n              return rule.sort(a.props, b.props);\n            }\n            return 0;\n          });\n\n        const layout = {\n          index: this.index,\n          zoom: this.z,\n          scratch: this.scratch,\n          order: order,\n          overzoom: this.z - preparedTile.dataTile.z,\n        };\n        for (const feature of feats) {\n          if (rule.filter && !rule.filter(this.z, feature)) continue;\n          const transformed = transformGeom(\n            feature.geom,\n            preparedTile.scale,\n            preparedTile.origin,\n          );\n          const labels = rule.symbolizer.place(layout, transformed, feature);\n          if (!labels) continue;\n\n          for (const label of labels) {\n            let labelAdded = false;\n            if (\n              label.deduplicationKey &&\n              this.index.deduplicationCollides(label)\n            ) {\n              continue;\n            }\n\n            // does the label collide with anything?\n            if (this.index.labelCollides(label, Infinity)) {\n              if (!this.index.labelCollides(label, order)) {\n                const conflicts = this.index.searchLabel(label, Infinity);\n                for (const conflict of conflicts) {\n                  this.index.removeLabel(conflict);\n                  for (const bbox of conflict.bboxes) {\n                    this.findInvalidatedTiles(\n                      tilesInvalidated,\n                      preparedTile.dim,\n                      bbox,\n                      key,\n                    );\n                  }\n                }\n                this.index.insert(label, order, key);\n                labelAdded = true;\n              }\n              // label not added.\n            } else {\n              this.index.insert(label, order, key);\n              labelAdded = true;\n            }\n\n            if (labelAdded) {\n              for (const bbox of label.bboxes) {\n                if (\n                  bbox.maxX > preparedTile.origin.x + preparedTile.dim ||\n                  bbox.minX < preparedTile.origin.x ||\n                  bbox.minY < preparedTile.origin.y ||\n                  bbox.maxY > preparedTile.origin.y + preparedTile.dim\n                ) {\n                  this.findInvalidatedTiles(\n                    tilesInvalidated,\n                    preparedTile.dim,\n                    bbox,\n                    key,\n                  );\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    for (const key of keysAdding) {\n      this.index.pruneOrNoop(key);\n    }\n\n    if (tilesInvalidated.size > 0 && this.callback) {\n      this.callback(tilesInvalidated);\n    }\n    return performance.now() - start;\n  }\n\n  private findInvalidatedTiles(\n    tilesInvalidated: Set<string>,\n    dim: number,\n    bbox: Bbox,\n    key: string,\n  ) {\n    const touched = covering(this.z, dim, bbox);\n    for (const s of touched) {\n      if (s.key !== key && this.index.hasPrefix(s.key)) {\n        tilesInvalidated.add(s.display);\n      }\n    }\n  }\n\n  public add(preparedTilemap: Map<string, PreparedTile[]>): number {\n    let allAdded = true;\n    for (const [k, preparedTiles] of preparedTilemap) {\n      for (const preparedTile of preparedTiles) {\n        if (!this.index.has(`${toIndex(preparedTile.dataTile)}:${k}`))\n          allAdded = false;\n      }\n    }\n\n    if (allAdded) {\n      return 0;\n    }\n    const timing = this.layout(preparedTilemap);\n    return timing;\n  }\n}\n\nexport class Labelers {\n  labelers: Map<number, Labeler>;\n  scratch: CanvasRenderingContext2D;\n  labelRules: LabelRule[];\n  maxLabeledTiles: number;\n  callback: TileInvalidationCallback;\n\n  constructor(\n    scratch: CanvasRenderingContext2D,\n    labelRules: LabelRule[],\n    maxLabeledTiles: number,\n    callback: TileInvalidationCallback,\n  ) {\n    this.labelers = new Map<number, Labeler>();\n    this.scratch = scratch;\n    this.labelRules = labelRules;\n    this.maxLabeledTiles = maxLabeledTiles;\n    this.callback = callback;\n  }\n\n  public add(z: number, preparedTilemap: Map<string, PreparedTile[]>): number {\n    let labeler = this.labelers.get(z);\n    if (labeler) {\n      return labeler.add(preparedTilemap);\n    }\n    labeler = new Labeler(\n      z,\n      this.scratch,\n      this.labelRules,\n      this.maxLabeledTiles,\n      this.callback,\n    );\n    this.labelers.set(z, labeler);\n    return labeler.add(preparedTilemap);\n  }\n\n  public getIndex(z: number) {\n    const labeler = this.labelers.get(z);\n    if (labeler) return labeler.index; // TODO cleanup\n  }\n}\n","import Point from \"@mapbox/point-geometry\";\nimport { PMTiles } from \"pmtiles\";\nimport {\n  Bbox,\n  Feature,\n  PmtilesSource,\n  TileCache,\n  TileSource,\n  Zxy,\n  ZxySource,\n} from \"./tilecache\";\n\n/*\n * PreparedTile\n * For a given display Z:\n * layers: map of names-> features with coordinates in CSS pixel units.\n * translate: how to get layers coordinates to global Z coordinates.\n * dataTile: the Z,X,Y of the data tile.\n * window? if present, use as bounding box or canvas clipping area.\n */\nexport interface PreparedTile {\n  z: number; // the display zoom level that it is for\n  origin: Point; // the top-left corner in global CSS pixel coordinates\n  data: Map<string, Feature[]>; // return a map to Iterable\n  scale: number; // over or underzooming scale\n  dim: number; // the effective size of this tile on the zoom level\n  dataTile: Zxy; // the key of the raw tile\n}\n\nexport interface TileTransform {\n  dataTile: Zxy;\n  origin: Point;\n  scale: number;\n  dim: number;\n}\n\n// TODO make this lazy\nexport const transformGeom = (\n  geom: Array<Array<Point>>,\n  scale: number,\n  translate: Point,\n) => {\n  const retval = [];\n  for (const arr of geom) {\n    const loop = [];\n    for (const coord of arr) {\n      loop.push(coord.clone().mult(scale).add(translate));\n    }\n    retval.push(loop);\n  }\n  return retval;\n};\n\nexport const wrap = (val: number, z: number) => {\n  const dim = 1 << z;\n  if (val < 0) return dim + val;\n  if (val >= dim) return val % dim;\n  return val;\n};\n\n/*\n * @class View\n * expresses relationship between canvas coordinates and data tiles.\n */\nexport class View {\n  levelDiff: number;\n  tileCache: TileCache;\n  maxDataLevel: number;\n\n  constructor(tileCache: TileCache, maxDataLevel: number, levelDiff: number) {\n    this.tileCache = tileCache;\n    this.maxDataLevel = maxDataLevel;\n    this.levelDiff = levelDiff;\n  }\n\n  public dataTilesForBounds(\n    displayZoom: number,\n    bounds: Bbox,\n  ): Array<TileTransform> {\n    const fractional = 2 ** displayZoom / 2 ** Math.ceil(displayZoom);\n    const needed = [];\n    let scale = 1;\n    const dim = this.tileCache.tileSize;\n    if (displayZoom < this.levelDiff) {\n      scale = (1 / (1 << (this.levelDiff - displayZoom))) * fractional;\n      needed.push({\n        dataTile: { z: 0, x: 0, y: 0 },\n        origin: new Point(0, 0),\n        scale: scale,\n        dim: dim * scale,\n      });\n    } else if (displayZoom <= this.levelDiff + this.maxDataLevel) {\n      const f = 1 << this.levelDiff;\n\n      const basetileSize = 256 * fractional;\n\n      const dataZoom = Math.ceil(displayZoom) - this.levelDiff;\n\n      const mintileX = Math.floor(bounds.minX / f / basetileSize);\n      const mintileY = Math.floor(bounds.minY / f / basetileSize);\n      const maxtileX = Math.floor(bounds.maxX / f / basetileSize);\n      const maxtileY = Math.floor(bounds.maxY / f / basetileSize);\n      for (let tx = mintileX; tx <= maxtileX; tx++) {\n        for (let ty = mintileY; ty <= maxtileY; ty++) {\n          const origin = new Point(\n            tx * f * basetileSize,\n            ty * f * basetileSize,\n          );\n          needed.push({\n            dataTile: {\n              z: dataZoom,\n              x: wrap(tx, dataZoom),\n              y: wrap(ty, dataZoom),\n            },\n            origin: origin,\n            scale: fractional,\n            dim: dim * fractional,\n          });\n        }\n      }\n    } else {\n      const f = 1 << this.levelDiff;\n      scale =\n        (1 << (Math.ceil(displayZoom) - this.maxDataLevel - this.levelDiff)) *\n        fractional;\n      const mintileX = Math.floor(bounds.minX / f / 256 / scale);\n      const mintileY = Math.floor(bounds.minY / f / 256 / scale);\n      const maxtileX = Math.floor(bounds.maxX / f / 256 / scale);\n      const maxtileY = Math.floor(bounds.maxY / f / 256 / scale);\n      for (let tx = mintileX; tx <= maxtileX; tx++) {\n        for (let ty = mintileY; ty <= maxtileY; ty++) {\n          const origin = new Point(tx * f * 256 * scale, ty * f * 256 * scale);\n          needed.push({\n            dataTile: {\n              z: this.maxDataLevel,\n              x: wrap(tx, this.maxDataLevel),\n              y: wrap(ty, this.maxDataLevel),\n            },\n            origin: origin,\n            scale: scale,\n            dim: dim * scale,\n          });\n        }\n      }\n    }\n    return needed;\n  }\n\n  public dataTileForDisplayTile(displayTile: Zxy): TileTransform {\n    let dataTile: Zxy;\n    let scale = 1;\n    let dim = this.tileCache.tileSize;\n    let origin: Point;\n    if (displayTile.z < this.levelDiff) {\n      dataTile = { z: 0, x: 0, y: 0 };\n      scale = 1 / (1 << (this.levelDiff - displayTile.z));\n      origin = new Point(0, 0);\n      dim = dim * scale;\n    } else if (displayTile.z <= this.levelDiff + this.maxDataLevel) {\n      const f = 1 << this.levelDiff;\n      dataTile = {\n        z: displayTile.z - this.levelDiff,\n        x: Math.floor(displayTile.x / f),\n        y: Math.floor(displayTile.y / f),\n      };\n      origin = new Point(dataTile.x * f * 256, dataTile.y * f * 256);\n    } else {\n      scale = 1 << (displayTile.z - this.maxDataLevel - this.levelDiff);\n      const f = 1 << this.levelDiff;\n      dataTile = {\n        z: this.maxDataLevel,\n        x: Math.floor(displayTile.x / f / scale),\n        y: Math.floor(displayTile.y / f / scale),\n      };\n      origin = new Point(\n        dataTile.x * f * scale * 256,\n        dataTile.y * f * scale * 256,\n      );\n      dim = dim * scale;\n    }\n    return { dataTile: dataTile, scale: scale, origin: origin, dim: dim };\n  }\n\n  public async getBbox(\n    displayZoom: number,\n    bounds: Bbox,\n  ): Promise<Array<PreparedTile>> {\n    const needed = this.dataTilesForBounds(displayZoom, bounds);\n    const result = await Promise.all(\n      needed.map((tt) => this.tileCache.get(tt.dataTile)),\n    );\n    return result.map((data, i) => {\n      const tt = needed[i];\n      return {\n        data: data,\n        z: displayZoom,\n        dataTile: tt.dataTile,\n        scale: tt.scale,\n        dim: tt.dim,\n        origin: tt.origin,\n      };\n    });\n  }\n\n  public async getDisplayTile(displayTile: Zxy): Promise<PreparedTile> {\n    const tt = this.dataTileForDisplayTile(displayTile);\n    const data = await this.tileCache.get(tt.dataTile);\n    return {\n      data: data,\n      z: displayTile.z,\n      dataTile: tt.dataTile,\n      scale: tt.scale,\n      origin: tt.origin,\n      dim: tt.dim,\n    };\n  }\n\n  public queryFeatures(\n    lng: number,\n    lat: number,\n    displayZoom: number,\n    brushSize: number,\n  ) {\n    const roundedZoom = Math.round(displayZoom);\n    const dataZoom = Math.min(roundedZoom - this.levelDiff, this.maxDataLevel);\n    const brushSizeAtZoom = brushSize / (1 << (roundedZoom - dataZoom));\n    return this.tileCache.queryFeatures(lng, lat, dataZoom, brushSizeAtZoom);\n  }\n}\n\nexport interface SourceOptions {\n  levelDiff?: number;\n  maxDataZoom?: number;\n  url?: PMTiles | string;\n  sources?: Record<string, SourceOptions>;\n}\n\nexport const sourcesToViews = (options: SourceOptions) => {\n  const sourceToViews = (o: SourceOptions): View => {\n    const levelDiff = o.levelDiff === undefined ? 1 : o.levelDiff;\n    const maxDataZoom = o.maxDataZoom || 15;\n    let source: TileSource;\n    if (typeof o.url === \"string\") {\n      if (new URL(o.url, \"http://example.com\").pathname.endsWith(\".pmtiles\")) {\n        source = new PmtilesSource(o.url, true);\n      } else {\n        source = new ZxySource(o.url, true);\n      }\n    } else if (o.url) {\n      source = new PmtilesSource(o.url, true);\n    } else {\n      throw new Error(`Invalid source ${o.url}`);\n    }\n\n    const cache = new TileCache(source, (256 * 1) << levelDiff);\n    return new View(cache, maxDataZoom, levelDiff);\n  };\n\n  const sources = new Map<string, View>();\n  if (options.sources) {\n    for (const key in options.sources) {\n      sources.set(key, sourceToViews(options.sources[key]));\n    }\n  } else {\n    sources.set(\"\", sourceToViews(options));\n  }\n  return sources;\n};\n","import Point from \"@mapbox/point-geometry\";\nimport { Index } from \"./labeler\";\nimport { PaintSymbolizer } from \"./symbolizer\";\nimport { Bbox, Feature } from \"./tilecache\";\nimport { PreparedTile, transformGeom } from \"./view\";\n\nexport type Filter = (zoom: number, feature: Feature) => boolean;\n\nexport interface PaintRule {\n  id?: string;\n  minzoom?: number;\n  maxzoom?: number;\n  dataSource?: string;\n  dataLayer: string;\n  symbolizer: PaintSymbolizer;\n  filter?: Filter;\n}\n\nexport function paint(\n  ctx: CanvasRenderingContext2D,\n  z: number,\n  preparedTilemap: Map<string, PreparedTile[]>,\n  labelData: Index | null,\n  rules: PaintRule[],\n  bbox: Bbox,\n  origin: Point,\n  clip: boolean,\n  debug?: string,\n) {\n  const start = performance.now();\n  ctx.save();\n  ctx.miterLimit = 2;\n\n  for (const rule of rules) {\n    if (rule.minzoom && z < rule.minzoom) continue;\n    if (rule.maxzoom && z > rule.maxzoom) continue;\n    const preparedTiles = preparedTilemap.get(rule.dataSource || \"\");\n    if (!preparedTiles) continue;\n    for (const preparedTile of preparedTiles) {\n      const layer = preparedTile.data.get(rule.dataLayer);\n      if (layer === undefined) continue;\n      if (rule.symbolizer.before) rule.symbolizer.before(ctx, preparedTile.z);\n\n      const po = preparedTile.origin;\n      const dim = preparedTile.dim;\n      const ps = preparedTile.scale;\n      ctx.save();\n\n      // apply clipping to the tile\n      // find the smallest of all the origins\n      if (clip) {\n        ctx.beginPath();\n        const minX = Math.max(po.x - origin.x, bbox.minX - origin.x); // - 0.5;\n        const minY = Math.max(po.y - origin.y, bbox.minY - origin.y); // - 0.5;\n        const maxX = Math.min(po.x - origin.x + dim, bbox.maxX - origin.x); // + 0.5;\n        const maxY = Math.min(po.y - origin.y + dim, bbox.maxY - origin.y); // + 0.5;\n        ctx.rect(minX, minY, maxX - minX, maxY - minY);\n        ctx.clip();\n      }\n\n      ctx.translate(po.x - origin.x, po.y - origin.y);\n\n      // TODO fix seams in static mode\n      // if (clip) {\n      //     // small fudge factor in static mode to fix seams\n      //     ctx.translate(dim / 2, dim / 2);\n      //     ctx.scale(1 + 1 / dim, 1 + 1 / dim);\n      //     ctx.translate(-dim / 2, -dim / 2);\n      // }\n\n      for (const feature of layer) {\n        let geom = feature.geom;\n        const fbox = feature.bbox;\n        if (\n          fbox.maxX * ps + po.x < bbox.minX ||\n          fbox.minX * ps + po.x > bbox.maxX ||\n          fbox.minY * ps + po.y > bbox.maxY ||\n          fbox.maxY * ps + po.y < bbox.minY\n        ) {\n          continue;\n        }\n        if (rule.filter && !rule.filter(preparedTile.z, feature)) continue;\n        if (ps !== 1) {\n          geom = transformGeom(geom, ps, new Point(0, 0));\n        }\n        rule.symbolizer.draw(ctx, geom, preparedTile.z, feature);\n      }\n      ctx.restore();\n    }\n  }\n\n  if (clip) {\n    ctx.beginPath();\n    ctx.rect(\n      bbox.minX - origin.x,\n      bbox.minY - origin.y,\n      bbox.maxX - bbox.minX,\n      bbox.maxY - bbox.minY,\n    );\n    ctx.clip();\n  }\n\n  if (labelData) {\n    const matches = labelData.searchBbox(bbox, Infinity);\n    for (const label of matches) {\n      ctx.save();\n      ctx.translate(label.anchor.x - origin.x, label.anchor.y - origin.y);\n      label.draw(ctx);\n      ctx.restore();\n      if (debug) {\n        ctx.lineWidth = 0.5;\n        ctx.strokeStyle = debug;\n        ctx.fillStyle = debug;\n        ctx.globalAlpha = 1;\n        ctx.fillRect(\n          label.anchor.x - origin.x - 2,\n          label.anchor.y - origin.y - 2,\n          4,\n          4,\n        );\n        for (const bbox of label.bboxes) {\n          ctx.strokeRect(\n            bbox.minX - origin.x,\n            bbox.minY - origin.y,\n            bbox.maxX - bbox.minX,\n            bbox.maxY - bbox.minY,\n          );\n        }\n      }\n    }\n  }\n  ctx.restore();\n  return performance.now() - start;\n}\n","// biome-ignore lint: leaflet 1.x\ndeclare const L: any;\n\nimport Point from \"@mapbox/point-geometry\";\n\nimport type { Coords } from \"leaflet\";\nimport { namedFlavor } from \"@protomaps/basemaps\";\nimport { PMTiles } from \"pmtiles\";\nimport { labelRules, paintRules } from \"../default_style/style\";\nimport { LabelRule, Labelers } from \"../labeler\";\nimport { PaintRule, paint } from \"../painter\";\nimport { PickedFeature } from \"../tilecache\";\nimport { PreparedTile, SourceOptions, sourcesToViews } from \"../view\";\n\nconst timer = (duration: number) => {\n  return new Promise<void>((resolve) => {\n    setTimeout(() => {\n      resolve();\n    }, duration);\n  });\n};\n\n// replacement for Promise.allSettled (requires ES2020+)\n// this is called for every tile render,\n// so ensure font loading failure does not make map rendering fail\ntype Status = {\n  status: string;\n  value?: unknown;\n  reason: Error;\n};\n\nconst reflect = (promise: Promise<Status>) => {\n  return promise.then(\n    (v) => {\n      return { status: \"fulfilled\", value: v };\n    },\n    (error) => {\n      return { status: \"rejected\", reason: error };\n    },\n  );\n};\n\ntype DoneCallback = (error?: Error, tile?: HTMLElement) => void;\ntype KeyedHtmlCanvasElement = HTMLCanvasElement & { key: string };\n\nexport interface LeafletLayerOptions extends L.GridLayerOptions {\n  bounds?: L.LatLngBoundsExpression;\n  attribution?: string;\n  debug?: string;\n  lang?: string;\n  tileDelay?: number;\n  noWrap?: boolean;\n  paintRules?: PaintRule[];\n  labelRules?: LabelRule[];\n  tasks?: Promise<Status>[];\n  maxDataZoom?: number;\n  url?: PMTiles | string;\n  sources?: Record<string, SourceOptions>;\n  flavor?: string;\n  backgroundColor?: string;\n  devicePixelRatio?: number;\n}\n\nconst leafletLayer = (options: LeafletLayerOptions = {}) => {\n  class LeafletLayer extends L.GridLayer {\n    public paintRules: PaintRule[];\n    public labelRules: LabelRule[];\n    public backgroundColor?: string;\n    public devicePixelRatio: number;\n\n    constructor(options: LeafletLayerOptions = {}) {\n      if (options.noWrap && !options.bounds)\n        options.bounds = [\n          [-90, -180],\n          [90, 180],\n        ];\n      if (options.attribution == null)\n        options.attribution =\n          '<a href=\"https://protomaps.com\">Protomaps</a>  <a href=\"https://openstreetmap.org/copyright\">OpenStreetMap</a>';\n      super(options);\n\n      if (options.flavor) {\n        const flavor = namedFlavor(options.flavor);\n        this.paintRules = paintRules(flavor);\n        this.labelRules = labelRules(flavor, options.lang || \"en\");\n        this.backgroundColor = flavor.background;\n      } else {\n        this.paintRules = options.paintRules || [];\n        this.labelRules = options.labelRules || [];\n        this.backgroundColor = options.backgroundColor;\n      }\n\n      this.devicePixelRatio =\n        options.devicePixelRatio ?? window.devicePixelRatio;\n\n      this.lastRequestedZ = undefined;\n      this.tasks = options.tasks || [];\n\n      this.views = sourcesToViews(options);\n\n      this.debug = options.debug;\n      const scratch = document.createElement(\"canvas\").getContext(\"2d\");\n      this.scratch = scratch;\n      this.onTilesInvalidated = (tiles: Set<string>) => {\n        for (const t of tiles) {\n          this.rerenderTile(t);\n        }\n      };\n      this.labelers = new Labelers(\n        this.scratch,\n        this.labelRules,\n        16,\n        this.onTilesInvalidated,\n      );\n      this.tileSize = 256 * this.devicePixelRatio;\n      this.tileDelay = options.tileDelay || 3;\n      this.lang = options.lang;\n    }\n\n    public async renderTile(\n      coords: Coords,\n      element: KeyedHtmlCanvasElement,\n      key: string,\n      done = () => {},\n    ) {\n      this.lastRequestedZ = coords.z;\n\n      const promises = [];\n      for (const [k, v] of this.views) {\n        const promise = v.getDisplayTile(coords);\n        promises.push({ key: k, promise: promise });\n      }\n      const tileResponses = await Promise.all(\n        promises.map((o) => {\n          return o.promise.then(\n            (v: PreparedTile[]) => {\n              return { status: \"fulfilled\", value: v, key: o.key };\n            },\n            (error: Error) => {\n              return { status: \"rejected\", reason: error, key: o.key };\n            },\n          );\n        }),\n      );\n\n      const preparedTilemap = new Map<string, PreparedTile[]>();\n      for (const tileResponse of tileResponses) {\n        if (tileResponse.status === \"fulfilled\") {\n          preparedTilemap.set(tileResponse.key, [tileResponse.value]);\n        } else {\n          if (tileResponse.reason.name === \"AbortError\") {\n            // do nothing\n          } else {\n            console.error(tileResponse.reason);\n          }\n        }\n      }\n\n      if (element.key !== key) return;\n      if (this.lastRequestedZ !== coords.z) return;\n\n      await Promise.all(this.tasks.map(reflect));\n\n      if (element.key !== key) return;\n      if (this.lastRequestedZ !== coords.z) return;\n\n      const layoutTime = this.labelers.add(coords.z, preparedTilemap);\n\n      if (element.key !== key) return;\n      if (this.lastRequestedZ !== coords.z) return;\n\n      const labelData = this.labelers.getIndex(coords.z);\n\n      if (!this._map) return; // the layer has been removed from the map\n\n      const center = this._map.getCenter().wrap();\n      const pixelBounds = this._getTiledPixelBounds(center);\n      const tileRange = this._pxBoundsToTileRange(pixelBounds);\n      const tileCenter = tileRange.getCenter();\n      const priority = coords.distanceTo(tileCenter) * this.tileDelay;\n\n      await timer(priority);\n\n      if (element.key !== key) return;\n      if (this.lastRequestedZ !== coords.z) return;\n\n      const buf = 16;\n      const bbox = {\n        minX: 256 * coords.x - buf,\n        minY: 256 * coords.y - buf,\n        maxX: 256 * (coords.x + 1) + buf,\n        maxY: 256 * (coords.y + 1) + buf,\n      };\n      const origin = new Point(256 * coords.x, 256 * coords.y);\n\n      element.width = this.tileSize;\n      element.height = this.tileSize;\n      const ctx = element.getContext(\"2d\");\n      if (!ctx) {\n        console.error(\"Failed to get Canvas context\");\n        return;\n      }\n      ctx.setTransform(this.tileSize / 256, 0, 0, this.tileSize / 256, 0, 0);\n      ctx.clearRect(0, 0, 256, 256);\n\n      if (this.backgroundColor) {\n        ctx.save();\n        ctx.fillStyle = this.backgroundColor;\n        ctx.fillRect(0, 0, 256, 256);\n        ctx.restore();\n      }\n\n      let paintingTime = 0;\n\n      const paintRules = this.paintRules;\n\n      paintingTime = paint(\n        ctx,\n        coords.z,\n        preparedTilemap,\n        this.xray ? null : labelData,\n        paintRules,\n        bbox,\n        origin,\n        false,\n        this.debug,\n      );\n\n      if (this.debug) {\n        ctx.save();\n        ctx.fillStyle = this.debug;\n        ctx.font = \"600 12px sans-serif\";\n        ctx.fillText(`${coords.z} ${coords.x} ${coords.y}`, 4, 14);\n\n        ctx.font = \"12px sans-serif\";\n        let ypos = 28;\n        for (const [k, v] of preparedTilemap) {\n          const dt = v[0].dataTile;\n          ctx.fillText(`${k + (k ? \" \" : \"\") + dt.z} ${dt.x} ${dt.y}`, 4, ypos);\n          ypos += 14;\n        }\n\n        ctx.font = \"600 10px sans-serif\";\n        if (paintingTime > 8) {\n          ctx.fillText(`${paintingTime.toFixed()} ms paint`, 4, ypos);\n          ypos += 14;\n        }\n\n        if (layoutTime > 8) {\n          ctx.fillText(`${layoutTime.toFixed()} ms layout`, 4, ypos);\n        }\n        ctx.strokeStyle = this.debug;\n\n        ctx.lineWidth = 0.5;\n        ctx.beginPath();\n        ctx.moveTo(0, 0);\n        ctx.lineTo(0, 256);\n        ctx.stroke();\n\n        ctx.lineWidth = 0.5;\n        ctx.beginPath();\n        ctx.moveTo(0, 0);\n        ctx.lineTo(256, 0);\n        ctx.stroke();\n\n        ctx.restore();\n      }\n      done();\n    }\n\n    public rerenderTile(key: string) {\n      for (const unwrappedK in this._tiles) {\n        const wrappedCoord = this._wrapCoords(\n          this._keyToTileCoords(unwrappedK),\n        );\n        if (key === this._tileCoordsToKey(wrappedCoord)) {\n          this.renderTile(wrappedCoord, this._tiles[unwrappedK].el, key);\n        }\n      }\n    }\n\n    // a primitive way to check the features at a certain point.\n    // it does not support hover states, cursor changes, or changing the style of the selected feature,\n    // so is only appropriate for debugging or very basic use cases.\n    // those features are outside of the scope of this library:\n    // for fully pickable, interactive features, use MapLibre GL JS instead.\n    public queryTileFeaturesDebug(\n      lng: number,\n      lat: number,\n      brushSize = 16,\n    ): Map<string, PickedFeature[]> {\n      const featuresBySourceName = new Map<string, PickedFeature[]>();\n      for (const [sourceName, view] of this.views) {\n        featuresBySourceName.set(\n          sourceName,\n          view.queryFeatures(lng, lat, this._map.getZoom(), brushSize),\n        );\n      }\n      return featuresBySourceName;\n    }\n\n    public clearLayout() {\n      this.labelers = new Labelers(\n        this.scratch,\n        this.labelRules,\n        16,\n        this.onTilesInvalidated,\n      );\n    }\n\n    public rerenderTiles() {\n      for (const unwrappedK in this._tiles) {\n        const wrappedCoord = this._wrapCoords(\n          this._keyToTileCoords(unwrappedK),\n        );\n        const key = this._tileCoordsToKey(wrappedCoord);\n        this.renderTile(wrappedCoord, this._tiles[unwrappedK].el, key);\n      }\n    }\n\n    public createTile(coords: Coords, showTile: DoneCallback) {\n      const element = L.DomUtil.create(\"canvas\", \"leaflet-tile\");\n      element.lang = this.lang;\n\n      const key = this._tileCoordsToKey(coords);\n      element.key = key;\n\n      this.renderTile(coords, element, key, () => {\n        showTile(undefined, element);\n      });\n\n      return element;\n    }\n\n    public _removeTile(key: string) {\n      const tile = this._tiles[key];\n      if (!tile) {\n        return;\n      }\n      tile.el.removed = true;\n      tile.el.key = undefined;\n      L.DomUtil.removeClass(tile.el, \"leaflet-tile-loaded\");\n      tile.el.width = tile.el.height = 0;\n      L.DomUtil.remove(tile.el);\n      delete this._tiles[key];\n      this.fire(\"tileunload\", {\n        tile: tile.el,\n        coords: this._keyToTileCoords(key),\n      });\n    }\n  }\n  return new LeafletLayer(options);\n};\n\nexport { leafletLayer };\n","import potpack from \"potpack\";\n\n// https://github.com/tangrams/tangram/blob/master/src/styles/text/font_manager.js\nexport const Font = (name: string, url: string, weight: string) => {\n  const ff = new FontFace(name, `url(${url})`, { weight: weight });\n  document.fonts.add(ff);\n  return ff.load();\n};\n\ninterface Sprite {\n  x: number;\n  y: number;\n  w: number;\n  h: number;\n}\n\ninterface PotPackInput {\n  x?: number;\n  y?: number;\n  w: number;\n  h: number;\n  id: string;\n  img: HTMLImageElement;\n}\n\nconst mkimg = async (src: string): Promise<HTMLImageElement> => {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve(img);\n    img.onerror = () => reject(\"Invalid SVG\");\n    img.src = src;\n  });\n};\n\nconst MISSING = `\n<svg width=\"20px\" height=\"20px\" viewBox=\"0 0 50 50\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\n    <rect width=\"50\" height=\"50\" fill=\"#cccccc\"/>\n    <g transform=\"translate(5,5)\">\n        <path fill=\"none\" stroke=\"#666666\" stroke-width=\"7\" d=\"m11,12a8.5,8 0 1,1 17,0q0,4-4,6t-4.5,4.5-.4,4v.2m0,3v7\"/>\n    </g>\n</svg>\n`;\n\nexport class Sheet {\n  src: string;\n  canvas: HTMLCanvasElement;\n  mapping: Map<string, Sprite>;\n  missingBox: Sprite;\n\n  constructor(src: string) {\n    this.src = src;\n    this.canvas = document.createElement(\"canvas\");\n    this.mapping = new Map<string, Sprite>();\n    this.missingBox = { x: 0, y: 0, w: 0, h: 0 };\n  }\n\n  async load() {\n    let src = this.src;\n    const scale = window.devicePixelRatio;\n    if (src.endsWith(\".html\")) {\n      const c = await fetch(src);\n      src = await c.text();\n    }\n    const tree = new window.DOMParser().parseFromString(src, \"text/html\");\n    const icons = Array.from(tree.body.children);\n\n    const missingImg = await mkimg(\n      `data:image/svg+xml;base64,${btoa(MISSING)}`,\n    );\n\n    const boxes: PotPackInput[] = [\n      {\n        w: missingImg.width * scale,\n        h: missingImg.height * scale,\n        img: missingImg,\n        id: \"\",\n      },\n    ];\n\n    const serializer = new XMLSerializer();\n    for (const ps of icons) {\n      const svg64 = btoa(serializer.serializeToString(ps));\n      const image64 = `data:image/svg+xml;base64,${svg64}`;\n      const img = await mkimg(image64);\n      boxes.push({\n        w: img.width * scale,\n        h: img.height * scale,\n        img: img,\n        id: ps.id,\n      });\n    }\n\n    const packresult = potpack(boxes);\n    this.canvas.width = packresult.w;\n    this.canvas.height = packresult.h;\n    const ctx = this.canvas.getContext(\"2d\");\n    if (ctx) {\n      for (const box of boxes) {\n        if (box.x !== undefined && box.y !== undefined) {\n          ctx.drawImage(box.img, box.x, box.y, box.w, box.h);\n          if (box.id)\n            this.mapping.set(box.id, {\n              x: box.x,\n              y: box.y,\n              w: box.w,\n              h: box.h,\n            });\n          else this.missingBox = { x: box.x, y: box.y, w: box.w, h: box.h };\n        }\n      }\n    }\n    return this;\n  }\n\n  get(name: string): Sprite {\n    let result = this.mapping.get(name);\n    if (!result) result = this.missingBox;\n    return result;\n  }\n}\n"],"mappings":"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","names":["Point","namedFlavor","mix","Point","_StringAttr","c","defaultValue","z","f","__name","StringAttr","_NumberAttr","NumberAttr","_TextAttr","options","_a","retval","labelProps","property","transform","word","TextAttr","_FontAttr","_b","style","weight","size","family","FontAttr","_ArrayAttr","ArrayAttr","Point","linelabel","__name","pts","maxAngleDelta","targetLen","chunks","a","b","c","i","n","d","abmag","bcmag","abx","aby","bcx","bcy","dt","iStart","dStart","__pow","simpleLabel","mls","minimum","repeatDistance","cellSize","candidates","ls","segments","segment","start","Point","end","normalized","lineCells","length","spacing","dx","dy","dist","retval","factor","linebreak","str","maxUnits","endIndex","spaceBefore","spaceAfter","first","after","__name","CJK_CHARS","cjkTest","Point","VectorTile","Protobuf","PMTiles","GeomType","toIndex","c","__name","loadGeomAndBbox","pbf","geometry","scale","end","cmd","length","x","y","x1","x2","y1","y2","lines","line","cmdLen","Point","parseTile","buffer","tileSize","v","VectorTile","Protobuf","result","key","value","features","layer","i","loaded","numVertices","part","_PmtilesSource","url","shouldCancelZooms","PMTiles","__async","za","controller","signal","PmtilesSource","_ZxySource","resolve","reject","resp","e","ZxySource","R","MAX_LATITUDE","MAXCOORD","project","latlng","d","constrainedLat","sin","sqr","dist2","w","distToSegmentSquared","p","l2","t","isInRing","point","ring","inside","j","xi","yi","xj","yj","isCcw","area","pointInPolygon","geom","isInCurrentExterior","pointMinDistToPoints","min","l","dist","pointMinDistToLines","_TileCache","source","idx","entry","ifentry","tile","ifentry2","f","minUsed","minKey","lng","lat","zoom","brushSize","projected","normalized","onZoom","tileX","tileY","retval","center","layerName","layerArr","feature","TileCache","Justify","TextPlacements","createPattern","__name","width","height","fn","canvas","ctx","_PolygonSymbolizer","options","_a","StringAttr","NumberAttr","z","patten","geom","f","doStroke","drawPath","poly","p","pt","PolygonSymbolizer","arr","base","a","b","getStopIndex","input","stops","idx","interpolate","factor","start","end","computeInterpolationFactor","difference","progress","__pow","exp","step","output0","retval","i","linear","_LineSymbolizer","ArrayAttr","strokePath","ls","LineSymbolizer","_IconSymbolizer","layout","feature","Point","loc","bbox","IconSymbolizer","_CircleSymbolizer","radius","CircleSymbolizer","_ShieldSymbolizer","FontAttr","TextAttr","property","font","metrics","ascent","descent","ShieldSymbolizer","_FlexSymbolizer","list","labels","label","anchor","draws","newGeom","mergeBbox","sub","FlexSymbolizer","b1","b2","_GroupSymbolizer","first","d","GroupSymbolizer","_CenteredSymbolizer","symbolizer","placed","firstLabel","centered","CenteredSymbolizer","_Padding","padding","Padding","_TextSymbolizer","letterSpacing","lines","linebreak","longestLine","longestLineLen","line","lineHeight","extra","textStrokeWidth","y","startX","xPos","letter","TextSymbolizer","_CenteredTextSymbolizer","CenteredTextSymbolizer","_OffsetSymbolizer","_b","_c","fb","offsetXvalue","offsetYvalue","justifyValue","placements","ddOffsetX","ddOffsetY","ddJustify","ddPlacements","offsetX","offsetY","getBbox","o","origin","justify","draw","placeLabelInPoint","placement","xAxisOffset","yAxisOffset","labelWidth","labelHalfWidth","labelHalfHeight","labelBottom","labelCenterHeight","fixedJustify","OffsetSymbolizer","_OffsetTextSymbolizer","OffsetTextSymbolizer","LineLabelPlacement","_LineLabelSymbolizer","name","minLabelableDim","fbbox","repeatDistance","cellSize","labelCandidates","simpleLabel","candidate","dx","dy","bboxes","lineCells","c","heightPlacement","lineWidth","LineLabelSymbolizer","getString","__name","props","key","val","getNumber","paintRules","t","PolygonSymbolizer","z","f","landcover","kind","mix","LineSymbolizer","exp","minAdminLevel","labelRules","lang","nametags","LineLabelSymbolizer","CenteredTextSymbolizer","linear","minZoom","weight","size","popRank","a","b","aRank","bRank","GroupSymbolizer","CircleSymbolizer","OffsetTextSymbolizer","Point","rBush","Point","transformGeom","__name","geom","scale","translate","retval","arr","loop","coord","wrap","val","z","dim","_View","tileCache","maxDataLevel","levelDiff","displayZoom","bounds","fractional","__pow","needed","Point","f","basetileSize","dataZoom","mintileX","mintileY","maxtileX","maxtileY","tx","ty","origin","displayTile","dataTile","__async","tt","data","i","lng","lat","brushSize","roundedZoom","brushSizeAtZoom","View","sourcesToViews","options","sourceToViews","o","maxDataZoom","source","PmtilesSource","ZxySource","cache","TileCache","sources","key","covering","__name","displayZoom","tileWidth","bbox","f","minx","miny","maxx","maxy","leveldiff","retval","x","wrappedX","y","toIndex","_Index","dim","maxLabeledTiles","rBush","tileKey","key","order","labels","match","label","dist","testBbox","collision","newSet","indexedLabel","entry","wrapsLeft","wrapsRight","shift","newBboxes","duplicateLabel","Point","keyAdded","added","maxKey","maxDist","keysForDs","existingKey","existing","__pow","keyToRemove","indexedLabels","entriesToDelete","labelToRemove","c","Index","_Labeler","z","scratch","labelRules","callback","preparedTilemap","start","keysAdding","k","preparedTiles","preparedTile","tilesInvalidated","rule","dsName","layer","feats","a","b","layout","feature","transformed","transformGeom","labelAdded","conflicts","conflict","touched","s","allAdded","Labeler","_Labelers","labeler","Labelers","Point","paint","ctx","z","preparedTilemap","labelData","rules","bbox","origin","clip","debug","start","rule","preparedTiles","preparedTile","layer","po","dim","ps","minX","minY","maxX","maxY","feature","geom","fbox","transformGeom","Point","matches","label","__name","R","MAX_LATITUDE","MAXCOORD","project","__name","latlng","d","constrainedLat","sin","Point","unproject","point","instancedProject","origin","displayZoom","projected","__pow","instancedUnproject","normalized","getZoom","degreesLng","cssPixels","_Static","options","flavor","namedFlavor","paintRules","labelRules","sourcesToViews","ctx","width","height","__async","center","bbox","promises","k","v","promise","tileResponses","o","error","preparedTilemap","tileResponse","start","labeler","Labeler","layoutTime","p","paint","idx","preparedTile","dt","_0","_1","_2","canvas","dpr","topLeft","bottomRight","deltaDegrees","_3","Static","Point","namedFlavor","timer","__name","duration","resolve","reflect","promise","v","error","leafletLayer","options","_LeafletLayer","_a","flavor","namedFlavor","paintRules","labelRules","sourcesToViews","scratch","tiles","t","Labelers","coords","element","key","done","__async","promises","k","tileResponses","o","preparedTilemap","tileResponse","layoutTime","labelData","center","pixelBounds","tileCenter","priority","buf","bbox","origin","Point","ctx","paintingTime","paint","ypos","dt","unwrappedK","wrappedCoord","lng","lat","brushSize","featuresBySourceName","sourceName","view","showTile","tile","LeafletLayer","potpack","Font","__name","name","url","weight","ff","mkimg","src","__async","resolve","reject","img","MISSING","_Sheet","scale","tree","icons","missingImg","boxes","serializer","ps","image64","packresult","potpack","ctx","box","result","Sheet"]}